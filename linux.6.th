\chapter{โปรเซส}
ในบทที่ผ่านมาเราได้เรียนรู้การใช้โปรแกรมคำสั่งพื้นฐานต่างๆที่ใช้ในลินุกซ์ไปแล้ว. ในบทนี้จะแนะนำคำสั่งที่เกี่ยวกับระบบปฏิบัติการโดยซึ่งได้แก่ลินุกซ์เคอร์เนล. เนื้อหาของบทนี้ส่วนหนึ่งจะเกี่ยวข้องกับการทำงานของเคอร์เนลโดยใช้มองผ่านการใช้งานคำสั่งที่เกี่ยวข้องเช่น \cmd{ps}, \cmd{kill} เป็นต้น, ช่วยให้ผู้อ่านเข้าใจการทำงานของระบบปฏิบัติการซึ่งได้แก่เคอร์เนลได้ดียิ่งขึ้น.
%ในบทนี้จะแนะนำโปรแกรมคำสั่งต่างๆที่เกี่ยวข้องกับตัวระบบปฏิบัติการเช่นคำสั่ง \cmd{ps}, \cmd{signal} ฯลฯ. การเรียนรู้คำสั่งเหล่านี้ยังเป็นการเรียนรู้การทำงานของเคอร์เนลไปในตัวด้วย.

\section{โปรเซส (process)}\label{sec:process}
นิยามอย่างง่ายของโปรแกรมคือไฟล์ที่มีเนื้อหาเป็นภาษาเครื่องกลและหน่วยประมวลผลสามารถแปลความกระทำการได้. ส่วนนิยามอย่างง่ายของโปรเซสคือโปรแกรมที่กำลังทำงานอยู่.  เวลารันโปรแกรม, เคอร์เนลจะอ่านข้อมูลที่อยู่ในไฟล์โปรแกรมเข้าไปไว้ในหน่วยความจำ, และหน่วยประมวลผลจะกระทำการตามคำสั่งต่อไป. สภาพที่ระบบปฏิบัติการโหลดภาษาเครื่องกล (โปรแกรม) นั้นสู่หน่วยความจำแล้วกระทำการอยู่เรียกว่า\emph{โปรเซส (process)}\gindex{process}\gindex{โปรเซส}. ในมุมมองของเคอร์เนลมักจะเรียกโปรเซสว่า\emph{ทาส์ก (task)} ซึ่งมีความหมายเหมือนกัน.

\begin{figure}[!htb]
\plfigure{.8}{task_switching.eps}{การสลับการทำงานของหน่วยประมวลผล.}{task_switching}
\end{figure}


ลินุกซ์เป็นระบบปฏิบัติการแบบระบบมัลติทาส์ก, ในระบบมีโปรเซสหลายโปรเซสทำงานหลายอย่างพร้อมๆกัน. ในความเป็นจริงแล้วหน่วยประมวลผลซึ่งเป็นตัวกระทำการต่างๆสามารถทำงานได้ทีละหนึ่งอย่าง, หนึ่งคำสั่ง. แต่เนื่องจากการทำงานของหน่วยประมวลผลสั้นมากทำให้ผู้ใช้รู้สึกเหมือนกับโปรเซสหลายๆตัวทำงานได้พร้อมๆกัน. การที่หน่วยประมวลเปลี่ยนการทำงานจากโปรเซสหนึ่งไปอีกโปรเซสหนึ่งเรียกว่า \emph{context switching}\gindex{context switching} คือเนื้อหาการทำงาน, ข้อมูลที่ต้องจัดการเปลี่ยนไป. หน่วยประมวลเป็นตัวที่คำนวณข้อมูล, เรียกอ่านข้อมูลจากหน่วยความจำ, จากฮาร์ดิกส์หรือฮาร์ดแวร์. การเรียกอ่านเขียนข้อมูลโดยเฉพาะฮาร์ดดิสก์นั้นจะใช้เวลามากกว่าการประมวลผล. ดังนั้นโปรเซสที่ต้องเขียนอ่านข้อมูลจะถูก\emph{บล็อก (block)} และเปลี่ยนไปอยู่ในสภาพรอ (wait). กล่าวคือแทนที่หน่วยประมวลจะรอให้ข้อมูลที่ต้องการใช้มาถึงก็จะหยุดการทำงานของโปรเซสนั้นชั่วคราวไปใช้เวลาทำงานกับโปรเซสอื่นเพื่อไม่ให้เสียเวลา. พอได้รับ \emph{interrupt} จากฮาร์ดแวร์นั้นๆเช่นเรียกอ่านเขียนข้อมูลเสร็จแล้วก็จะจัดการกับโปรเซสนั้นอีกที.


\begin{figure}[!tb]
%\plfigure{.6}{virt_phy.eps}{ความสัมพันธ์ระหว่างหน่วยความจำเสมือนและหน่วยความจำจริง.}{virtualmem}
\plfigure{.75}{process.eps}{ความสัมพันธ์ระหว่างโปรเซสและหน่วยความจำ.}{process}
\end{figure}

ตามทฤษฎีแล้ว, โปรเซสแต่ละตัวจะมี \emph{address space} %
\myvocab{a}{address space}{หน่วยความจำเสมือน (virtual memory) ที่โปรเซสสามารถใช้ได้. เคอร์เนลจะแม็ป (map) address space เข้ากับหน่วยความจำจริง (physical memory) เวลาใช้งาน.}%
เป็นของตัวเอง. Address space คือพื้นที่หน่วยความจำเสมือน (virtual memory) เป็นที่เก็บข้อมูลของโปรเซสสำคัญๆเช่น \emph{code}, %
\myvocab{c}{code}{ส่วนที่เป็นข้อมูลสำหรับหน่วยประมวลผลสั่งคำสั่ง.}%
 \emph{data}, %
\myvocab{d}{data}{ส่วนที่เป็นข้อมูลตัวแปรส่วนกลาง (global variable) ของโปรเซส.}%
\emph{stack}. %
\myvocab{s}{stack}{โครงสร้างข้อมูล (data structure) แบบเข้าก่อนออกหลัง (first-in last-out) สำหรับเก็บตัวแปรเฉพาะที่ (local variable) ในฟังก์ชัน ฯลฯ. พื้นที่สำหรับ stack จะอยู่ท้ายๆของหน่วยความจำ.}%
หน่วยความจำเสมือนสำหรับหน่วยประมวลผลสถาปัตยกรรมแบบ 32 บิตจะมีพื้นที่ 4GB ($2^{32}$ ไบต์) และพื้นที่ 1GB ท้ายของหน่วยความจำจะใช้โดยเคอร์เนล. พื้นที่ที่ใช้โดยเคอร์เนลจะเป็นส่วนเดียวกันสำหรับทุกโปรเซส. เคอร์เนลเป็นตัวจัดการหน่วยความจำโดยแม็ป (map) หน่วยความจำเสมือนนี้เข้ากับหน่วยความจำจริง (physical memory) ซึ่งไม่จำเป็นต้องแม็ปหน่วยความจำทั้งหมดที่โปรเซสใช้เข้ากับหน่วยความจำจริง. ส่วนของหน่วยความจำที่ไม่จำเป็นต้องอยู่ในหน่วยความจำจริงจะถูกเคอร์เนล swap out ไปเก็บไว้ที่ฮาร์ดดิสก์ส่วนที่เป็น swap. เมื่อโปรเซสต้องพยายามเข้าถึง address ที่ข้อมูลไม่อยู่ในหน่วยความจำจริง, จะเกิด \emph{page fault}\gindex{page fault} คือมีข้อมูลใน address ที่ระบุแต่ข้อมูลนั้นไม่ได้อยู่ในหน่วยความจำจริง, เคอร์เนลต้องไปดึงข้อมูลที่อยู่ใน swap กลับมาในหน่วยความจำจริง.


เวลาที่โปรเซสหนึ่งทำงาน, หน่วยประมวลผลจะทำงานและใช้เวลาในการแปลคำสั่งของโปรเซสนั้นๆ. เวลาหน่วยประมวลผลทำงานจะมีสภาพแบบใดแบบหนึ่งได้แก่ \emph{user mode}\gindex{user mode} หรือ \emph{kernel mode}\gindex{kernel mode}. เวลาที่หน่วยประมวลทำงานอยู่ใน user mode, การเข้าถึงหน่วยความจำจะถูกจำกัดไว้ในส่วนที่อนุญาตให้เข้าถึงได้เท่านั้นและไม่สามารถใช้ฮาร์ดแวร์ต่างๆได้โดยตรง. การทำงานของโปรเซสโดยทั่วไปจะอยู่ใน user mode. เมื่อโปรเซสนั้นเรียกใช้ซิสเต็มคอล (system call), หน่วยประมวลจะเปลี่ยนสภาพการทำงานไปอยู่ใน kernel mode. ใน kernel mode, หน่วยประมวลผลสามารถเข้าถึงหน่วยความจำได้ทุกส่วนและติดต่อกับฮาร์ดแวร์ได้. เมื่อจบการทำงานใน kernel mode แล้วก็จะกลับไปเป็น user mode ใหม่. เป็นเช่นนี้ไปเรื่อยๆ.

โปรเซส





\section{สำรวจโปรเซส}

คำสั่งที่ใช้แสดงรายการโปรเซสที่มีอยู่ระบบได้แก่ \cmd{ps}\cindex{ps}\refcmd{ps}. คำสั่งจะแสดงรายการโปรเซส (ชื่อโปรแกรม) แบบ foreground และ background ที่เกิดจากเทอร์มินอลนั้นโดยปริยายถ้าไม่ระบุอาร์กิวเมนต์.

\begin{MyExample}[ผลลัพธ์ของคำสั่ง \cmd{ps} โดยไม่มีอาร์กิวเมนต์.]
\begin{MyEx}
$ \cin{ps}
  PID TTY          TIME CMD
10523 pts/1    00:00:00 bash
11556 pts/1    00:00:00 firefox
11595 pts/1    00:00:00 run-mozilla.sh
11600 pts/1    00:00:05 firefox-bin
11690 pts/1    00:00:00 ps
\end{MyEx}
\end{MyExample}%$

ข้อมูลที่คำสั่ง \cmd{ps} แสดงได้แก่
\begin{itemize}
\item PID (Process ID)\\
โปรเซสทุกโปรเซสจะมีเลขประจำตัวเฉพาะที่เรียกว่า\emph{โปรเซส ID (process ID)}\gindex{process!ID} เพื่อใช้อ้างอิง. หมายเลขโปรเซสจะเริ่มต้นด้วย 0 จนถึง 32767\mymemo{ค่าโปรเซส ID สูงสุดสามารถดูได้จากไฟล์ \cmd{/proc/sys/kernel/pid\_max}} \cite{ulk}. ถ้ามีโปรเซสใหม่เกิดขึ้นก็จะใช้โปรเซส ID ที่มีค่าถัดจากโปรเซส ID ตัวสุดท้ายในระบบไปเรื่อยๆ. ถ้าโปรเซส ID เกิน 32767 ก็จะใช้โปรเซส ID เริ่มตั้งแต่ 0 ใหม่โดยจะใช้โปรเซส ID ที่ยังไม่ซ้ำกับโปรเซสที่กำลังทำงานอยู่.
\item TTY (Teletype)\\
โปรเซสแต่ละโปรเซสจะมีเทอร์มินอลควบคุมโปรเซสซึ่งโดยปรกติคือเทอร์มินอลที่รันโปรเซสนั้น. โปรเซสบางตัวที่ไม่ได้เกิดจากการสั่งคำสั่งทางเทอร์มินอลเช่นโปรเซสของเซิฟร์เวอร์ต่างๆ ในคอลัมน์ที่แสดงเทอร์มินอลควบคุมจะเป็นเครื่องหมาย \cmd{?}.
\item TIME\\
ระยะเวลาที่หน่วยประมวลผลใช้ทำงานโดยโปรเซส. ค่า TIME ไม่ใช่ระยะเวลาที่รันโปรเซสนั้นจนถึงปัจจุบันแต่เป็นระยะเวลาจริงที่หน่วยประมวลผลใช้ไปกับโปรเซสนั้น. ระยะเวลานี้สั้นมากดังนั้นค่า TIME ของบางโปรเซสมีค่าประมาณเป็นศูนย์.
\item CMD\\
ชื่อโปรเซสแบบสั้นซึ่งได้แก่ชื่อโปรแกรมที่กระทำการ.
\end{itemize}

ถ้าต้องการแสดงโปรเซสทั้งหมดที่มีอยู่ในระบบให้ใช้ตัวเลือก \cmd{-e} (everything) หรือ \cmd{-A} (All).
\begin{MyExample}[แสดงโปรเซสทั้งหมดในระบบ.]
\begin{MyEx}
$ \cin{ps -e} \mycomment{หรือ} ps -A
  PID TTY          TIME CMD
    1 ?        00:00:04 init
    2 ?        00:00:00 ksoftirqd/0
    3 ?        00:00:00 events/0
    4 ?        00:00:00 kblockd/0
\abb
\end{MyEx}
\end{MyExample}%$

\subsection{โปรเซสและเจ้าของ}
ในระบบมัลติยูสเซอร์, โปรเซสทุกตัวจะมีเจ้าของซึ่งโดยปรกติแล้วจะเป็นผู้ที่สร้างโปรเซสนั้น. การควบคุมโปรเซสเช่นสั่งจบการทำงานจะสามารถทำได้กับโปรเซสที่เป็นเจ้าของเท่านั้น. แต่สำหรับผู้ใช้ root มีสิทธิ์พิเศษสามารถควบคุมโปรเซสได้ทุกตัวในระบบ. การควบคุมโปรเซสทำได้โดยการส่งสัญญาณ (signal) ให้โปรเซสรับรู้ซึ่งจะแนะนำในช่วงถัดไป (หน้า \pageref{sec:signal}).

เราสามารถใช้ตัวเลือก \cmd{-f} เพื่อแสดงเจ้าของโปรเซสและข้อมูลเพิ่มเติมเกี่ยวกับโปรเซสได้ด้วย. ถ้าใช้ตัวเลือกนี้กับตัวเลือก \cmd{-e} ก็จะแสดงโปรเซสทั้งหมดในระบบและรายละเอียดของโปรเซส.
\begin{MyExample}[แสดงรายละเอียดของโปรเซสด้วยตัวเลือก \cmd{-f}]\label{ex:init}
\begin{MyEx}
$ \cin{ps -ef}
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 09:01 ?        00:00:04 init [3]
root         2     1  0 09:01 ?        00:00:00 [ksoftirqd/0]
root         3     1  0 09:01 ?        00:00:00 [events/0]
root         4     3  0 09:01 ?        00:00:00 [kblockd/0]
\abb
\end{MyEx}
\end{MyExample}%$
รายเอียดของโปรเซสเพิ่มเติมจากค่าปริยายที่แสดงได้แก่
\begin{itemize}
\item UID (User ID)\\
 แสดงเจ้าของโปรเซสโดยใช้ชื่อล็อกอิน.
\item PPID (Parent Process ID)\\
โปรเซสพ่อแม่, แสดงโปรเซส ID ที่เป็นตัวสร้างโปรเซสที่แสดงอยู่.
\item C\\
ข้อมูลดิบของระยะเวลาที่หน่วยประมวลผลใช้ไปกับโปรเซสในหน่วย clock tick. %ระยะเวลานี้ไม่ใช่เวลาสะสมแต่เป็นระยะเวลาในช่วงหนึ่งซึ่งจะสามารถนำมาคำนวณเปอร์เซ็นต์การใช้งานของหน่วยประมวลผลได้.
\item STIME (Start TIME)\\
เวลาที่โปรเซสเริ่มทำงาน.
\end{itemize}

สำหรับผู้ดูแลระบบที่ต้องดูว่ายูสเซอร์รันโปรเซสอะไรอยู่, สามารถใช้ตัวเลือก \cmd{-u \textit{user}}  ดูโปรเซสโดยระบุยูสเซอร์ที่ต้องการได้.
\begin{MyExample}[ใช้คำสั่ง \cmd{ps} เลือกดูโปรเซสของผู้ใช้ที่ต้องการ.]\label{ex:psfu}
\begin{MyEx}
$ \cin{ps -fu poonlap}
  PID TTY          TIME CMD
 7099 ?        00:00:00 gam_server
10197 ?        00:00:00 esd
10291 ?        00:00:01 gnome-session
\abb
10523 pts/1    00:00:00 bash
10642 pts/2    00:00:00 bash
10679 pts/2    00:00:01 ssh
11556 pts/1    00:00:00 firefox
11595 pts/1    00:00:00 run-mozilla.sh
11600 pts/1    00:00:17 firefox-bin
13715 pts/1    00:00:00 ps
\end{MyEx}
\end{MyExample}%$
อาร์กิวเมนต์ของตัวเลือก \cmd{-u} จะเป็นชื่อล็อกอินหรือ UID ก็ได้.

ในกรณีที่ยูสเซอร์ใช้เทอร์มินอลอยู่หลายตัวและเราต้องการเลือกดูโปรเซสที่อยู่ในเทอร์มินอลทีทต้องการ, ให้ใช้ตัวเลือก  \cmd{-t \textit{tty}}.
\begin{MyExample}[เลือกแสดงโปรเซสตามเทอร์มินอลที่ต้องการ.]
\begin{MyEx}
$ \cin{ps -ft pts/2}
UID        PID  PPID  C STIME TTY          TIME CMD
poonlap  10642 10499  0 10:26 pts/2    00:00:00 bash
poonlap  10679 10642  0 10:26 pts/2    00:00:01 ssh -X poonlap@10.0.0.1
\end{MyEx}
\end{MyExample}%$
จากตัวอย่างเป็นการแสดงโปรเซสที่ควบคุมโดยเทอร์มินอล pts/2 และใช้ตัวเลือก \cmd{-f} แสดงรายละเอียดประกอบ. ลำดับของตัวเลือกมีความสำคัญ, ไม่สามารถสลับกันได้เพราะ pts/2 เป็นอาร์กิวเมนต์ของ \cmd{-t} ไม่ใช่ \cmd{-f}.


\subsection{ความสัมพันธ์ระหว่างโปรเซส}
การสร้างโปรเซสคือการรันโปรแกรมซึ่งสามารถทำได้โดยสั่งคำสั่งในเชลล์พรอมต์, หรือเลือกโปรแกรมที่ต้องการใช้จากเมนูเป็นต้น. ในกรณีที่ใช้เชลล์สั่งคำสั่ง, โปรเซสใหม่จะสร้างโดยเชลล์และจะเกิดความสัมพันธ์ระหว่างโปรเซสที่เป็นผู้สร้างและโปรเซสที่ถูกสร้าง. เราจะเรียกโปรเซสที่เป็นผู้สร้างว่า\emph{โปรเซสพ่อแม่\gindex{โปรเซสพ่อแม่} (parent process)\gindex{process!parent}} และโปรเซสที่ถูกสร้างใหม่ว่า\emph{โปรเซสลูก\gindex{โปรเซสลูก} (child process)\gindex{process!child}}. โปรเซสที่เกิดใหม่จะมีโปรเซสพ่อแม่เสมอซึ่งจะดูได้จากคอลัมน์ PPID ของคำสั่ง \cmd{ps}.

คำสั่ง \cmd{pstree}\cindex{pstree} ช่วยแสดงโปรเซสโดยใช้แผนภาพต้นไม้ทำให้ดูความสัมพันธ์ระหว่างโปรเซสง่ายขึ้น. เราลองมาดูความสัมพันธ์ของโปรเซส bash (PID 10523) ที่แสดงในตัวอย่าง \ref{ex:psfu} ด้วยคำสั่ง \cmd{pstree} ดังต่อไปนี้.
\begin{MyExample}[แผนภาพต้นไม้ของโปรเซส.]
\begin{MyEx}
$ \cin{pstree -pu 10523}
bash(10523,poonlap)-+-firefox(11556)---run-mozilla.sh(11595)---firefox-bin(1160+
                    `-pstree(16346)
\end{MyEx}
\end{MyExample}%$
ตัวเลือก \cmd{-p} และ \cmd{-u} ใช้สำหรับแสดงโปรเซส ID และชื่อยูสเซอร์ในวงเล็บตามลำดับ. จากคำสั่ง \cmd{pstree} ทำให้เราเห็นภาพชัดเจนขึ้นว่า bash เป็นโปรเซสพ่อแม่ของ firefox. ต่อจากนั้น firefox สร้างโปรเซสตัวใหม่ชื่อ run-mozilla.sh, และสุดท้ายโปรเซส run-mozilla.sh สร้างโปรเซส firefox-bin ซึ่งเป็นไบนารีไฟล์จริงๆของโปรแกรมเบราเซอร์ Firefox.

อาร์กิวเมนต์ของคำสั่ง \cmd{pstree} สามารถเป็นได้ทั้งโปรเซส ID หรือชื่อยูสเซอร์. ในกรณีที่ไม่ระบุโปรเซส ID หรือชื่อยูสเซอร์, จะแสดงแผนภาพโปรเซสของระบบ.

\begin{MyExample}[ความสัมพันธ์ระหว่างโปรเซสต่างๆในระบบ.]
\begin{MyEx}
$ \cin{ps -cpun}
init(1)-+-ksoftirqd/0(2)
        |-events/0(3)-+-khelper(4)
        |             |-kacpid(5)
        |             |-kblockd/0(24)
        |             |-pdflush(34)
        |             |-pdflush(35)
        |             `-aio/0(37)
        |-khubd(25)
\abb
        |-mapping-daemon(10483,poonlap)
        |-gnome-terminal(10499,poonlap)-+-gnome-pty-helpe(10522)
        |                               |-bash(10523)-+-firefox(11556)---run-mo+
        |                               |             `-pstree(17205)
        |                               `-bash(10642)---ssh(10679)
        |-wnck-applet(10503,poonlap)
        |-multiload-apple(10507,poonlap)
        |-clock-applet(10509,poonlap)
        |-mixer_applet2(10512,poonlap)
        |-gnome-keyboard-(10515,poonlap)
        `-notification-ar(10518,poonlap)
\end{MyEx}
\end{MyExample}%$
ตัวอย่างข้างบนเป็นการแสดงผลของคำสั่ง \cmd{pstree} ตามลำดับการสร้างโปรเซสต่างๆในระบบ (ตัวเลือก \cmd{-n}), แสดงโปรเซส ID (ตัวเลือก \cmd{-p}), และแสดงชื่อล็อกอินที่เป็นเจ้าของโปรเซส (ตัวเลือก \cmd{-u}).

ในทางเทคนิค, การสร้างโปรเซสใหม่จะเรียกว่าการ fork\mymemo{fork เป็นคำกริยาแปลว่าการแยกออกเป็นกิ่งก้านสาขา.}\gindex{fork}. ในระบบปฏิบัติการลินุกซ์, โปรเซสตัวแรกที่เป็นโปรเซสเริ่มต้นของโปรเซสทั้งหมดคือ init\gindex{init}. เนื่องจากเป็นโปรเซสตัวแรก, จึงมีโปรเซส ID เป็นเลข 1 เสมอ. ถัดจากโปรเซส init จะเป็นโปรเซสที่เกิดจากเคอร์เนลเช่น ksoftirqd, eventd, khelper ฯลฯ. โปรเซสเหล่านี้เรียกว่า \emph{kernel thread}\gindex{kernel thread} เป็นโปรเซสที่ช่วยการทำงานของเคอร์เนล. ถ้าใช้คำสั่ง \cmd{ps -ef} จะแสดง kernel thread ในวงเล็บเหลี่ยม.

จากตัวอย่างจะเห็นว่า firefox เป็นโปรเซสลูกของโปรเซส bash. จะเกิดอะไรขึ้นถ้าโปรเซส bash ตายไป? ถ้าโปรเซส firefox เป็นโปรเซสแบบ foreground, โปรเซส firefox จะตายตามไปด้วย. แต่ถ้า firefox เป็นโปรเซส background, โปรเซส firefox จะกลายเป็น\emph{โปรเซสกำพร้า (orphan process)}\gindex{โปรเซสกำพร้า}\gindex{orphan process} ไม่มีโปรเซสพ่อแม่. ในกรณีนี้โปรเซสพ่อของ firefox จะกลายเป็นโปรเซส init โดยปริยาย. จะสังเกตได้ว่าโปรเซสหลายตัวมีโปรเซสพ่อแม่เป็นโปรเซส init เช่น wnck-applet, multiload-apple ฯลฯ. โปรเซสเหล่านี้จะไม่มีเทอร์มินอลควบคุม.

โปรเซสอีกประเภทหนึ่งซึ่งไม่พบบ่อยนักได้แก่โปรเซส zombie\gindex{zombie|see{process}}\gindex{process!zombie}\gindex{โปรเซส!zombie}. โปรเซส zombie คือโปรเซสที่ตายไปแต่โปรเซสพ่อแม่ไม่ได้รับรู้, ทำให้ชื่อโปรเซสยังอยู่ในตารางโปรเซสของเคอร์เนล. คำสั่ง \cmd{ps} จะแสดงชื่อโปรเซส zombie ตามด้วยคำว่า <defunct>. โปรเซส zombie เป็นโปรเซสที่ตายไปแล้วไม่ได้ใช้ทรัพยากรใดๆในระบบ, ไม่มีอันตรายใดๆ.

\begin{MyExample}[โปรเซส zombie.]\label{ex:zombie}
\begin{MyEx}
$ \cin{ps -ly 21634}
S   UID   PID  PPID  C PRI  NI  RSS    SZ WCHAN  TTY        TIME CMD
Z   500 21634 11600  0  77   0    0     0 exit   pts/1      0:00 [netstat] <defu\wrap
nct>
\end{MyEx}
\end{MyExample}%$



\subsection{เกี่ยวกับคำสั่ง \cmd{ps}}
คำสั่ง \cmd{ps} เป็นคำสั่งที่ใช้มานานตั้งแต่สมัยระบบปฏิบัติการยูนิกซ์. ตัวเลือกต่างๆของคำสั่งดั้งเดิมจะแตกต่างกันตามระบบปฏิบัติการยูนิกซ์ที่ใช้เช่น SysV หรือ BSD. สำหรับคนที่เคยใช้ยูนิกซ์มาก่อนอาจจะรู้มาว่าถ้าต้องการแสดงโปรเซสในระบบทั้งหมดให้ใช้คำสั่ง \cmd{ps aux}. การใช้คำสั่ง \cmd{ps} และตัวเลือกโดยไม่ใช้เครื่องหมาย \cmd{-} นำหน้าตัวเลือกเป็นการใช้คำสั่ง \cmd{ps} สไตล์ BSD. เพื่อความเป็นมาตรฐานและไม่สับสนควรใช้คำสั่ง \cmd{ps} แบบมาตรฐานตาม The Single UNIX Specification Version 3 (SusV3) \cite{susv3} ซึ่งจะใช้เครื่องหมาย \cmd{-} นำหน้าตัวเลือกเสมอ. ในหนังสือเล่มนี้จะยึดตามหลัก SusV3. สำหรับรายละเอียดเพิ่มเติมเกี่ยวกับการใช้คำสั่ง \cmd{ps} สไตล์ BSD สามารถอ่านได้จาก \cmd{man ps}.

\subsubsection{รายละเอียดของตัวเลือก}
คำสั่ง \cmd{ps} มีความยืดหยุ่นสูงสามารถแสดงข้อมูลต่างๆของโปรเซสที่เราต้องการได้. ตัวอย่างเช่นตัวเลือก \cmd{-f} (full-format) ใช้แสดงรายละเอียดของโปรเซสได้ในระดับที่พอควร. นอกจากนั้นยังมีตัวเลือก \cmd{-F} (extra full-format) ซึ่งจะแสดงรายละเอียดของโปรเซสให้ละเอียดขึ้นอีก, และตัวเลือก \cmd{-l} (long format) แสดงรายเอียดแบบยาว.

\begin{MyExample}[เปรียบเทียบตัวเลือกแสดงรายละเอียดของโปรเซส.]
\begin{MyEx}
$ \cin{ps -f}
UID        PID  PPID  C STIME TTY          TIME CMD
poonlap  18519  7868  0 12:07 pts/7    00:00:00 -bash
poonlap  22212 18519  0 14:00 pts/7    00:00:00 ps -f
$ \cin{ps -F}
UID        PID  PPID  C    SZ   RSS PSR STIME TTY          TIME CMD
poonlap  18519  7868  0   561  1292   0 12:07 pts/7    00:00:00 -bash
poonlap  22215 18519  0   605   828   0 14:00 pts/7    00:00:00 ps -F
$ \cin{ps -l}
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000 18519  7868  0  75   0 -   561 wait4  pts/7    00:00:00 bash
0 R  1000 22218 18519  0  77   0 -   559 -      pts/7    00:00:00 ps
$ \cin{ps -ly}
S   UID   PID  PPID  C PRI  NI   RSS    SZ WCHAN  TTY          TIME CMD
S  1000 18519  7868  0  75   0  1292   561 wait4  pts/7    00:00:00 bash
R  1000 22232 18519  0  77   0   668   559 -      pts/7    00:00:00 ps
\end{MyEx}
\end{MyExample}

รายละเอียดต่างของแต่คอลัมน์ได้แก่
\begin{itemize}
\item SZ\\
ขนาดของหน่วยความจำที่โปรเซสใช้มีหน่วยเป็น \emph{page} %
\myvocab{p}{page}{หน่วยของหน่วยความจำ. ในระบบยูนิกซ์รวมถึงลินุกซ์จะแบ่งหน่วยความจำเป็นกลุ่มขนาดเล็กเรียกว่า page. โดยทั่วไป page จะมีขนาด 4Kb (4096 ไบต์).}%
หน่วยความจำนี้คือเนื้อที่ที่ใช้สำหรับข้อมูล text, data และ stack ของโปรเซส. อีกความหมายหนึ่งคือขนาดของ\emph{หน่วยความจำเสมือน (virtual memory)}\gindex{virtual memory} %
\myvocab{v}{virtual memory}{\emph{หน่วยความจำเสมือน}. พื้นที่หน่วยความจำ (address space) ที่โปรเซสมองเห็นซึ่งโดยทั่วไปจะมีขนาดไม่เท่ากับหน่วยความจำจริง (physical memory). ในระบบสถาปัตยกรรม 32 บิตพื้นที่ที่โปรเซสเห็นจะมีขนาด 4GB.}%
ของโปรเซส.
\item \label{sec:rss}RSS (Resident Set Size)\gindex{rss@RSS}\gindex{resident set size@Residen set size}\\
จำนวนหน่วยความจำที่โปรเซสใช้อยู่จริง. มีหน่วยเป็น kB. สมมติว่าโปรเซสหนึ่งต้องการใช้หน่วยความจำทั้งหมด x กิโลไบต์, โดยปรกติแล้วเคอร์เนลจะจัดการการใช้หน่วยความจำของระบบและจะจัด\emph{หน่วยความจำจริง (physical memory)}\gindex{physical memory} %
\myvocab{p}{physical memory}{\emph{หน่วยความจำจริง}. คือจำนวนหน่วยความจำที่มีจริงในระบบหมายถึงตัวฮาร์ดแวร์ (memory). เคอร์เนลจะใช้หน่วยความจำจริงโดยแบ่งเป็น page, มักจะเรียกว่า freame.}%
 ให้ซึ่งไม่จำเป็นต้องเท่ากับหน่วยความจำที่โปรเซสต้องการทั้งหมด.
\item PSR (Processor)\\
หน่วยประมวลที่ทำงานโปรเซสนั้น. มีความหมายสำหรับเครื่องคอมพิวเตอร์ที่มีหน่วยประมวลผลหลายตัว.
\item F และ ADDR\mymemo{ข้อมูลของ flag ของโปรเซสอยู่ในไฟล์ \cmd{/usr/include/linux/sched.h}}\\
เป็นข้อมูลที่ไม่ค่อยใช้กันและมักจะใช้ตัวเลือก \cmd{-y} กับ \cmd{-l} เพื่อไม่แสดง flag และเปลี่ยน \cmd{ADDR} ให้เป็น \cmd{RSS} แทน.
\item S (Status)\\
สภาพของโปรเซสได้แก่
\begin{itemize}
\item D~~    Uninterruptible sleep
\item R~~    Running หรือ runnable คือโปรเซสที่อยู่ใน\emph{รันคิว (run queue)} หน่วยประมวลผลกำลังทำงานโปรเซสนั้นอยู่, หรือรอหน่วยประมวลอยู่.
\item S~~    Interruptible sleep, กำลังรอเหตุการณ์ใดเหตุการณ์หนึ่งให้เสร็จ
\item T~~    Stopped หมายถึงหยุดทำงานชั่วคราวไม่ใช่จบการทำงาน.
\item W~~    paging (ยกเลิกหลังจากเคอร์เนล 2.6)
\item X~~    dead คือโปรเซสที่ตายไปแล้ว. จริงๆแล้วจะไม่เห็นในรายการโปรเซส.
\item Z~~    Defunct process หรือเรียกอีกอย่างว่าโปรเซส \emph{zombie}\gindex{zombie process} คือโปรเซสที่ตายไปแล้วแต่โปรเซสพ่อแม่ไม่ได้รับรู้ทำให้ยังแสดงอยู่ในรายการโปรเซส. จากตัวอย่างที่ \ref{ex:zombie} จะเห็นว่า SZ และ RSS มีค่าเป็น 0 คือไม่ได้ใช้ทรัพยากร.
\end{itemize}
\item PRI (Priority)\\
แสดง priority ของโปรเซสตัวเลขอยู่ระหว่าง 0 ถึง 99. สำหรับโปรเซสที่อยู่ในรันคิว, โปรเซสที่มีค่า PRI สูงกว่าจะทำงานก่อน.
\item NI (Nice)\\
ตัวเลขนี้ช่วยบอกให้เคอร์เนลรู้ว่าควรจะรันโปรเซสนี้บ่อยหรือให้เวลาหน่วยประมวลผลอย่างไร. ค่าโดยปริยายจะเป็น 0. NI จะมีค่าตั้งแต่ -20 ถึง 19. ตัวเลขยิ่งมากจะได้เวลาใช้หน่วยประมวลผลน้อย, ค่าน้อยๆจะได้เวลาประมวลผลมาก. Nice ในที่นี้หมายถึงดี (nice) ต่อโปรเซสอื่นๆ.
\item WCHAN (Wait)\\
โปรเซสที่อยู่ในระบบไม่จำเป็นต้องกำลังทำงานอยู่ทุกตัว. ส่วนมากจะ sleep รอเหตุการณ์ใดเหตุการณ์หนึ่งอยู่และคอลัมน์ WCHAN แสดงชื่อฟังก์ชันเคอร์เนลที่โปรเซสนั้นกำลังรออยู่. ตัวอย่างเช่นโปรเซส bash อยู่ในสภาพ sleep (S) โดยฟังก์ชัน wait4\mymemo{wait4 เป็นซิสเต็มคอลล์. อ่านรายละเอียดได้จาก \cmd{man wait4}.}. เราพอจะเดาได้ว่าเชลล์กำลังรอการทำงานของโปรเซส ps ให้เสร็จอยู่.
\end{itemize}

\medskip
คำสั่ง \cmd{ps} มีตัวเลือกสามารถข้อมูลที่ต้องการเองได้โดยใช้ตัวเลือก \cmd{-o}. ตัวอย่างต่อไปนี้จะแสดงโปรเซสโดยเลือกยูสเซอร์, จัดคอลัมน์ใหม่โดยระบุค่าที่ต้องการดูและแสดงเป็นแผนภาพต้นไม้ความสัมพันธ์ระหว่างโปรเซสด้วยตัวเลือก \cmd{--forest}.
\begin{MyExample}[โปรเซสของยูสเซอร์ที่ระบุและความสัมพันธ์ระหว่างโปรเซส.]\label{ex:psforest}
\begin{MyEx}
$ \cin{ ps -u poonlap -o pid,ppid,tty,stime,comm --forest}
  PID  PPID TT       STIME COMMAND
10291  3725 ?        10:25 gnome-session
10373 10291 ?        10:25  \bs{}_ ssh-agent
10518     1 ?        10:26 notification-ar
10515     1 ?        10:26 gnome-keyboard-
10512     1 ?        10:26 mixer_applet2
10509     1 ?        10:26 clock-applet
10507     1 ?        10:26 multiload-apple
10503     1 ?        10:26 wnck-applet
10499     1 ?        10:26 gnome-terminal
10522 10499 ?        10:26  \bs{}_ gnome-pty-helpe
10523 10499 pts/1    10:26  \bs{}_ bash
11556 10523 pts/1    10:34  |   \bs{}_ firefox
11595 11556 pts/1    10:34  |   |   \bs{}_ run-mozilla.sh
11600 11595 pts/1    10:34  |   |       \bs{}_ firefox-bin
21634 11600 pts/1    12:54  |   |           \bs{}_ netstat <defunct>
 9394 10523 pts/1    17:41  |   \bs{}_ ps
10642 10499 pts/2    10:26  \bs{}_ bash
10679 10642 pts/2    10:26  |   \bs{}_ ssh
 1733 10499 pts/3    15:53  \bs{}_ bash
10483     1 ?        10:26 mapping-daemon
10477     1 ?        10:25 gnome-vfs-daemo
10466     1 ?        10:25 eggcups
10464     1 ?        10:25 pam-panel-icon
10459     1 ?        10:25 gnome-volume-ma
10457     1 ?        10:25 nautilus
10455     1 ?        10:25 gnome-panel
10450     1 ?        10:25 metacity
10413     1 ?        10:25 xscreensaver
10398     1 ?        10:25 gnome-settings-
10393     1 ?        10:25 bonobo-activati
10391     1 ?        10:25 gnome-keyring-d
10382     1 ?        10:25 gconfd-2
10377     1 ?        10:25 dbus-daemon-1
10376     1 ?        10:25 dbus-launch
10197     1 ?        10:24 esd
 7099     1 ?        09:58 gam_server
\end{MyEx}
\end{MyExample}%$
คำสั่ง \cmd{ps} เป็นคำสั่งที่ค่อนข้างซับซ้อน. ผู้อ่านสามารถดูรายละเอียดเพิ่มเติมได้จาก \cmd{man ps}.
\subsection{โปรเซส และ thread}
โปรเซสหนึ่งโปรเซสสามารถทำงานเป็นขั้นตอนที่กำหนดไว้ตั้งแต่ต้นจนจบได้หนึ่งชุด. ถ้าเรามีสายงานอยู่สองชุดที่ต้องทำพร้อมๆกันจะทำอย่างไร? วิธีหนึ่งคือโปรเซสที่ทำงานอาจจะสร้างโปรเซสเพิ่มโดยการ fork และให้โปรเซสลูกนั้นทำงานที่สองพร้อมๆกัน. การใช้วิธี fork เป็นการใช้โปรเซสสองตัว. อีกวิธีหนึ่งคือการใช้ \emph{thread}\gindex{thread}. %
\myvocab{t}{thread}{สายงานที่อยู่โปรเซสที่สามารถทำงานได้พร้อมๆกัน. โปรแกรมที่ใช้ thread ได้จะใช้ไลบรารี pthread.}%
Thread คือสายงานที่อยู่ในโปรเซส. โปรเซสหนึ่งอาจจะมีได้หลายสายงานคือมี thread หลายสายทำงานได้พร้อมๆกันซึ่งแต่ละสายงานอาจจะเหมือนกันหรือต่างกันก็ได้. การใช้ thread มีข้อดีที่ว่าไม่มีการสลับเปลี่ยนการทำงานโปรเซสของหน่วยประมวลเพราะ thread เป็นสายงานที่อยู่ในโปรเซสและ thread สามารถใช้ข้อมูลบางอย่างที่อยู่ในหน่วยความจำร่วมกันได้. ส่วนการแบ่งเวลาการทำงานของ thread ในโปรเซสนั้นจะใช้ไลบรารีไลบรารี pthread\gindex{pthread} (POSIX thread library).

ไลบรารี thread สำหรับลินุกซ์ในช่วงแรกๆไม่สมบูรณ์และมีปัญหาหลายอย่าง \cite{nptl}. ตัวอย่างที่เห็นได้ชัดเช่นโปรแกรมที่ใช้ไลบรารีรุ่นเก่าเวลาแสดงโปรเซสด้วยคำสั่ง \cmd{ps} จะเห็น thread เป็นโปรเซสหลายโปรเซสแยกแยะไม่ออกว่าจริงๆแล้วโปรเซสไหนเป็น thread หรือโปรเซสจริงๆ. ไลบรารี thread รุ่นใหม่ที่เรียกว่า \emph{Native POSIX Thread Library (NPTL)}\gindex{nptl@NPTL|see{Native POSIX thread library}}\gindex{native posix thread library@Native POSIX thread library} จะไม่มีปัญหาแบบนี้. เวลาใช้คำสั่ง \cmd{ps} แสดงโปรเซสจะเห็นเป็นโปรเซสเดียว.

คำสั่ง \cmd{ps} มีตัวเลือกที่ใช้แสดง thread ID (LWP) ได้แก่ \cmd{-L}. ถ้าใช้ตัวเลือกนี้ร่วมกับตัวเลือก \cmd{-f} จะแสดงจำนวน thread (NLWP) ของโปรเซสด้วย.

\begin{MyExample}[โปรเซสที่ใช้ thread.]
\begin{MyEx}
$ \cin{ps -e | grep firefox-bin} \mycomment{หาโปรเซส ID ของ firefox-bin}
 7379 pts/0    00:17:03 firefox-bin
$ \cin{ps -fLp 7379}
UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD
poonlap   7379  7369  7379  0    6 Nov15 pts/0    00:17:03 /usr/lib/MozillaFiref\wrap
ox/firefox-bin
poonlap   7379  7369  7389  0    6 Nov15 pts/0    00:00:04 /usr/lib/MozillaFiref\wrap
ox/firefox-bin
poonlap   7379  7369  7391  0    6 Nov15 pts/0    00:00:06 /usr/lib/MozillaFiref\wrap
ox/firefox-bin
poonlap   7379  7369  7781  0    6 Nov15 pts/0    00:00:00 /usr/lib/MozillaFiref\wrap
ox/firefox-bin
poonlap   7379  7369 12544  0    6 Nov16 pts/0    00:00:00 /usr/lib/MozillaFiref\wrap
ox/firefox-bin
poonlap   7379  7369 12545  0    6 Nov16 pts/0    00:00:00 /usr/lib/MozillaFiref\wrap
ox/firefox-bin
\end{MyEx}
\end{MyExample}

จากตัวอย่างจะเห็นว่าโปรเซส firefox-bin มีโปรเซส ID เป็น 7379 และมี thread อยู่ 6 ตัว. Thread แต่ละตัวจะมีหมายเลขเฉพาะแสดงในคอลัมน์ LWP\gindex{lwp@LWP|see{Light Weight Process}} ซึ่งย่อมาจากคำว่า \emph{Light Weight Process}\gindex{light weight process@Light Weight Process} ซึ่งคือ thread นั่นเอง.


\subsection{หาโปรเซส ID}
คำสั่ง \cmd{ps} เป็นคำสั่งที่แสดงข้อมูลต่างๆเกี่ยวกับโปรเซส. ถ้าเรารู้ชื่อโปรเซสหรือชื่อโปรแกรมแล้วต้องการหาโปรเซส ID ของโปรเซสนั้น, อาจจะใช้คำสั่ง \cmd{grep} ช่วยในการกรองผลลัพธ์ของคำสั่ง \cmd{ps} อีกที. ตัวอย่างเช่นเราต้องการค้นหาโปรเซส ID ของโปรแกรม \cmd{emacs} ก็สามารถสั่งคำสั่งดังนี้

\begin{MyExample}[การใช้ \cmd{ps} ร่วมกับ \cmd{grep} เพื่อหาโปรเซส ID จากชื่อ]\label{ex:psgrep}
\begin{MyEx}
$ \cin{ps -ef | grep emacs}
poonlap   4837  4831  0 14:51 pts/2    00:02:41 emacs
poonlap   6162  4811  0 22:01 pts/1    00:00:00 grep emacs
\end{MyEx}
\end{MyExample}%$

ในกรณีนี้เราก็จะรู้ว่าโปรเซส ID ของ \cmd{emacs} คือ 4837. หลังจากนั้นถ้าเราต้องการติดต่อกับโปรเซสนี้เช่น หยุดการทำงานของโปรเซสนี้ก็สามารถทำได้โดยอ้างอิงโปรเซส ID ที่ได้มา.
การใช้ \cmd{grep} เข้าช่วยทำให้รู้โปรเซส ID ของโปรแกรมที่ต้องการแต่สุดท้ายเราต้องมาดูอยู่ดีว่าโปรเซส ID ของ \cmd{emacs} คือตัวเลขที่อยู่บรรทัดแรกคอลัมน์ที่สอง.


คำสั่ง \cmd{pgrep}\cindex{pgrep}\refcmd{pgrep} เป็นคำสั่งที่รวมความสามารถของ \cmd{ps} และ \cmd{grep} เข้าด้วยกันใช้หาโปรเซส ID โดยระบุชื่อโปรเซสแบบ regular expression โดยปริยายถ้าไม่ระบุตัวเลือก.

\begin{MyExample}[การใช้โปรแกรม \cmd{pgrep} หาโปรเซส ID]
\begin{MyEx}
$ \cin{pgrep -x emacs}
4837
$ \cin{pgrep -lx emacs}
4837 emacs
\end{MyEx}
\end{MyExample}
จากตัวอย่าง, เป็นการหาโปรเซส ID ของโปรเซสชื่อ \cmd{emacs} โดยใช้ตัวเลือก \cmd{-x} เพื่อให้คำสั่งแมชท์คำนั้นตรงตัว. ถ้าไม่ใช้ตัวเลือก \cmd{-x} ประกอบ, คำสั่ง \cmd{pgrep} อาจจะแสดงโปรเซส ID ของโปรเซสที่มีคำว่า \cmd{emacs} อยู่ซึ่งอาจจะเป็น \cmd{emacs}, \cmd{xemacs}, \cmd{emacsclient} ฯลฯ เพราะคำที่ระบุเป็น regular expression. ตัวเลือก \cmd{-l} ใช้แสดงชื่อโปรเซสร่วมกับโปรเซส ID.




\section{สัญญาณ (signal)}\label{sec:signal}
\emph{สัญญาณ (signal)}\gindex{signal} เป็นวิธีสื่อสารวิธีหนึ่งระหว่างโปรเซส. ระบบปฏิบัติการลินุกซ์ได้มีการกำหนดสัญญาณต่างๆซึ่งคล้ายเหมือนกับระบบปฏิบัติการยูนิกซ์. เมื่อโปรเซสใดโปรเซสหนึ่งได้รับสัญญาณหนึ่งจะมีการตอบสนองต่อสัญญาณนั้นๆโดยปริยาย. ตารางที่ \ref{tab:signal} แสดงรายการสัญญาณทั่วๆไปที่ใช้กัน.

\bigskip
\tablecaption{สัญญาณต่างๆและหมายเลขที่กำหนดโดยระบบปฏิบัติการ}\label{tab:signal}
\tablefirsthead{\hline \multicolumn{1}{c|}{สัญญาณ} & \multicolumn{1}{|c|}{หมายเลข} & \multicolumn{1}{|c|}{การตอบสนอง} & \multicolumn{1}{|c}{คำอธิบาย}\\
\hline
}
\tablehead{\multicolumn{4}{l}{{\slshape ต่อจากหน้าที่แล้ว}}\\ \hline \multicolumn{1}{c|}{สัญญาณ} & \multicolumn{1}{|c|}{หมายเลข} & \multicolumn{1}{|c|}{การตอบสนอง} & \multicolumn{1}{|c}{คำอธิบาย}\\
\hline
}
\tabletail{\hline \multicolumn{4}{r}{\slshape ต่อหน้าถัดไป}\\}
\tablelasttail{\hline}
\begin{supertabular}{l|r|c|p{.4\linewidth}}
SIGHUP  & 1& Term & รับรู้การ hangup จากเทอร์มินอลที่ควบคุมอยู่หรือสูญเสียการควบคุมโปรเซส\\
SIGINT  & 2& Term & ยับยั้งจากคีย์บอร์ด\\
SIGQUIT &      3   &    Core&    จบการทำงานจากคีย์บอร์ด\\
SIGILL  &      4   &    Core&    คำสั่งปฏิบัติการที่ไม่ถูกต้อง\\
SIGABRT &      6   &    Core&    ทำให้ล้มเหลวจากซิสเต็มคอล abort\\
SIGFPE  &      8   &    Core&    ข้อยกเว้น (exception) แบบ floating point \\
SIGKILL &      9   &    Term&    สัญญาณ kill\\
SIGSEGV &     11   &    Core&    การอ้างอิงหน่วยความจำที่เป็นโมฆะ\\
SIGPIPE &     13   &    Term&    การส่งต่อข้อมูลให้ไปป์ที่ไม่มีตัวรับข้อมูลต่อ (broken pipe)\\
SIGALRM &     14   &    Term&    การปลุกจากซิสเต็มคอล alarm\\
SIGTERM &     15   &    Term&    สัญญาณสิ้นสุดการทำงาน\\
SIGUSR1 &  30,10,16&    Term&    สัญญาณกำหนดโดยผู้ใช้ 1\\
SIGUSR2 &  31,12,17&    Term&    สัญญาณกำหนดโดยผู้ใช้ 2\\
SIGCHLD &  20,17,18&    Ign &    โปรเซสลูกถูกหยุดหรือสิ้นสุดการทำงาน\\
SIGCONT &  19,18,25&        &    กระทำการต่อไปถ้าหยุดอยู่\\
SIGSTOP &  17,19,23&    Stop&    หยุดโปรเซส\\
SIGTSTP &  18,20,24&    Stop&    หยุดการพิมพ์จากเทอร์มินอล\\
\end{supertabular}
\medskip

การตอบสนองโดยปริยายมีหลายประเภทเช่น
\begin{itemize}
\item \textbf{Term}\\
สิ้นสุดโปรเซส. การสิ้นสุดโปรเซสนี้ไม่ได้หมายถึงโปรเซสจบการทำงานโดยสมบูรณ์แบบแต่หมายถึงโปรเซสที่ตอบสนองนั้นจะสิ้นสุดการกระทำการทันทีไม่ว่างานที่ทำอยู่นั้นจะเสร็จบริบูรณ์หรือไม่ก็ตาม.\mymemo{การจบการทำโดยสมบูรณ์หมายถึงโปรเซสมีโอกาสสามารถกระทำการสิ่งต่างๆที่จำเป็นก่อนที่จะจบการทำงาน.}
\item \textbf{Ign}\\
เป็นการตอบสนองโดยเพิกเฉยต่อสัญญาณที่ได้รับ.
\item \textbf{Core}\\
ตอบสนองโดยการสิ้นสุดโปรเซสและ\emph{ดัมพ์ (dump)} เนื้อหาของหน่วยความจำที่โปรเซสนั้นใช้ลงไฟล์ชื่อว่า \cmd{core}. โดยทั่วไปเรียกว่า \emph{core dump}\gindex{core dump}.
\item \textbf{Stop}\\
หยุดการทำงานของโปรเซสชั่วคราว. โปรเซสที่หยุดการทำงานนี้สามารถทำให้ทำงานต่อได้.
\end{itemize}
ตัวอย่างเช่นเมื่อโปรเซสได้รับสัญญาณ SIGINT, โปรเซสนั้นก็จะยกเลิกการทำงานโดยปริยาย. ถ้าโปรเซสนั้นมีความสามารถดักจับรอสัญญาณที่ได้ก็จะสามารถกระทำการอื่นๆที่ไม่ใช่การตอบสนองโดยปริยายก็ได้. สำหรับสัญญาณโดยทั่วๆไป, โปรเซสที่ได้รับสัญญาณนั้นสามารถดัก, บล็อกหรือเพิกเฉยการตอบสนองที่กำหนดไว้ได้. สัญญาณ SIGKILL และ SIGSTOP เป็นสัญญาณที่ไม่สามารถดัก, บล็อกหรือเพิกเฉยได้. กล่าวคือถ้าโปรเซสใดโปรเซสหนึ่งได้รับสัญญาณ SIGKILL ก็จะสิ้นสุดการทำงานทันทีเสมอโดยไม่มีข้อยกเว้น. ส่วนโปรเซสที่ได้รับสัญญาณ SIGSTOP ก็จะหยุดการทำงานชั่วคราวเสมอโดยไม่มีข้อยกเว้นเช่นกัน. ตัวอย่างการส่งสัญญาณ SIGSTOP จากเชลล์ (\cmd{C-z}) ได้แสดงไปแล้วในตอนต้น.

สัญญาณ SIGINT สามารถส่งได้โดยการกดคีย์ \cmd{C-c} จากเทอร์มินัล, ใช้ในการยกเลิกการทำงานของจ็อบแบบ foreground. ตัวอย่างเช่น

\begin{MyExample}[การส่งสัญญาณ \cmd{SIGINT} ให้โปรแกรมที่ใช้อยู่ด้วย \cmd{C-c}]
\begin{MyEx}
$ \cin{cat}
`cat' will repeat what you typed from standard input\myenter
`cat' will repeat what you typed from standard input
Now we are going to press C-c\myenter
Now we are going to press C-c
\ovalbox{Ctrl}+\ovalbox{c}
$ \cursorprompt
\end{MyEx}
\end{MyExample}

จากตัวอย่างดังกล่าวเป็นการยกเลิกการทำงาน, ไม่ใช่การจบการทำงานอย่างถูกต้อง. ในกรณีของโปรแกรม \cmd{cat} จะเรียกได้ว่าจบการทำงานบริบูรณ์ก็ต่อเมื่อไม่มีข้อมูลป้อนให้โปรแกรม \cmd{cat} อีกต่อไป. กล่าวคือเมื่อได้รับอักขระควบคุม EOT (End Of Transmission)\mymemo{EOT บ้างก็เรียกว่า EOF (End Of File).} คือกด \cmd{C-d}.

โดยทั่วไปผู้ใช้สามารถใช้คีย์ \cmd{C-c} ส่งสัญญาณ SIGINT เพื่อยกเลิกการทำงานของโปรแกรม foreground ต่างๆได้. แต่โปรแกรมก็มีสิทธิ์ที่จะเพิกเฉยการรบกวนของสัญญาณ SIGINT ได้โดยการดักสัญญาณ SIGINT และกระทำสิ่งที่โปรแกรมกำหนดไว้. ตัวอย่างเช่นถ้าผู้ใช้ใช้โปรแกรมเครื่องคิดเลข \cmd{bc}\cindex{bc}\refcmd{bc} แล้วกด \cmd{C-c} เพื่อยกเลิกการใช้การใช้งาน, ตัวโปรแกรม \cmd{bc} จะดักสัญญาณ SIGINT แล้วแสดงข้อความการใช้งานที่ถูกต้องทางหน้าจอแทนที่จะจบกระทำการกลางครร.\mymemo{ในโปรแกรม \cmd{bc} ผู้ใช้สามารถสร้างตัวแปรและใช้ฟังชันคณิตศาสตร์ต่างๆได้เช่น $sin$, $log$, ยกกำลังเป็นต้น. ในตัวอย่างมีการกำหนดค่า $\pi$ โดยอาศัยฟังชัน $arctan(1)$ เข้าช่วย, $\pi = 4 arctan(1)$. }\cindex{bc}

\begin{MyExample}[โปรแกรมที่ดักสัญญาณ \cmd{SIGINT}]
\begin{MyEx}
$ \cin{bc -l}
bc 1.06
Copyright 1991-1994, 1997, 1998, 2000 Free Software Foundation, Inc.
This is free software with ABSOLUTELY NO WARRANTY.
For details type `warranty'.
\cin{pi = 4*a(1)}
\cin{r = 2.5}
\cin{area = pi * r^2}
\cin{area}
19.63495408493620774025
\cin{4*a(1) * 2.5^2}
19.63495408493620774025
\ovalbox{Ctrl}+\ovalbox{c}
(interrupt) use quit to exit.
\cin{quit}
$ \cursorprompt
\end{MyEx}
\end{MyExample}

ตามตัวอย่างที่แสดงไปขั้นต้นจะเห็นได้ว่าสัญญาณบางอย่างผู้ใช้สามารถส่งได้โดยใช้ key binding เช่น \cmd{C-c}, \cmd{C-z}. แต่สำหรับการส่งสัญญาณโดยทั่วไปแล้วผู้ใช้ทำได้โดยใช้คำสั่ง \cmd{kill} โดยส่งโปรเซส ID เป็นอาร์กิวเมนต์ของคำสั่ง. ผู้ใช้สามารถหาโปรเซส ID ได้จากคำสั่ง \cmd{ps} หรือ \cmd{pgrep} ที่ได้แนะนำไปแล้ว (\ref{sec:process}).

โดยปรกติคำสั่ง \cmd{kill}\cindex{kill}\refcmd{kill} จะเป็นการทำให้โปรเซสหรือจ็อบที่ระบุสิ้นสุดการทำงาน. ในหลักการแล้ว \cmd{kill} จะเป็นตัวส่งสัญญาณ SIGTERM เพื่อให้โปรเซสหรือจ็อบที่ต้องการหยุดการทำงาน. ตัวอย่างเช่น %\myexplanation{emacs}{โปรแกรมบรรณาธิกรณ์ที่สร้างจากภาษา lisp บางส่วนและเรียกใช้ภาษา lisp ที่เรียกว่า emacs lisp ได้ในตัวบรรณาธิกรณ์. \cmd{emacs} สามารถใช้ได้ทั้งบนเทอร์มินอล (terminal based) และหน้าจอ X วินโดว์ (GUI based)}
\begin{MyExample}[การใช้คำสั่ง \cmd{kill} โดยระบุหมายเลขโปรเซส]
\begin{MyEx}
$ \cin{emacs &}
[1] 4362
$ \cin{kill 4362}
\end{MyEx}
\end{MyExample}
แทนที่จะระบุหมายเลขโปรเซสเราอาจจะระบุหมายเลขจ็อบแทนก็ได้เช่น
\begin{MyExample}[การใช้คำสั่ง \cmd{kill} โดยระบุหมายเลขจ็อบ]
\begin{MyEx}
$ \cin{emacs &}
[1] 4410
$ \cin{kill %1}
\end{MyEx}
\end{MyExample}

\bigskip
นอกจากสัญญาณ SIGTERM แล้ว, โปรแกรม \cmd{kill} ยังสามารถส่งสัญญาณอื่นๆให้โปรเซสได้ด้วย. รายการสัญญาณที่โปรแกรม \cmd{kill} ส่งได้ใช้ตัวเลือก \cmd{-l} ในการแสดง.
\begin{MyExample}[ใช้คำสั่ง \cmd{kill} แสดงชื่อสัญญาณต่างๆ]
\begin{MyEx}
$ \cin{kill -l}
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
13) SIGPIPE     14) SIGALRM     15) SIGTERM     17) SIGCHLD
18) SIGCONT     19) SIGSTOP     20) SIGTSTP     21) SIGTTIN
22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO
30) SIGPWR      31) SIGSYS      32) SIGRTMIN    33) SIGRTMIN+1
34) SIGRTMIN+2  35) SIGRTMIN+3  36) SIGRTMIN+4  37) SIGRTMIN+5
38) SIGRTMIN+6  39) SIGRTMIN+7  40) SIGRTMIN+8  41) SIGRTMIN+9
42) SIGRTMIN+10 43) SIGRTMIN+11 44) SIGRTMIN+12 45) SIGRTMIN+13
46) SIGRTMIN+14 47) SIGRTMIN+15 48) SIGRTMAX-15 49) SIGRTMAX-14
50) SIGRTMAX-13 51) SIGRTMAX-12 52) SIGRTMAX-11 53) SIGRTMAX-10
54) SIGRTMAX-9  55) SIGRTMAX-8  56) SIGRTMAX-7  57) SIGRTMAX-6
58) SIGRTMAX-5  59) SIGRTMAX-4  60) SIGRTMAX-3  61) SIGRTMAX-2
62) SIGRTMAX-1  63) SIGRTMAX
\end{MyEx}
\end{MyExample}%$

ในกรณีที่ \cmd{kill} ไม่สามารถสิ้นสุดการทำงานของโปรเซสที่ต้องการได้, ผู้ใช้สามารถส่งสัญญาณ SIGKILL ด้วยอาร์กิวเมนต์ \cmd{-9} หรือ \cmd{-SIGKILL} ซึ่งมีความหมายเหมือนกัน. สัญญาณนี้ใช้สำหรับฆ่าโปรเซสที่ผิดปรกติเช่นโปรเซสที่ไม่ตอบสนองการทำงาน. เนื่องจาก SIGKILL เป็นสัญญาณที่โปรเซสไม่สามารถปฏิเสธได้, เมื่อโปรเซสได้รับสัญญาณ SIGKILL แล้ว, ตัวโปรเซสนั้นจะสิ้นสุดการทำงานแน่นอน.

การใช้คำสั่ง \cmd{kill} ฆ่าโปรเซสต้องรู้โปรเซส ID ของโปรเซสที่ต้องการก่อนจึงจะใช้ส่งสัญญาณหาโปรเซสนั้นๆได้. ในความเป็นจริง, ผู้ใช้ต้องค้นหาโปรเซส ID ด้วยคำสั่ง \cmd{ps} หรือ \cmd{pgrep} เอง. เมื่อรู้โปรเซส ID แล้วจึงสามารถใช้คำสั่ง \cmd{kill} ส่งสัญญาณ. บางดิสทริบิวชันอาจจะมีคำสั่ง \cmd{pkill}\cindex{pkill}\refcmd{pkill} ซึ่งรวมการทำงานของคำสั่ง \cmd{kill} กับ \cmd{grep} เข้าด้วยกันให้ส่งสัญญาณให้โปรเซสที่ต้องการโดยระบุชื่อหรือ regular expression. คำสั่ง \cmd{pkill} จะมีตัวเลือกส่วนใหญ่เหมือนกับคำสั่ง \cmd{pgrep}.

\medskip
คำสั่งที่เกี่ยวกับการส่งสัญญาณอีกตัวหนึ่งคือ \cmd{killall}\cindex{killall}\refcmd{killall} ใช้ส่งสัญญาณให้โปรเซสทุกตัวที่ต้องการโดยการระบุชื่อโปรเซส. จะต่างกับคำสั่ง \cmd{pkill} ที่ไม่สามารถใช้ regular expression. คำสั่ง \cmd{killall} สำหรับระบบปฏิบัติการยูนิกซ์อื่นๆที่ไม่ใช้ลินุกซ์อาจจะมีพฤติกรรมที่แตกต่างจากคำสั่ง \cmd{killall} ในลินุกซ์. เช่นในระบบปฏิบัติการ Solaris, ถ้าสั่ง \cmd{killall} ด้วย root จะทำลายโปรเซสทุกตัวในระบบตามคำแปลของชื่อคำสั่ง.

\section{ทรัพยากร}
คำว่า ``ทรัพยากร'' ในภาษาไทยอาจจะฟังดูแปลกๆสำหรับหนังสือคอมพิวเตอร์. ถ้าจะเขียนเป็นภาษาอังกฤษจะใช้คำว่า resource ซึ่งหมายถึงทรัพยากรของเครื่องคอมพิวเตอร์ได้เช่น เวลาที่หน่วยประมวลผลใช้ไปกับโปรเซสหนึ่งๆ, หน่วยความจำจริงที่ใช้ไป, พื้นที่ของฮาร์ดดิสก์ เป็นต้น. เคอร์เนลเป็นตัวที่ควบคุมการใช้ทรัพยากรต่างๆของโปรเซสเพื่อให้ระบบทั้งระบบทำงานได้อย่างมีประสิทธิภาพ.

ลินุกซ์เป็นระบบปฏิบัติการแบบมัลติยูสเซอร์, มัลติทาส์ก สามารถมีโปรเซสหลายๆตัวทำงานในเวลาเดียวกัน. บางโปรเซสใช้ทรัพยากรมาก, บางโปรเซสใช้ทรัพยากรน้อยแตกต่างกันไป. คำสั่ง \cmd{ps} สามารถดูทรัพยากรที่โปรเซสหนึ่งๆใช้ไปได้เช่น เปอร์เซนต์การใช้งานหน่วยประมวลผลในช่วงเวลาสั้นๆ (CPU)\mymemo{ใช้วิธีการเลือกคอลัมน์ \cmd{-o pcpu}.}, หน่วยความจำที่ใช้ไปกับโปรเซส ฯลฯ. แต่สำหรับการดูการใช้ทรัพยากรต่างๆในระบบแบบทันต่อเวลา (real time) มักจะใช้คำสั่ง \cmd{top}\cindex{top}\refcmd{top} เพราะจะแสดงการใช้ทรัพยากรต่างๆที่สำคัญๆของโปรเซสตามลำดับเปอร์เซ็นต์การใช้งานหน่วยประมวลผล.

\subsection{คำสั่ง \cmd{top}}
\begin{figure}[!htb]
\plfigure{.5}{top_G1.eps}{คำสั่ง \cmd{top} แสดงโปรเซสต่างๆและทรัพยากรที่ใช้.}{top_G1}
\end{figure}

คำสั่ง \cmd{top} เป็นโปรแกรมที่ใช้เทอร์มินอลชั่วแสดงผลจะอัปเดทข้อมูลทางหน้าจอทุกๆ 3 วินาทีโดยปริยาย. ข้อมูลในบรรทัดแรกเป็นข้อมูลโหลดโดยเฉลี่ย (load average) ของระบบซึ่งเหมือนกับผลลัพธ์ของคำสั่ง \cmd{uptime}. บรรทัดที่ 2 แสดงจำนวนโปรเซสและสถานะต่างของโปรเซสได้แก่
\begin{itemize}
\item จำนวนโปรเซสทั้งหมดในระบบ (Tasks)
\item จำนวนโปรเซที่อยู่ในรันคิว (running). ถ้ามีจำนวนโปรเซสอยู่ในรันคิวมากจำทำให้ค่าโหลดโดยเฉลี่ยสูง.
\item จำนวนโปรเซสที่กำลังรอทำงานต่อไป (sleeping)
\item จำนวนโปรเซสที่หยุดชั่วคราว (stopped) คือโปรเซสที่ได้รับสัญญาณ SIGSTOP.
\item จำนวนโปรเซส zombie.
\end{itemize}

บรรทัดที่ 3 แสดงเปอร์เซ็นต์การทำงานของหน่วยประมวลผลในช่วงที่ผ่านมาได้แก่
\begin{itemize}
\item user (us) เปอร์เซ็นต์การใช้หน่วยประมวลผลไปกับโปรเซสธรรมดาที่ทำงานอยู่ใน user space.
\item system (sy) เปอร์เซ็นต์การใช้หน่วยประมวลผลไปกับโปรเซสที่ทำงานอยู่ใน kernel space.
\item nice (ni) เปอร์เซ็นต์การใช้หน่วยประมวลผลไปกับโปรเซสที่มีค่า nice ทำงานอยู่ใน user space.
\item idle (id) เปอร์เซ็นต์ที่หน่วยประมวลผลไม่ได้ทำอะไร.
\item iowait (wa) เปอร์เซ็นต์การใช้หน่วยประมวลผลรอให้ I/O เสร็จเรียบร้อย.
\item irq (hi) เปอร์เซ็นต์การใช้หน่วยประมวลผลที่ใช้ไปกับการ interrupt ของฮาร์ดแวร์.
\item softirq (si) เปอร์เซ็นต์การใช้หน่วยประมวลผลที่ใช้ไปกับการ interrupt แบบซอฟต์แวร์.
\end{itemize}

บรรทัดที่ 4 เป็นข้อมูลเกี่ยวกับหน่วยความจำในระบบในหน่วยกิโลไบต์ได้แก่
\begin{itemize}
\item จำนวนหน่วยความจำจริงทั้งหมด (total).
\item จำนวนหน่วยความจำที่ใช้อยู่ (used).
\item จำนวนหน่วยความจำที่ยังเหลืออยู่ (free).
\item จำนวนหน่วยความจำที่ใช้ไปกับ \emph{buffer cache}\gindex{cache!buffer} %
\myvocab{c}{cache}{การเก็บข้อมูลบางอย่างไว้ช่วยคราวเพื่อความรวดเร็วในการเข้าถึงข้อมูลนั้นภายหลัง. ถ้าใช้คำว่า cache อย่างเดียวไม่สามารถบอกได้ว่าเป็น cache ของอะไร. ลินุกซ์เคอร์เนลใช้หน่วยความจำในการ cache ข้อมูลหลายอย่างเช่น buffer cache, page cache, inode cache, directory cache และ swap cache.}%
(buffers). หน่วยความจำส่วนนี้ใช้สำหรับเก็บข้อมูลที่จะบันทึกลงในฮาร์ดดิสก์, หรือข้อมูลที่อ่านมาจากฮาร์ดดิสก์. การอ่านข้อมูลจากฮาร์ดดิสก์จะใช้เวลานานเมื่อเทียบกับการอ่านข้อมูลจากหน่วยความจำ. ดังนั้นเคอร์เนลจึงใช้เนื้อที่หน่วยความจำส่วนนี้ช่วยทุ่นเวลา I/O ที่จะเกิดกับฮาร์ดดิสก์.
\item จำนวนหน่วยความจำที่ใช้ไปกับ \emph{page cache}\gindex{cache!page} (cached) คือ cache ของ page ที่แม็ปไว้กับไฟล์. ข้อมูลนี้อยู่ในบรรทัดที่ห้าแต่เป็นข้อมูลการใช้งานหน่วยความจำ.
\end{itemize}

บรรทัดที่ 5 แสดงข้อมูลเกี่ยวกับ \emph{swap} ในระบบ. Swap เป็นพื้นที่ในฮาร์ดดิสก์ใช้เก็บข้อมูลแทนหน่วยความจำ\mymemo{swap ทำงานกลับกันกับ buffer cache.}. ตัวอย่างการใช้ swap ของเคอร์เนลเช่นในกรณีที่มีข้อมูลบางอย่างในโปรเซสที่ไม่มีความจำเป็นต้องอยู่ในหน่วยความจำจริงก็จะเก็บไว้ใน swap (ฮาร์ดดิสก์) แทนไม่ให้เปลืองที่โดยใช่เหตุเป็นต้น. หน่วยความจำที่ไปอยู่ใน swap นี้เรียกว่าถูก \emph{swap out} ถ้ามีการเรียกข้อมูลจาก swap เข้าไปในหน่วยความจำใหม่ก็เรียกว่า \emph{swap in}
\begin{itemize}
\item จำนวน swap ที่มีอยู่ในระบบ (total).
\item จำนวน swap ที่ใช้ไป (used).
\item จำนวน swap ที่ยังเหลืออยู่ (free).
\end{itemize}

\medskip
ถัดจากสถิติโดยรวมของระบบแล้วก็จะเป็นรายงานการใช้ทรัพยากรต่างๆของโปรเซสโดยเรียงตามลำดับโปรเซสที่ใช้งานหน่วยความจำมาก. ถ้าต้องการจะออกจากโปรแกรม \cmd{top} ให้กดคีย์ ``q'' หมายถึง quit ก็จะจบการทำงานแสดงเชลล์พรอมต์ต่อไป.

รายละเอียดการใช้ทรัพยากรของโปรเซสจะคล้ายเมหือนกับผลลัพธ์ของคำสั่ง \cmd{ps} เช่น PID, USER, PR, NI เป็นต้น. ส่วนที่ต้องอธิบายเพิ่มเติมได้แก่
\begin{itemize}
\item \textbf{VIRT}\\
หน่วยความจำเสมือนที่โปรเซสใช้ในหน่วยของ kB ประกอบด้วยจำนวนหน่วยความจำที่ใช้ไปกับ code, data, shared library และ page ที่ถูก swap out ออกไป. VIRT = SWAP + RES.
\item \textbf{RES}\\
ได้แก่หน่วยความจำ Resident Size ในหน่วย kB ได้แก่หน่วยความจำจริงที่ไม่ได้ swap out. RES = CODE + DATA.
\item \textbf{SHR}\\
Shared memory ได้แก่หน่วยความจำที่ใช้ร่วมกันระหว่างโปรเซสในหน่วย kB.
\end{itemize}

\subsection{กลุ่มการแสดงผลของคำสั่ง \cmd{top}}
คำสั่ง \cmd{top} จะแสดงผลโดยใช้หน้าต่างเทอร์มินอลและหน้าต่างที่แสดงในรูปที่ \ref{fig:top_G1} เป็นเพียง 1 ใน 4 ของกลุ่มแสดงผลที่เตรียมและคอลัมน์ต่างๆที่แสดงในแต่ละกลุ่มจะแยกแยะไว้ไม่เหมือนกันแล้วแต่จุดประสงค์ของกลุ่มแสดงผล. กลุ่มแสดงผลมีดังนี้
\begin{enumerate}
\item \textbf{Def} (Default) กลุ่มนี้เป็นหน้าต่างโดยปริยายใช้แสดงรายละเอียดโปรเซสต่างๆตามลำดับโดยเน้นเปอร์เซ็นต์การใช้งานหน่วยประมวลผลเป็นหลัก.
\item \textbf{Job} สำหรับแสดงผลเน้นจ็อบ. จะแสดงโปรเซสตามลำดับโปรเซส ID จากมากไปหาน้อยโดยปริยาย. คอลัมน์ต่างๆที่แสดงไม่ต่างจากกลุ่ม Def มากนัก. ข้อมูลที่แสดงแทนหรือเพิ่มเข้ามาได้แก่ PPID, UID และ SWAP.

\begin{figure}[!htb]
\plfigure{.5}{top_G2.eps}{กลุ่มการแสดงผล Job ของคำสั่ง \cmd{top}.}{top_G2}
\end{figure}


\begin{itemize}
\item \textbf{PPID} โปรเซส ID ของโปรเซสพ่อแม่.
\item \textbf{UID} ยูสเซอร์ ID.
\item \textbf{SWAP} แสดงหน่วยความจำของโปรเซสที่ถูก swap out จากหน่วยความจำเสมือนในหน่วย kB.
\end{itemize}
\item \textbf{Mem} (Memory) กลุ่มแสดงผลที่เน้นสำหรับข้อมูลเกี่ยวกับหน่วยความจำโดยเฉพาะ. รายการโปรเซสจะเรียงลำดับตามค่า \%MEM ซึ่งได้แก่จำนวนหน่วยความจำจริงที่ใช้. รายละเอียดที่แสดงเพิ่มเติมในกลุ่มนี้ได้แก่

\begin{figure}[!htb]
\plfigure{.5}{top_G3.eps}{กลุ่มการแสดงผล Mem ของคำสั่ง \cmd{top}.}{top_G3}
\end{figure}


\begin{itemize}
\item \textbf{CODE} หน่วยความจำจริงที่ใช้สำหรับส่วนที่เป็น code. รู้จักกันในอีกชื่อว่า \emph{Text Resident Set (TRS)}\gindex{text resident set}\gindex{trs@TRS|see{text resident set}}.
\item \textbf{nFLT} จำนวน major page fault ที่เกิดขึ้นเนื่องจากการเขียนหรืออ่าน address ที่ไม่ได้อยู่หน่วยความจำแต่อยู่ในฮาร์ดดิสก์.
\item \textbf{nDRT} จำนวน dirty page ได้แก่หน่วยความจำที่ข้อมูลมีการเปลี่ยนแปลงต้องบันทึกลงในฮาร์ดดิสก์.
\end{itemize}
\item \textbf{Usr} (User) กลุ่มแสดงผลเน้นข้อมูลที่เกี่ยวกับยูสเซอร์โดยเรียงลำดับโปรเซสตามชื่อยูสเซอร์. รายละเอียดที่เพิ่มเข้ามาได้แก่

\begin{figure}[!htb]
\plfigure{.5}{top_G4.eps}{กลุ่มการแสดงผล Usr ของคำสั่ง \cmd{top}.}{top_G4}
\end{figure}


\begin{itemize}
\item \textbf{RUSER} ยูสเซอร์จริงที่เป็นเจ้าของโปรเซส.
\item \textbf{TTY} ชื่อเทอร์มินอลควบคุมโปรเซส.
\end{itemize}
\end{enumerate}

การเปลี่ยนกลุ่มการแสดงผลทำได้โดยการกดคีย์ ``G'' แล้วกดเลข 1 ถึง 4 ตามกลุ่มที่ต้องการแสดง. ถ้าต้องการแสดงหน้าต่างทั้ง 4 แบบพร้อมๆกันให้กดคีย์ ``A''. มุมบนซ้ายของหน้าจอจะแสดงหน้าต่างปัจจุบันที่เลือกอยู่. ถ้ามีการโต้ตอบกับโปรแกรม \cmd{top} จะถือว่าเป็นการกระทำกับหน้านั้น. ถ้าต้องการเปลี่ยนหน้าต่างที่เลือกอยู่เป็นหน้าต่างอื่นให้กดคีย์ ``a''.

\begin{figure}[!htb]
\plfigure{.5}{top_A.eps}{หน้าจอ \cmd{top} เมื่อแสดงหน้าต่าง 4 แบบพร้อมๆกัน.}{top_A}
\end{figure}

\subsection{คำสั่งในโปรแกรม \cmd{top}}
โปรแกรม \cmd{top} เป็นโปรแกรมแบบโต้ตอบ, ผู้ใช้สามารถกดคีย์ต่อไปนี้กระทำการต่างๆได้. คำสั่งเหล่านี้ใช้ได้กับหน้าต่างกลุ่มการแสดงแสดงผลทุกแบบ.


\begin{itemize}
\item ``q'' จบการทำงาน.
\item ``h'' แสดงหน้าจอช่วยเหลือ. การออกจากหน้าจอช่วยเหลือให้กดคีย์ใดๆ.
\item ``z'' ใช้สีในการแสดงผล. ถ้ากด ``Z'' จะแสดงคำอธิบายสั้นๆก่อนแล้วใช้สีตามภายหลัง. ถ้าต้องการเลิกใช้สีให้กด ``z'' อีกที.
\item ``b'' แสดงบรรทัดโปรเซสที่อยู่ในรันคิว (สถานะ R) ให้มีสีพื้นหลังกับสีตัวอักษรกลับกัน. ในกรณีจะทำให้เห็นโปรเซสสถานะ R เด่นชัดขึ้น.
\item ``B'' แสดงบรรทัดโปรเซสที่สถานะ R และค่าสถิติโดยรวมต่างๆด้วยตัวหนา.
\item ``l'' ซ่อน/แสดง บรรทัดแรกที่เป็นผลลัพธ์ของ \cmd{uptime}.
\item ``t'' ซ่อน/แสดง บรรทัดสถิติจำนวนโปรเซสแบบต่างๆ.
\item ``m'' ซ่อน/แสดง บรรทัดที่เกี่ยวกับหน่วยความจำและ swap.
\item ``u'' แสดงโปรเซสของยูสเซอร์ที่ต้องการ. ให้ผลเหมือนกับการสั่งคำสั่งด้วยตัวเลือก \cmd{-u \textit{user}}.
\item ``n'' หรือ ``\#'' ระบุจำนวนโปรเซสที่ต้องการดู.
\item ``d'' หรือ ``s'' ตั้งช่วงเวลาการแสดงผลในแต่ละครั้งในหน่วยวินาที. คำสั่ง \cmd{top} จะแสดงผลทุกๆ 3 วินาทีโดยปริยาย. การตั้งช่วงเวลาการแสดงผลสามารถทำได้ด้วยตัวเลือก \cmd{-d \textit{seconds}} เช่นกัน.
\item ``W'' เขียนไฟล์ตั้งค่าเริ่มต้นในไฟล์. การปรับแต่งโปรแกรมต่างๆเช่น สี ฯลฯ จะเขียนเก็บไว้ในไฟล์  \cmd{~\ /.toprc} และใช้ได้ใหม่ครั้งหน้า.
\item ``R'' เรียงลำดับจากน้อยไปหามาก. คำสั่ง \cmd{top} จะเรียงลำดับโปรเซสตามคอลัมน์ที่จัดลำดับอยู่จากค่ามากไปหาน้อยโดยปริยาย.
\item ``f'' เพิ่ม/ลด คอลัมน์ข้อมูลที่ต้องการแสดง. หลังจากที่กดคีย์ ``f'' แล้วจะเปลี่ยนเป็นหน้าจอให้เลือกคอลัมน์ที่ต้องแสดง.
\item ``o'' จัดลำดับคอลัมน์ที่ต้องการแสดงก่อนหลังตามต้องการ.
\item ``F'' เลือกคอลัมน์ที่ต้องการให้เรียงลำดับรายการโปรเซส. เช่นถ้าคอลัมน์ \%CPU เป็นคอลัมน์สำหรับเรียงลำดับโปรเซสก็จะเรียงลำดับโปรเซสที่มีเปอร์เซ็นต์การใช้หน่วยประมวลผลจากมากไปหาน้อยโดยปริยาย.
\item ``k'' (kill) ส่งสัญญาณให้กับโปรเซสเหมือนกับคำสั่ง \cmd{kill}. โปรแกรม \cmd{top} จะถาม PID ของโปรเซสที่ต้องการส่งสัญญาณไปให้และถามสัญญาณที่ต้องการส่งซึ่งจะส่งสัญญาณ SIGTERM โดยปริยายถ้าไม่ระบุ.
\item ``r'' (renice) ให้ผลเหมือนกับคำสั่ง \cmd{renice} ใช้เปลี่ยนค่า nice ของโปรเซสที่ต้องการ.
\end{itemize}


\subsection{ทรัพยากรหน่วยความจำ}
ในลินุกซ์จะมีคำสั่ง \cmd{free}\cindex{free}\refcmd{free} ใช้สำหรับแสดงการใช้งานหน่วยความจำโดยรวมของระบบซึ่งจะให้ผลคล้ายกับคำสั่ง \cmd{top} ในช่วงสรุปการใช้งานหน่วยความจำ. สิ่งที่แตกต่างจากคำสั่ง \cmd{top} คือจะแสดงจำนวนหน่วยความที่หักลบส่วนที่ใช้ไปกับ buffer และ cached แสดงในตัวอย่างต่อไปนี้.

\begin{MyExample}[คำสั่ง \cmd{free} แสดงการใช้งานหน่วยความจำในระบบ.]
\begin{MyEx}
$ \cin{free}
             total       used       free     shared    buffers     cached
Mem:        903544     655784     247760          0      22348     436352
-/+ buffers/cache:     197084     706460
Swap:       505848          0     505848
\end{MyEx}
\end{MyExample}%$

ถ้าเป็นการสั่งคำสั่งโดยไม่มีอาร์กิวเมนต์, คำสั่ง \cmd{free} จะแสดงจำนวนหน่วยความจำในหน่วย kB โดยปริยาย.

คำสั่งที่เกี่ยวกับการตรวจสอบการใช้งานหน่วยความจำอีกตัวได้แก่ \cmd{vmstat}\cindex{vmstat}\refcmd{vmstat}. คำสั่ง \cmd{vmstat} คล้ายกับ \cmd{free} ที่รายงานการใช้งานหน่วยความจำโดยรวมแต่จะให้ข้อมูลอื่นๆที่เกี่ยวข้องในระบบด้วย.

\begin{MyExample}[ใช้ \cmd{vmstat} ตรวจสอบการทำงานของระบบ.]
\begin{MyEx}
$ vmstat 10 6
procs -----------memory---------- ---swap-- -----io---- --system-- ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in    cs us sy id wa
 2  0      0 239848  23404 437448    0    0    26    80 1101   853 11  1 87  1
 1  0      0 239920  23440 437580    0    0    16     4 1021  1485 10  2 86  2
 0  1      0 230328  25452 438844    0    0   326     8 1071  1504 13  2 42 44
 0  1      0 224952  28108 440980    0    0   476     9 1124  1055  5  2  0 94
 0  1      0 220216  30396 441796    0    0   308    48 1069   851  3  0  0 97
 0  1      0 216184  32752 441796    0    0   235    14 1064   787  3  1  0 96
\end{MyEx}
\end{MyExample}%$

รายละเอียดของคำสั่ง \cmd{vmstat} ได้แก่.
\begin{itemize}
\item procs\\
ข้อมูลเกี่ยวกับโปรเซสในระบบว่ามีโปรเซสกี่ตัวที่อยู่ในรันคิว (r), โปรเซสที่ถูกบล็อก (b) หรืออยู่ในสภาพ sleep แบบรบกวนไม่ได้ (uninterruptible).
\item memory\\
ข้อมูลเกี่ยวกับหน่วยความจำเหมือนคำสั่ง \cmd{free} และ \cmd{top}.
\item swap\\
จำนวนหน่วยความจำที่ swap in (si) เข้ามาจากฮาร์ดดิสก์และ swap out (so) จากหน่วยความจำจริง.หน่วยเป็น kB ต่อวินาที.
\item IO\\
ความเร็วการเขียน (bo) อ่าน (bi) ข้อมูลหน่วยเป็น block\mymemo{โดยปรกติ 1 block มีค่า 512 ไบต์.} ต่อวินาที่.
\item system\\
จำนวน interrupt ต่อวินาทีที่เกิดขึ้น (in). จำนวน context switch (cs) ต่อวินาที.
\item CPU\\
เปอร์เซ็นการทำงานของหน่วยประมวลผลที่อยู่ใน user mode (us). เปอร์เซ็นต์การทำงานของหน่วยประมวลใน kernel mode (sys). เปอร์เซ็นต์ที่หน่วยประมวลผลว่าง (id) และเปอร์เซ็นต์ที่หน่วยประมวลผลใช้รอ IO (wa).
\end{itemize}

นอกจากคำสั่ง \cmd{vmstat} ยังมีคำสั่งรายงานสถิติต่างๆที่เกี่ยวกับระบบในทำนองเดียวกันได้แก่ \cmd{iostat}\cindex{iostat} ใช้แสดงสถิติการถ่ายโอนข้อมูลของดิสก์และ \cmd{mpstat}\cindex{mpstat} ใช้แสดงสถิติเกี่ยวกับการใช้หน่วยประมวลผลซึ่งจะไม่กล่าวถึงในที่นี้.


\section{จับเวลาการทำงานของโปรเซส}
การจับเวลาการทำงานของโปรเซสเป็นเรื่องที่เกิดขึ้นบ่อยครั้งโดยเฉพาะเวลาที่ต้องการสำรวจเวลาที่ใช้ในการรันโปรแกรมที่สร้างขึ้นเอง. คำสั่งที่ใช้จับเวลาการทำงานของโปรเซสคือ \cmd{time}.\cindex{time}\refcmd{time}
\begin{MyExample}[จับเวลาการทำงานของคำสั่ง.]
\begin{MyEx}
$ \cin{time cp aowthai-5.5.92-i386-cd1.iso /mnt/usb}

real    0m45.845s
user    0m0.033s
sys     0m2.040s
\end{MyEx}
\end{MyExample}%$

เวลาที่ใช้ทำงานจริงตั้งแต่เริ่มทำงานจนจบ (real) ได้แก่ค่าที่แสดงในบรรทัดแรก. เวลาที่ใช้ไปจะช้าหรือเร็วขึ้นกับระบบตอนนั้นว่าทำงานหนักอยู่หรือไม่. ส่วนเวลาที่แสดงในบรรทัดที่สอง (user) บอกเวลาที่หน่วยประมวลผลใช้ไปกับโปรเซสใน user mode. และบรรทัดสุดท้าย (sys) แสดงเวลาที่หน่วยประมวลผลใช้ไปกับโปรเซสใน kernel mode. จากตัวอย่างข้างบนเป็นการก็อปปี้ไฟล์ใหญ่ๆ. ในกรณีนี้ทำให้รู้ว่าหน่วยประมวลใช้เวลาไปกับระบบ (kernel) มากกว่าการทำงานของโปรเซสจริงๆ (user).


%\section{limit resource}
%
%ulimit, sysctl

\section{ไฟล์และโปรเซส}
โปรเซสจะมีความสัมพันธ์กับไฟล์หรือไดเรกทอรีเสมอ. เมื่อโปรเซสเริ่มกระทำการ, โปรเซสจะรับรู้สภาพแวดล้อมที่ทำงานอยู่เช่นไดเรกทอรีที่ทำงานอยู่ (current working directory). \mymemo{ไดเรกทอรีที่โปรเซสทำงานอยู่นี้สามารถตรวจสอบได้จากไฟล์ \cmd{/proc/\textit{PID}/cwd}. cwd ย่อมาจาก current working directory.}, ไฟล์ที่เปิดใช้อยู่ เป็นต้น.

\subsection{หาโปรเซสที่ใช้ไฟล์}
ถ้าต้องการตรวจไฟล์ฉบับหนึ่งว่ามีโปรเซสอะไรบ้างที่ใช้ไฟล์นั้นอยู่, ให้ใช้คำสั่ง \cmd{fuser}\refcmd{fuser}\cindex{fuser} โดยระบุชื่อไฟล์.

\begin{MyExample}[ตรวจดูโปรเซสที่ใช้ไฟล์ \cmd{/bin/bash}.]
\begin{MyEx}
$ \cin{fuser -uv /bin/bash}

                     USER        PID ACCESS COMMAND
/bin/bash            poonlap    7820 ...e.  bash
                     poonlap    7826 ...e.  firefox
                     poonlap    7848 ...e.  thunderbird
                     poonlap    8213 ...e.  xdvi
\end{MyEx}
\end{MyExample}%$

ในกรณีนี้มีการใช้ตัวเลือก \cmd{-u} เพื่อให้คำสั่ง \cmd{fuser} (user) แสดงชื่อผู้ใช้, และตัวเลือก \cmd{-v} (verbose) เพื่อแสดงรายละเอียดความสัมพันธ์ระหว่างไฟล์กับโปรเซสที่ใช้ไฟล์นั้น. ในคอลัมน์ ACCESS เป็นรายละเอียดการใช้งานของโปรเซสต่อไฟล์ที่เกี่ยวข้องมีความหมายดังนี้.
\begin{itemize}
\item c: ไดเรกทอรที่ตรวจสอบเป็นไดเรกทอรีปัจจุบันของโปรเซสนั้นๆ.
\item e: ไฟล์นั้นกำลังถูกรันอยู่.
\item f: ไฟล์ถูกเปิดใช้อยู่.
\item r: รูทไดเรกทอรี.
\item m: ไฟล์ถูกแม็ปในหน่วยความจำหรือเป็น shared library.
\end{itemize}

จากตัวอย่างทำให้เรารู้ว่าโปรเซสชื่อ bash, firefox, thunderbird และ xdvi กำลังรันไฟล์ \cmd{/bin/bash} อยู่\mymemo{ในกรณีนี้ \cmd{firefox}, \cmd{thunderbird} และ \cmd{xdvi} เป็นเชลล์สคริปต์, ไม่ใช่ไฟล์ไบนารี. ไฟล์ไบนารีที่แท้จริงได้แก่ \cmd{firefox-bin}, \cmd{thunderbird-bin} และ \cmd{xdvi.bin}.}. นี่เป็นวิธีหนึ่งที่สามารถตรวจเวลาสงสัยว่ามีโปรเซสอะไรบ้างใช้ไฟล์ที่ระบุ. มีประโยชน์ใช้หาโปรเซสแปลกปลอมที่กำลังจะเข้าถึงไฟล์สำคัญๆในระบบได้.


บางครั้งเราต้องการจะ unmount พาร์ทิชันออกจากระบบไฟล์แต่ไม่สามารถ umount ได้และเกิด error ว่า ``device is busy''. สาเหตุที่ไม่สามารถ unmount อาจเกิดจากมีโปรเซสใช้ไฟล์ที่อยู่ในพาร์ทิชันนั้น, หรือไดเรกทอรีที่อยู่ในพาร์ทิชันนั้นเป็นไดเรกทอรีที่ทำงานอยู่ของโปรเซสบางตัว. ในกรณีนี้ก็ใช้คำสั่ง \cmd{fuser} ตรวจสอบกับตัวเลือก \cmd{-m} หมายถึงต้องการตรวจสอบทั้งระบบไฟล์, ไม่ใช้ไฟล์เดี่ยวๆ.

\begin{MyExample}[หาโปรเซสที่ใช้ระบบไฟล์.]
\begin{MyEx}
$ \cmd{eject}
umount: /mnt/cdrom: device is busy
umount: /mnt/cdrom: device is busy
eject: unmount of `/dev/cdrom' failed
$ \cin{fuser -muv /mnt/cdrom}

                     USER        PID ACCESS COMMAND
/mnt/cdrom/          poonlap    7941 ..c..  bash
                     poonlap   27237 f.c.m  mpg321
\end{MyEx}
\end{MyExample}

ตัวอย่างข้างบนเป็นการใช้คำสั่ง \cmd{eject}\cindex{eject}\refcmd{eject} เพื่อเอา CD ออกจากไดรว์ได้. คำสั่ง \cmd{eject} จะพยายาม unmount ก่อนแล้วดีด CD ออกมา. แต่ในกรณีนี้มีโปรเซสที่ใช้ไฟล์หรือไดเรกทอรี \cmd{/mnt/cdrom} อยู่จึงต้องใช้คำสั่ง \cmd{fuser} ตรวจสอบโปรเซส.

จากผลลัพธ์ของคำสั่งทำให้เรารู้ว่าไดเรกทอรี \cmd{/mnt/cdrom} ไม่สามารถ unmount ได้เพราะมีโปรเซส bash และ mpg321 ทำงานเกี่ยวข้องกับไดเรกทอรีนั้นอยู่. ถ้าต้องการ unmount ไดเรกทอรี \cmd{/mnt/cdrom} ต้องฆ่าโปรเซสที่เกี่ยวข้องการกับไดเรกทอรีนั้นก่อน, ซึ่งทำได้โดยการใช้คำสั่ง \cmd{kill} โดยให้โปรเซส ID ทีแสดงในผลลัพธ์ของคำสั่ง \cmd{fuser}. หรือถ้าไม่สนใจโปรเซสที่ใช้ไดเรกทอรี \cmd{/mnt/cdrom} เป็นโปรเซสอะไรแต่ต้องการจะฆ่าโปรเซสทุกโปรเซสที่ใช้หรือเกี่ยวข้องกับไดเรกทอรีนั้นอยู่, ให้ใช้ตัวเลือก \cmd{-k} ประกอบกับคำสั่ง \cmd{fuser}.

\begin{MyExample}[ใช้ \cmd{fuser} ฆ่าโปรเซสที่ใช้ไฟล์หรือไดเรกทอรีที่ระบุ.]
\begin{MyEx}
$ \cin{fuser -k /mnt/cdrom/}
/mnt/cdrom/:          7941c 27237c
kill 27237: No such process
No automatic removal. Please use  umount /mnt/cdrom
\end{MyEx}
\end{MyExample}%$

ในกรณีนี้คำสั่ง \cmd{fuser} จะฆ่าโปรเซส 7941 และ 27237 ตามลำดับ. แต่มี error ว่าหาโปรเซส 27237 ไม่เจอเพราะในความเป็นจริงแล้วโปรเซส 27237 เป็นโปรแกรม \cmd{mpg321}\mymemo{โปรแกรม \cmd{mpg321} เป็นโปรแกรมคำสั่งสำหรับเล่นไฟล์ mp3, ogg ฯลฯ.} ที่รันอยู่ในเชลล์ (โปรเซส 7941) เมื่อโปรเซส 7941 ตายไปแล้วทำให้โปรเซส 27237 ตายตามไปด้วย.

ตัวเลือก \cmd{-m} ไม่ได้ใช้สำหรับหาโปรเซสที่ใช้ไฟล์ใต้ไดเรกทอรีที่ระบุ, แต่เป็นการหาทั้งระบบไฟล์ของไฟล์ที่ระบุ. ตัวอย่างเช่นถ้าใช้ตัวเลือก \cmd{-m} และระบุไดเรกทอรีจะได้ผลดังต่อไปนี้.
\begin{MyExample}[ผลของตัวเลือก \cmd{-m} ต่อชื่อไดเรกทอรีหรือไฟล์.]
\begin{MyEx}
$ \cin{fuser -muv /tmp}

                     USER        PID ACCESS COMMAND
/tmp                 root          1 .rce.  init
                     root          2 .rc..  ksoftirqd/0
                     root          3 .rc..  events/0
                     root          4 .rc..  kblockd/0
\abb
$ \cin{mount}
/dev/hdb1 on / type ext3 (rw,noatime)
devfs on /dev type devfs (rw)
none on /proc type proc (rw)
none on /sys type sysfs (rw)
none on /dev/pts type devpts (rw)
/dev/hdb2 on /home type ext3 (rw,noatime)
/dev/hda3 on /mnt/hda type ext3 (rw,noatime)
none on /dev/shm type tmpfs (rw)
none on /proc/bus/usb type usbfs (rw)
/dev/cdrom on /mnt/cdrom type iso9660 (ro,noexec,nosuid,nodev,user=poonlap)
\end{MyEx}
\end{MyExample}%
คำสั่ง \cmd{fuser} จะแสดงโปรเซสที่จริงๆแล้วไม่ได้ใช้ไฟล์ที่อยู่ใต้ไดเรกทอรี \cmd{tmp} เพราะตัวเลือก \cmd{-m} หมายถึงระบบไฟล์ (พาร์ทิชัน). ในกรณีนี้, ไดเรกทอรี \cmd{tmp} อยู่ในพาร์ทิชัน \cmd{/dev/hdb1}, ดังนั้นคำสั่ง \cmd{fuser} จึงแสดงโปรเซสทั้งหมดที่เกี่ยวข้องกับพาร์ทิชันนั้น.

\medskip
คำสั่งที่คล้ายกับ \cmd{fuser} แต่สามารถแสดงรายละเอียดได้มากกว่าได้แก่คำสั่ง \cmd{lsof}\cindex{lsof}\refcmd{lsof}. ถ้าต้องการหาว่ามีโปรเซสอะไรบ้างที่ใช้ไฟล์ใต้ไดเรกทอรี \cmd{/tmp} รวมถึงไดเรกทอรีย่อย, จะใช้ตัวเลือก \cmd{+D}.
\begin{MyExample}[ใช้ \cmd{lsof} หาโปรเซสที่ใช้ไฟล์ในไดเรกทอรีที่ระบุ.]
\begin{MyEx}
# \cin{lsof +D /tmp}
COMMAND     PID    USER   FD   TYPE     DEVICE SIZE   NODE NAME
cannaserv  5914    root    0u  unix 0xecc81380        9957 /tmp/.iroha_unix/IROHA
cannaserv  5914    root    3u  unix 0xf7311380        6687 /tmp/.iroha_unix/IROHA
famd       7216 poonlap    4u  unix 0xf254e200        9279 /tmp/.fampnWIDy
famd       7216 poonlap    5u  unix 0xf0e58800        9437 /tmp/.famL21ZzK
\abb
\end{MyEx}
\end{MyExample}

คำสั่ง \cmd{lsof} จะแสดงรายละเอียดต่างๆในแต่ละคอลัมน์ได้แก่ ชื่อคำสั่ง (COMMAND), โปรเซส ID (PID), ชื่อผู้ใช้ (USER), file descriptor (FD), ประเภทของไฟล์ (TYPE), ประเภทดีไวซ์ (DEVICE), ขนาด (SIZE), เลข i-node (NODE) และชื่อไฟล์ (NAME).

คอลัมน์ที่น่าสนใจที่ควรรู้จักในที่นี้ได้แก่คอลัมน์ FD ซึ่งจะบอกรายเอียดเกี่ยวกับ file descriptor แบ่งเป็น
\begin{itemize}
\item \textbf{cwd} (current working directory) ไดเรกทอรีที่โปรเซสทำงานอยู่.
\item \textbf{ltx} (library text) ข้อมูลของ shared library ได้แก่ส่วนที่เป็น code และ data.
\item \textbf{mem} (memory-mapped file) ไฟล์ที่แม็ปไว้ในหน่วยความจำ.
\item \textbf{mmap} (memory-mapped device) ไฟล์ดีไวส์ที่แม็ปไว้ในหน่วยความจำ.
\item \textbf{pd} (parent directory) ไดเรกทอรีพ่อแม่.
\item \textbf{rtd} (root directory) ไดเรกทอรีรูท.
\item \textbf{txt} (program text) ข้อมูลของโปรแกรมในส่วนของ code และ data.
\item \textbf{\textit{N}} ตัวเลขเฉพาะของ file descriptor. ตามด้วยอักษรต่อไปนี้บ่งบอกถึงการเข้าถึงของไฟล์นั้นได้แก่
\begin{itemize}
\item \textbf{r} สิทธิ์การอ่าน
\item \textbf{w} สิทธิ์การเขียน
\item \textbf{u} สิทธิ์การอ่านและเขียน
\end{itemize}
\end{itemize}

คอลัมน์ TYPE แสดงประเภทของไฟล์เช่น
\begin{itemize}
\item \textbf{DIR} (directory) ไดเรกทอรี
\item \textbf{REG} (regular file) ไฟล์ธรรมดา
\item \textbf{CHR} (character device) ไฟล์ดีไวซ์แบบ character.
\item \textbf{IPv4} (IPv4 socket) เน็ตเวิร์ก socket สื่อสารประเภท IP version 4.
\item \textbf{FIFO} (first in first out) ไปป์
\item \textbf{unix} (Unix domain socket) ไฟล์ socket
\end{itemize}


\subsection{หาไฟล์ที่โปรเซสใช้}
ข้อมูลเกี่ยวกับโปรเซสต่างๆจะอยู่ในไดเรกทอรีชื่อเป็นโปรเซส ID ใต้ไดเรกทอรี \cmd{proc}. เราสามารถใช้คำสั่ง \cmd{cat} ดูว่าโปรเซสเหล่านั้นกำลังใช้ไฟล์อะไรอยู่ได้. แต่วิธีนี้ไม่สะดวกมากนักเพราะเป็นการดูข้อมูลดิบโดยตรง. คำสั่งที่อำนวยความสะดวกใช้ตรวจสอบดูโปรเซสว่ากำลังใช้ไฟล์อะไรอยู่บ้างได้แก่ \cmd{lsof}\cindex{lsof}\refcmd{lsof} แสดงไฟล์ทั้งหมดที่เปิดใช้อยู่และโปรเซสที่เกี่ยวข้องกับไฟล์นั้น.
%ในทางกลับกันถ้าต้องการตรวจสอบดูโปรเซสว่ากำลังเปิดใช้ไฟล์อะไรอยู่บ้าง, สามารถดูจากไดเรกทอรี \cmd{fd} (file descriptor) ใต้ \cmd{/pro/\textit{PID}}. ก่อนอื่นต้องหาโปรเซส ID ของโปรเซสที่ต้องการตรวจสอบ, เช่นโปรเซส xdvi.bin กำลังใช้ไฟล์อะไรอยู่บ้างสามารถตรวจสอบได้ตามตัวอย่างต่อไปนี้.
%\begin{MyExample}[ดูไฟล์ที่เปิดใช้งานโดยโปรเซสจากระบบไฟล์ \cmd{/proc}]
%\begin{MyEx}
%$ \cin{ls -l /proc/`pgrep xdvi.bin`/fd}
%total 12
%lrwx------    1 poonlap  users          64 Dec  8 20:42 0 -> /dev/pts/0
%lrwx------    1 poonlap  users          64 Dec  8 20:42 1 -> /dev/pts/0
%l-wx------    1 poonlap  users          64 Dec  8 20:42 11 -> pipe:[10725]
%lr-x------    1 poonlap  users          64 Dec  8 20:42 12 -> pipe:[10726]
%l-wx------    1 poonlap  users          64 Dec  8 20:42 2 -> /dev/null
%lrwx------    1 poonlap  users          64 Dec  8 20:42 3 -> socket:[10718]
%lr-x------    1 poonlap  users          64 Dec  8 20:42 4 -> /home/poonlap/.mail
%cap
%lr-x------    1 poonlap  users          64 Dec  8 20:42 5 -> /home/poonlap/BOOK/
%linuxbook/linux.dvi
%lr-x------    1 poonlap  users          64 Dec  8 20:42 6 -> /var/cache/fonts/pk
%/ljfour/jknappen/tc/tctt1440.600pk
%lr-x------    1 poonlap  users          64 Dec  8 20:42 7 -> /var/cache/fonts/pk
%/ljfour/jknappen/tc/tctt0800.600pk
%lr-x------    1 poonlap  users          64 Dec  8 20:42 8 -> /var/cache/fonts/pk
%/ljfour/jknappen/tc/tctt1200.600pk
%lr-x------    1 poonlap  users          64 Dec  8 20:42 9 -> /var/cache/fonts/pk
%/ljfour/jknappen/tc/tcrm1200.600pk
%\end{MyEx}
%\end{MyExample}%$
%
%ชื่อไฟล์ที่อยู่ใต้ไดเรกทอรี \cmd{fd} จะเป็นตัวเลขได้แก่ file descriptor ของโปรเซสและเป็น symbolic link ไปหาไฟล์จริงที่ใช้อยู่. จากการแสดงผลของคำสั่ง \cmd{ls} ข้างบนทำให้เรารู้ว่าโปรเซส xdvi.bin กำลังใช้ไฟล์อะไรอยู่บ้าง, มีทั้งไฟล์ธรรมดา, ไฟล์ดีไวซ์, socket และไปป์.


ตัวอย่างต่อไปนี้เป็นการใช้คำสั่ง \cmd{lsof} ตรวจสอบดูว่าโปรเซส xdvi.bin กำลังเปิดใช้ไฟล์อะไรบ้าง. ตัวเลือก \cmd{-c} ใช้สำหรับเลือกโปรเซสที่ขึ้นต้นด้วยอักษรที่กำหนดเป็นอาร์กิวเมนต์ของตัวเลือก.

\begin{MyExample}[ดูไฟล์ที่เปิดใช้โดยโปรเซส xdvi.bin ทั้งหมด.]
\begin{MyEx}
$ \cin{/usr/sbin/lsof -c xdvi.bin}
COMMAND   PID    USER   FD   TYPE     DEVICE    SIZE    NODE NAME
xdvi.bin 8677 poonlap  cwd    DIR       3,66    4096  587529 /home/poonlap/BOOK/\wrap
linuxbook
xdvi.bin 8677 poonlap  rtd    DIR       3,65    4096       2 /
xdvi.bin 8677 poonlap  txt    REG       3,65  344180  725577 /usr/bin/xdvi.bin
xdvi.bin 8677 poonlap  mem    REG       3,65   90796 1313292 /lib/ld-2.3.4.so
xdvi.bin 8677 poonlap  mem    REG       3,65   10572  823279 /usr/X11R6/lib/X11/\wrap
locale/lib/common/xlcDef.so.2
xdvi.bin 8677 poonlap  mem    REG       3,65   15480  724869 /usr/lib/libwwwsql.
so.0.1.0
xdvi.bin 8677 poonlap  mem    REG       3,65    8472  724849 /usr/lib/libwwwinit\wrap
.so.0.1.0
\abb
xdvi.bin 8677 poonlap  mem    REG       3,65   40759  826417 /usr/X11R6/lib/libX\wrap
cursor.so.1.0
xdvi.bin 8677 poonlap  mem    REG       3,65   32191  826396 /usr/X11R6/lib/libX\wrap
render.so.1.2
xdvi.bin 8677 poonlap    0u   CHR      136,0               2 /dev/pts/0
xdvi.bin 8677 poonlap    1u   CHR      136,0               2 /dev/pts/0
xdvi.bin 8677 poonlap    2w   CHR        1,3               6 /dev/null
xdvi.bin 8677 poonlap    3u  unix 0xe8cdf980           10718 socket
xdvi.bin 8677 poonlap    4r   REG       3,66    2361  575351 /home/poonlap/.mail\wrap
cap
xdvi.bin 8677 poonlap    5r   REG       3,66 1964924  604123 /home/poonlap/BOOK/\wrap
linuxbook/linux.dvi
xdvi.bin 8677 poonlap    6r   REG       3,65   14312 1204286 /var/cache/fonts/pk\wrap
/ljfour/jknappen/tc/tctt1440.600pk
xdvi.bin 8677 poonlap    7r   REG       3,65    7572  923858 /var/cache/fonts/pk\wrap
/ljfour/jknappen/tc/tctt0800.600pk
xdvi.bin 8677 poonlap    8r   REG       3,65   11524  923854 /var/cache/fonts/pk\wrap
/ljfour/jknappen/tc/tctt1200.600pk
xdvi.bin 8677 poonlap    9r   REG       3,65   14220  923849 /var/cache/fonts/pk\wrap
/ljfour/jknappen/tc/tcrm1200.600pk
xdvi.bin 8677 poonlap   11w  FIFO        0,7           10725 pipe
xdvi.bin 8677 poonlap   12r  FIFO        0,7           10726 pipe
\end{MyEx}
\end{MyExample}%$

จะเห็นว่าโปรเซสๆหนึ่งเปิดใช้ไฟล์หลายไฟล์ในเวลาเดียวกัน, ไดเรกทอรีที่ทำงานอยู่, ไฟล์โปรแกรมของโปรเซส, ไปป์, ไฟล์ไลบรารีที่แม็ปไว้ในหน่วยความจำ ฯลฯ.

\medskip
คำสั่ง \cmd{lsof} มีประโยชน์อย่างยิ่งต่อการดูแลระบบ, สามารถหาโปรเซสที่กำลังเปิดใช้ไฟล์ได้และหาไฟล์ที่ใช้โดยโปรเซสได้เช่นกัน. ข้อมูลเหล่านี้บางทีสามารถบอกได้ว่าโปรเซสนั้นๆเป็นโปรเซสแปลกปลอมหรือไม่. ตัวเลือกที่น่าสนใจอื่นๆเช่น \cmd{-u \textit{user}} สามารถใช้ดูไฟล์และโปรเซสที่รันอยู่โดยผู้ใช้ที่ระบุได้. คำสั่ง \cmd{lsof} เป็นคำสั่งที่ค่อนข้างซับซ้อนอีกคำสั่งและมีตัวเลือกหลายตัว. สำหรับรายละเอียดของตัวเลือกให้อ่านจาก \cmd{man lsof}.


\section{ดูการทำงานของโปรเซส}
การดูการทำงานของโปรเซสทำได้หลายวิธีเช่น ดูรหัสต้นฉบับของซอฟต์แวร์นั้นๆ, ถ้าเป็นโปรแกรมที่คอมไพล์เองก็อาจจะใช้ตัวเลือกเวลาคอมไพล์โปรแกรมให้ debug ดูการทำงานได้ภายหลัง. วิธีการเหล่านี้มีข้อจำกัดคือต้องมีต้นฉบับของซอฟต์แวร์จึงจะใช้วิธีนี้ได้. ทางเลือกอีกทางเวลาต้องการดูการทำงานของโปรเซสแต่ไม่มีรหัสต้นฉบับให้ศึกษา, อาจทำได้โดยการดูว่าโปรเซสนั้นๆเรียกใช้ซิสเต็มคอลล์อะไร. เราเรียกวิธีนี้ว่าการ trace จะทำให้เรารู้คร่าวๆว่าโปรเซสนั้นทำงานอย่างไร.

คำสั่งที่ใช้ดูซิสเต็มคอลล์ที่โปรเซสเรียกใช้คือ \cmd{strace}\cindex{strace}\refcmd{strace}. คำสั่ง \cmd{strace} จะแสดงซิสเต็มคอลล์ต่างๆที่โปรเซสเรียกใช้และสัญญาณที่โปรเซสได้รับ. โปรเซสที่ต้องการ trace เป็นได้ทั้งโปรเซสที่รันอยู่แล้ว, หรือกำลังจะรันจากบรรทัดคำสั่งก็ได้. ตัวอย่างต่อไปนี้จะแสดงการ trace การทำงานของโปรแกรม \cmd{cat} ซึ่งมีอาร์กิวเมนต์เป็นไฟล์ชื่อ \cmd{hello.txt}.

\begin{MyExample}[การใช้ \cmd{strace} ดูการทำงานของโปรเซส.]
\begin{MyEx}
$ \cin{cat hello.txt}
hello
$ \cin{strace cat hello.txt}
execve("/bin/cat", ["cat", "hello.txt"], [/* 57 vars */]) = 0
uname({sys="Linux", node="toybox", ...}) = 0
brk(0)                                  = 0x804d000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=150692, ...}) = 0
mmap2(NULL, 150692, PROT_READ, MAP_PRIVATE, 3, 0) = 0x40017000
close(3)                                = 0
open("/lib/tls/libc.so.6", O_RDONLY)    = 3
read(3, "\bs{}177ELF\bs{}1\bs{}1\bs{}1\bs{}0\bs{}0\bs{}0\bs{}0\bs{}0\bs{}0\bs{}0\bs{}0\bs{}0\bs{}3\bs{}0\bs{}3\bs{}0\bs{}1\bs{}0\bs{}0\bs{}0\bs{}275P\bs{}1"..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1174064, ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x40\wrap
03c000
mmap2(NULL, 1105132, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x4\wrap
003d000
mmap2(0x40145000, 16384, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRI\wrap
TE, 3, 0x107) = 0x40145000
mmap2(0x40149000, 7404, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOU\wrap
S, -1, 0) = 0x40149000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x40\wrap
14b000
mprotect(0x40145000, 4096, PROT_READ)   = 0
mprotect(0x40015000, 4096, PROT_READ)   = 0
set_thread_area(\{entry_number:-1 -> 6, base_addr:0x4014b6c0, limit:1048575, seg_\wrap
32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, usea\wrap
ble:1\}) = 0
munmap(0x40017000, 150692)              = 0
open("/dev/urandom", O_RDONLY)          = 3
read(3, "\bs{}214;^\bs{}222", 4)                = 4
close(3)                                = 0
brk(0)                                  = 0x804d000
brk(0x806e000)                          = 0x806e000
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 2), ...}) = 0
open("hello.txt", O_RDONLY|O_LARGEFILE) = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=6, ...}) = 0
read(3, "hello\bs{}n", 4096)                = 6
write(1, "hello\bs{}n", 6\textbf{hello} \mycomment{``\cmd{hello}'' แสดงทาง \cmd{stdout} แทรกใน \cmd{stderr}}
)                  = 6
read(3, "", 4096)                       = 0
close(3)                                = 0
close(1)                                = 0
exit_group(0)                           = ?
\end{MyEx}
\end{MyExample}

จากผลลัพธ์ของคำสั่ง \cmd{strace} ทำให้เรารู้ว่าคำสั่ง \cmd{cat hello.txt} ซึ่งใช้อ่านเนื้อหาที่อยู่ในไฟล์ \cmd{hello.txt} และแสดงผลออกทางหน้าจอเรียกใช้ซิสเต็มคอลล์ถึง 35 อย่าง. ผลลัพธ์ของคำสั่งจะแสดงทาง stderr จึงไม่สามารถไปป์หรือรีไดเรกบันทึกในไฟล์ได้. ถ้าต้องการเก็บผลลัพธ์ของคำสั่งลงในไฟล์, ให้ใช้ตัวเลือก \cmd{-o \textit{file}}.

ข้อมูลที่แสดงในแต่ละบรรทัดได้แก่ซิสเต็มคอลล์ซึ่งก็คือฟังก์ชันในภาษา C, อาร์กิวเมนต์ของฟังก์ชัน, และค่าตอบกลับของฟังก์ชันนั้น. บรรทัดแรกได้แก่ซิสเต็มคอลล์ \cmd{execve}\mymemo{ซิสเต็มคอลล์ \cmd{execve}}. ถ้าต้องการรู้ความหมายของซิสเต็มคอลล์นี้ก็ให้อ่าน \cmd{man 2 execve} ก็จะรู้เป็นการรันโปรแกรม \cmd{/bin/cat} มีอาร์กิวเมนต์เป็นสายอักขระได้แก่ \cmd{cat} และ \cmd{hello.txt}. และมีตัวแปรสภาพแวดล้อมอีก 57 ตัวซึ่งไม่ได้แสดงในที่นี้เป็นอาร์กิวเมนต์ของซิสเต็มคอลล์. ตัวเลขที่อยู่หลังเครื่องหมาย = คือค่าตอบกลับของซิสเต็มคอลล์ในกรณีนี้มีค่าเป็น 0.

การดูซิสเต็มยังทำให้รู้อีกว่าโปรเซสนั้นพยายามจะเข้าถึงไฟล์อะไร, อย่างไร, และเกิดอะไรขึ้นได้ด้วย. เช่นซิสเต็มคอลล์ \cmd{access}\mymemo{ซิสเต็มคอลล์ \cmd{access}, \cmd{open}} ซึ่งเป็นการตรวจสอบสิทธิ์การใช้ไฟล์ของไฟล์ \cmd{/etc/ld.so.preload} แต่มีค่าตอบกลับเป็น -1 มีรหัสเป็น ENOENT หมายถึงเกิดข้อผิดพลาดและมีรายละเอียดบอกให้รู้ว่า ``No such file or directory''. ทำให้รู้ว่าโปรเซสพยายามจะตรวจสอบไฟล์นี้แต่หาไม่เจอ. บรรทัดถัดมาเป็นซิสเต็มที่ใช้บ่อยคือ \cmd{open}. โปรเซสพยายามจะเปิดไฟล์ \cmd{/etc/ld.so.cache} แบบ \cmd{O\_RDONLY} คืออ่านอย่างเดียว. ค่าตอบกลับของซิสเต็มคอลล์จะเป็น file descriptor ซึ่งในกรณีนี้มีค่าเป็น 3. อย่าลืมว่าโปรเซสทุกตัวจะมี file descriptor 0 (stdin), 1 (stdout), และ 2 (stderr) โดยปริยาย. ดังนั้น file descriptor ที่ได้จากการเปิดไฟล์ใหม่จึงเป็น 3.

ต่อจากนั้นใช้ซิสเต็มคอลล์ \cmd{fstat64}\mymemo{ซิสเต็มคอลล์ \cmd{fstat}, \cmd{mmap2}, \cmd{close}} ดึงข้อมูลเกี่ยวกับไฟล์ที่เปิด. เรียกใช้ซิสเต็มคอลล์ \cmd{mmap2} เพื่อแม็ปข้อมูลจากไฟล์เข้าสู่หน่วยความจำ. และปิดไฟล์ที่เปิดไว้ด้วยซิสเต็มคอลล์ \cmd{close}. เปิดไฟล์อื่นๆและกระทำการต่อไปเรื่อยๆ.

\mymemo{ซิสเต็มคอลล์ \cmd{open}, \cmd{read}, \cmd{write}, \cmd{close}}คำสั่ง \cmd{cat} ในตัวอย่างจะเปิดไฟล์ \cmd{hello.txt} หลังจากที่จัดการไฟล์ไลบรารีต่างๆเรียบร้อยแล้ว. ซิสเต็มคอลล์ที่ใช้เปิดไฟล์ไฟล์คือ \cmd{open} และซิสเต็มคอลล์ที่ใช้อ่านไฟล์คือ \cmd{read}. หลังจากนั้นเขียนข้อมูลออกทาง stdout ซึ่งมี file descriptor เป็น 1 ด้วยซิสเต็มคอลล์ \cmd{write}. และสุดท้ายปิดไฟล์ด้วย \cmd{close} และจบการทำงาน.

\medskip
สำหรับโปรเซสที่ทำงานอยู่แล้วและต้องการ trace โปรเซสนั้นให้ใช้ตัวเลือก \cmd{-p \textit{pid}}. บางครั้งโปรแกรมบางตัวทำงานอยู่แต่ดูเหมือนไม่ทำงานหรือทำงานผิดปรกติ, เราสามารถ trace ด้วยคำสั่ง \cmd{strace} ดูว่าโปรเซสทำงานอยู่จริงหรือไม่. หรือถ้าไม่ทำงาน, โปรเซสนั้นไปค้างอยู่ตรงไหนสามารถรู้ได้จากผลลัพธ์ของคำสั่ง. โปรเซสบางตัวอาจจะ fork โปรเซสลูก. ในกรณีนี้คำสั่ง \cmd{strace} จะไม่ trace ดูไปถึงโปรเซสลูกว่าทำอะไรบ้างต้องใช้ตัวเลือก \cmd{-f} มิฉะนั้นคำสั่งจะ trace เฉพาะโปรเซสแม่ที่ดูเท่านั้น.

ตัวเลือกที่มีประโยชน์อีกตัวได้แก่ \cmd{-e} ใช้เลือกดูซิสเต็มคอลล์หรือเหตุการณ์ที่ต้องการดู. อาร์กิวเมนต์ของตัวเลือก \cmd{-e} เป็นได้ทั้งชื่อซิสเต็มคอลล์ที่ต้องการจับตาดูหรือชื่อเหตุการณ์ที่เตรียมไว้อยู่แล้วในตารางที่ \ref{tab:strace}.

\begin{table}[htb]
\center
\caption{ตัวเลือกของ \cmd{strace} สำหรับเลือกเหตุการณ์ที่ต้องการ.}\label{tab:strace}
\begin{tabular}{lp{.7\textwidth}}
\toprule
\multicolumn{1}{c}{ตัวเลือก} & \multicolumn{1}{c}{คำอธิบาย}\\
\midrule
\cmd{-e trace=file} & สำรวจซิสเต็มคอลล์ที่เกี่ยวกับไฟล์เช่น \cmd{open}, \cmd{stat}, \cmd{chmod} ฯลฯ.\\
\cmd{-e trace=process} & สำรวจซิสเต็มคอลล์ที่เกี่ยวกับการควบคุมโปรเซสเช่น \cmd{fork}, \cmd{wait}, \cmd{exec} ฯลฯ.\\
\cmd{-e trace=network} & สำรวจซิสเต็มคอลล์ที่เกี่ยวกับเน็ตเวิร์ก.\\
\cmd{-e trace=signal} & สำรวจซิสเต็มคอลล์ที่เกี่ยวกับสัญญาณ.\\
\cmd{-e trace=ipc} & สำรวจซิสเต็มคอลล์ที่เกี่ยวกับ IPC (Inter Process Communication)\\
\cmd{-e trace=\textit{syscall}} & เลือกดูซิสเต็มคอลล์ที่ระบุ. เช่นถ้าต้องการดูว่าโปรเซสเปิดไฟล์อะไรบ้างให้ใช้ \cmd{-e trace=open}.\\
\bottomrule
\end{tabular}
\end{table}



การใช้คำสั่ง \cmd{strace} นอกจากจะเป็นดูการทำงานของโปรเซสโดยอาศัยการดูซิสเต็มคอลล์ที่โปรเซสใช้แล้วยังมีประโยชน์ในการ debug โปรแกรมในกรณีที่เกิด error โดยไม่รู้สาเหตุอีกด้วย.

\section{สรุปท้ายบท}
%\section{สำรวจฮาร์ดแวร์}
%lspci dmesg lpinfo lsdev lsusb hdparam
\begin{itemize}
\item โปรเซสคือโปรแกรมที่โหลดเข้าสู่หน่วยความจำเพื่อกระทำการโดยที่เคอร์เนลเป็นตัวควบคุมโปรเซสในระบบ.
\item โปรเซสแต่ละตัวจะมีพื้นที่หน่วยความจำเสมือนของตัวเอง. ที่อยู่ของหน่วยความจำเสมือนจะถูกแปลงไปเป็นที่อยู่หน่วยความจำจริงเมื่อใช้. ที่อยู่หน่วยความจำเสมือนไม่จำเป็นต้องอยู่ในหน่วยความจำจริงทุกส่วน. ที่อยู่ของหน่วยความจำเสมือนบางส่วยอาจจะอยู่ในพื้นที่ swap ในหน่วยความจำถาวร.
\item สัญญาณเป็นวิธีการสื่อสารระหว่างโปรเซส. เมื่อโปรเซสได้รับสัญญาณหนึ่งๆจะมีการตอบสนองต่อสัญญาณที่ได้รับ. บางสัญญาณที่ได้รับอาจปฏิบัติเพิกเฉยการตอบสนองได้โดยการสร้าง signal trap. สัญญาณที่ไม่สามารถเพิกเฉยได้แก่ SIGSTOP, SIGKILL.
\item คำสั่งสำคัญที่เกี่ยวกับโปรเซสได้แก่ \cmd{ps}, \cmd{kill}, \cmd{top}
\item คำสั่งที่ใช้ตรวจสอบความสัมพันธ์ระหว่างโปรเซสและไฟล์ที่โปรเซสใช้ได้แก่ \cmd{fuser} และ \cmd{lsof}.
\item คำสั่ง \cmd{strace} ใช้สำหรับดูซิสเต็มคอลล์ที่โปรเซสเรียกใช้. การดูซิสเต็มคอลล์ที่โปรเซสใช้ช่วยให้เข้าใจการทำงานของโปรเซสได้คร่าวๆ. สามารถใช้ในการแก้ปัญหาการทำงานของโปรเซสได้ด้วยเช่นการ debug โปรแกรมเมื่อเกิดข้อผิดพลาดหรือโปรเซสทำงานผิดปรกติ.
\end{itemize}

%\section{แบบฝึกหัดและคำถามทบทวนความเข้าใจ}
%\begin{description}
%\myprac จงเขียนคำสั่งบรรทัดเดียวโดยใช้ \cmd{kill} และ \cmd{grep} ฆ่าโปรเซสตามชื่อที่ระบุ.\pageref{q_5_1}
%\end{description}
