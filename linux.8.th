\chapter{ภาษาไทยกับลินุกซ์}
ในอดีต, คอมพิวเตอร์สร้างขึ้นมาสำหรับการใช้งานในกลุ่มประเทศที่ใช้ภาษาอังกฤษ. ปัจจุบันคอมพิวเตอร์ใช้กันอย่างแพร่หลายทั่วโลกไม่จำกัดอยู่ในประเทศที่ใช้ภาษาอังกฤษอีกต่อไป. ในแต่ละประเทศมีเอกลักษณ์ของตัวเอง, บางประเทศมีภาษาของตัวเอง, บางประเทศใช้ภาษาเดียวกันประเทศอื่นแต่มีการใช้ภาษามีความแตกต่างกันในรายละเอียดปลีกย่อย. และสิ่งเหล่านี้เองเป็นปัจจัยที่ทำให้โปรแกรมที่ใช้ในคอมพิวเตอร์ต้องเปลี่ยนจากการสนับสนุนภาษาอังกฤษอย่างเดียวมาสนับสนุนภาษาต่างๆ.

วิธีการทำให้โปรแกรมสนับสนุนภาษาอื่นนอกจากภาษาอังกฤษที่เข้าใจง่ายที่สุดคือการแก้ไขไฟล์ต้นฉบับของโปรแกรมเช่นถ้าเป็นโปรแกรมแบบ GUI ก็อาจจะเปลี่ยนข้อความที่ใช้แสดงในเมนูเป็นภาษาท้องถิ่นหรือปรับรหัสต้นฉบับส่วนอื่นๆให้เหมาะสมกับภาษาที่ต้องการใช้. การกระทำในลักษณะนี้เรียกว่าการ \emph{localization}\gindex{localization} หรือเรียกย่อๆว่า \emph{L10N}\gindex{l10n}\mymemo{เลข 10 ที่อยู่ใน L10N คือจำนวนอักษรที่อยู่ระหว่าง l กับ n ในคำว่า localization.} เป็นหลักการที่เข้าใจง่ายแต่มีข้อเสียบางอย่างเช่นถ้าต้องการทำให้โปรแกรมรองรับภาษาไทย 10 ภาษาก็จะได้โปรแกรมที่ปรับแก้ไขแล้ว 10 โปรแกรมเป็นต้น.

กลวิธีอีกอย่างที่สามารถทำให้โปรแกรมรองรับภาษานานาชาติได้โดยส่งผลกระทบรหัสต้นฉบับเดิมให้น้อยที่สุดคือการ \emph{Internationalization}\gindex{internationalization} หรือเขียนย่อๆว่า \emph{I18N}\gindex{i18n}\mymemo{เลข 18 ที่อยู่ใน I18N หมายถึงจำนวนอักษรที่อยู่ระหว่าง I และ N.}. แนวความคิดของ I18N จะต่างจาก L10N ที่ว่าจะแยกส่วนที่จัดการหรือเกี่ยวข้องภาษาท้องถิ่นเช่นข้อความที่ต้องแสดง ฯลฯ ออกจากตัวรหัสต้นฉบับ. แต่รหัสต้นฉบับนั้นต้องเขียนอยู่ในมาตรฐานที่กำหนดที่สามารถรองรับภาษานานาชาติได้. วิธีนี้เป็นวิธีที่สะอาดกว่าการ L10N สามารถแยกงานของผู้พัฒนาซอฟต์แวร์กับผู้แปลภาษาออกจากกันได้ง่าย.

การรองรับภาษาไทยไม่จำกัดเฉพาะข้อมความที่ใช้แสดงในโปรแกรมเท่านั้น. การประมวลผลของโปรแกรมที่เกี่ยวกับข้องกับภาษายังมีอีกหลายส่วนเช่น
\begin{itemize}
\item การเข้ารหัสอักขระ (character encoding)\mymemo{คำว่า encryption ก็แปลงเป็นไทยว่าการเข้ารหัสเช่นกัน.} คือการนำเสนอข้อมูลอักขระเป็นสายข้อมูลในหน่วยไบต์. ในแต่ละภาษาใช้จำนวนบิตแสดงข้อมูลต่างกัน. ข้อมูล 7 บิตสามารถแทนอักขระทั่วไปที่ใช้ในภาษาอังกฤษได้ทุกตัวในขณะที่ภาษาไทยต้องใช้ข้อมูล 8 บิต (1 ไบต์) เพื่อที่จะแสดงทั้งข้อมูลภาษาอังกฤษและภาษาไทย.
\item การแสดงวันเดือนปี. โปรแกรมที่รองรับ I18N จะแสดงวันเดือนปีให้เหมาะสมกับสภาพแวดล้อมของผู้ใช้เช่นสำหรับคนไทยจะคุ้นเคยกับปี พ.ศ. มากกว่าปี ค.ศ. เป็นต้น.
\item การแสดงตัวเลขและสกุลเงินตรา. ในบางประเทศจะมีวิธีการแสดงจำนวนจุดทศนิยมไม่เหมือนกันเช่นในประเทศฝรั่งเศสจะนิยมเขียนจุดทศนิยมเป็นเครื่องหมายลูกน้ำ.
\item การรองรับภาษานานาชาติโดยตัวโปรแกรมอย่างเดียวบางครั้งไม่เพียงพอ. ในสภาพแวดล้อมที่รองรับภาษานานาชาติต้องมีฟอนต์เพื่อแสดงผลอักขระต่างๆให้ถูกต้องด้วย.
\item สภาพแวดล้อมที่เปิดให้ป้อนข้อมูลได้หลายภาษาจะสามารถตั้งผังแป้นพิมพ์ได้หลายภาษาพร้อมๆกัน.
\end{itemize}

%ในบทนี้จะแนะนำปัญหาและการประมวลผลที่เกี่ยวกับภาษาไทยในลินุกซ์.

\section{ความรู้เบื้องต้นเกี่ยวกับอักขระไทย}
ก่อนที่จะแนะนำเรื่องเกี่ยวกับการประมวลผลข้อมูลภาษาไทย, เราจะมาทำความเข้าใจกับอักขระไทยและศัพท์เทคนิคที่เกี่ยวข้องก่อนดังนี้.
\begin{itemize}
\item อักขระ (character) --- สัญลักษณ์ที่มีความหมายในตัวเช่น ``a'' คืออักขระที่แสดงถึงตัวอักษร ``a''. อักขระ\gindex{อักขระ}มีความหมายคลอบคลุมถึงตัวอักษร, ตัวเลข, เครื่องหมายพิเศษ และเครื่องหมายอื่นๆ.
\item รหัส (code) --- ค่าตัวเลขที่ใช้แทนอักขระ.
\item ชุดอักขระ\gindex{ชุดอักขระ} (character set)\gindex{character set} --- กลุ่มของอักขระ. โดยทั่วไปจะถือว่ามีความหมายเดียวกันกับชุดรหัสอักขระ.
\item ชุดรหัสอักขระ\gindex{ชุดรหัสอักขระ} (coded character set)\gindex{coded character set} --- บางครั้งเรียกย่อๆว่า charset\gindex{charset|see{coded character set}}, code set\gindex{code set|see{coded character set}} หมายถึงชุดอักขระที่อักขระทุกตัวมีรหัสประจำตัวเช่น ``a'' มีค่ารหัสเป็น 0x61 (เลขฐานสิบหก) ฯลฯ.
\item การเข้ารหัสอักขระ (character encoding) --- วิธีการ, รูปแบบการนำเสนอข้อมูลรหัสอักขระเป็นสายข้อมูลไบต์.
\item ยูนิโค้ด (unicode) --- ชุดรหัสอักขระที่รวมอักขระของภาษานานาชาติไว้ในชุดเดียวและใช้ค่าหมายเลขขนาด 16 บิตในการนำเสนอ.
\item กลีฟ (glyph)\gindex{กลีฟ}\gindex{glyph} --- รูปอักขระที่ใช้ในการแสดงผล.
\end{itemize}

\subsection{รหัสอักขระ TIS-620}
อักขระภาษาไทยที่ใช้ในคอมพิวเตอร์นิยามไว้ใน มอก.620-2533\gindex{มอก.620-2533} (TIS-620)\gindex{tis-620@TIS-620} \cite{tis620} โดยสำนักงานมาตรฐานผลิตภัณฑ์อุตสาหกรรม (สมอ.)\gindex{สมอ.} มีอยู่ 87 ตัวประกอบด้วย
\begin{itemize}
%\item อักขระ ASCII (94 ตัว) ---  ! " \#{} \${} \%{} \&{} ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \bs{} ] \^{} \_{} ` a b c d e f g h i j k l m n o p q r s t u v w x y z \{{} | \}{} \~{}
\item พยัญชนะไทย (46 ตัว) --- ก ข ฃ ค ฅ ฆ ง จ ฉ ช ซ ฌ ญ ฎ ฏ ฐ ฑ ฒ ณ ด ต ถ ท ธ น บ ป ผ ฝ พ ฟ ภ ม ย ร ล ว ศ ษ ส ห ฬ อ ฮ
\item สระ (19 ตัว) --- ฤ ฦ ะ -ั า ำ -ิ -ี -ึ -ื -ุ -ู -ฺ (พินทุ) เ แ โ ใ ไ -\char237{} (นิคหิต)
\item วรรณยุกต์และทัณฑฆาต (5 ตัว) --- -่ -้ -๊ -๋ -์ (ทัณฑฆาต)
\item ตัวเลขไทย (10 ตัว) --- ๐ ๑ ๒ ๓ ๔ ๕ ๖ ๗ ๘ ๙
\item เครื่องหมายพิเศษ (7 ตัว) --- ฯ ฿ ๅ -\char238{} (ยามักการ) ๏ (ฟองมัน) \char250{} (อังคั่นคู่) \char251{} (โคมูตร)
\end{itemize}
เราเรียกชุดรหัสอักขระนี้ว่า TIS-620 (รูปที่ \ref{fig:tis620-table}) ประกาศใช้สาธารณะเมื่อปีพ.ศ. 2529 และได้รับการปรับปรุงอีกทีเมื่อปีพ.ศ. 2533.

\begin{figure}[!htb]
\plfigure{.7}{tis620-table.eps}{ตารางรหัสอักขระ TIS-620.}{tis620-table}
\end{figure}

วิธีการดูตารางรหัสอักขระจะเริ่มจากการอ่านตัวเลขที่อยู่ข้างบนตารางก่อนและตามด้วยตัวเลขที่อยู่ด้านซ้ายของตาราง. ตัวเลขเหล่านี้เป็นตัวเลขฐาน 16 มีค่าตั้งแต่ 0 ถึง F. ตัวอย่างเช่น ``a'' มีค่ารหัสเป็น 0x61 หรือแปลงเป็นเลขฐานสองเป็น 1100001. อักขระ ASCII (ภาษาอังกฤษ) จะอยู่ในช่วง 0x00 - 0x7F (0000000 - 1111111) และอักขระภาษาไทยจะอยู่ในช่วง 0xA1 - 0xFB (10100001 - 11111011). จะเห็นได้ว่าในระบบที่รองรับภาษาอังกฤษอย่างเดียวสามารถนำเสนอข้อมูลได้โด้ยใช้ข้อมูลอักขระขนาด 7 บิต. ถ้าต้องการเพิ่มการนำเสนอข้อมูลภาษาไทยด้วยต้องใช้ข้อมูลอักขระขนาด 8 บิตหรือ 1 ไบต์.

เราสามารถแบ่งข้อมูลในตารางที่แสดงชุดรหัสอักขระแบบ 8 บิตเป็นส่วนต่างๆได้ดังนี้
\begin{itemize}
\item C0 --- ส่วนอักขระควบคุม (control characters) ที่ตำแหน่งบิตตัวที่ 8 (หลักตัวเลขที่อยู่ซ้ายสุด) มีค่าเป็นศูนย์, 0x00 (00000000) - 0x1F (00011111) และ 0x7F (01111111).
\item G0 หรือ GL --- ได้แก่ชุดอักขระที่ตำแหน่งบิตตัวที่ 8 มีค่าเป็นศูนย์, 0x20 (00100000) - 0x7E (01111110). GL ย่อมาจากคำว่า \emph{Graphics Left}\gindex{graphics left}.
\item C1 --- ส่วนอักขระควบคุมที่ตำแหน่งบิตตัวที่ 8 มีค่าเป็นหนึ่ง, 0x80 (1000000) - 0x9F (10011111).
\item G1 หรือ GR --- ได้แก่ชุดอักขระที่ตำแหน่งบิตตัวที่ 8 มีค่าเป็นหนึ่ง, 0xA0 (10100000) - 0xFF (11111111). GR ย่อมาจากคำว่า \emph{Graphics Right}\gindex{graphics right}.
\end{itemize}

อักขระภาษาไทยจะอยู่ในตำแหน่ง GR ซึ่งชุดรหัสอักขระอื่นๆเช่น ISO 8859-1\gindex{iso 8859-1@ISO 8859-1}\mymemo{ISO 8859-1 เป็นชุดรหัสอักขระภาษาที่ใช้ในยุโรปตะวันตก. มีชื่อเรียกอีกอย่างว่า Latin1.}, ISO 8859-2 ฯลฯ กำหนดรหัสของอักขระในภาษาของตนเองไว้ในช่วง GR เช่นกัน. คอมพิวเตอร์รับรู้ข้อมูลต่างๆเป็นไบนารีดังนั้นเวลาที่คอมพิวเตอร์รับข้อมูลเท็กซ์เช่น 0xA1, คอมพิวเตอร์ไม่สามารถตัดสินได้ว่า 0xA1 คืออักขระภาษาไทย ``ก'' หรือภาษาลาติน. วิธีแก้ปัญหานี้มีอยู่ 2 ทางคือบอกให้ระบบปฏิบัติรับรู้ว่าสภาพแวดล้อมภาษาที่ใช้อยู่, หรือเปลี่ยนไปใช้ชุดรหัสอักขระยูนิโค้ดซึ่งช่วงรหัสอักขระของภาษาไทยจะไม่ซ้ำกับ latin1.

\begin{figure}[!htb]
\plfigure{.7}{iso8859-1-table.eps}{ตารางรหัสอักขระ ISO-8859-1 (Latin1).}{iso8859-1-table}
\end{figure}

\subsection{ชุดรหัสอักขระ ISO 8859-11}
ชุดรหัสอักขระ ISO 8859-11 \gindex{iso 8859-11@ISO 8859-11} เป็นชุดรหัสอักขระภาษาไทยที่ขยายต่อจากมาตรฐาน ISO 8859 ซึ่งเป็นมาตรฐานรหัสอักขระที่สามารถแสดงได้ด้วยข้อมูล 8 บิต (1 ไบต์) และนิยมใช้กันในหมู่ประเทศทางยุโรป. ค่ารหัสของชุดอักขระนี้เหมือนกับรหัสอักขระ TIS-620 ทุกประการและเป็นมาตรฐานที่องค์กรมาตรฐานโลก (ISO, International Organization for Standardization) ประกาศใช้เมื่อปี พ.ศ. 2544.

\subsection{ชุดรหัสอักขระยูนิโค้ดและ ISO 10646}
\begin{figure}[!htb]
\plfigure{.7}{unicode-table.eps}{ตารางรหัสอักขระยูนิโค้ดช่วงภาษาไทย.}{unicode-table}
\end{figure}
ชุดรหัสอักขระ\emph{ยูนิโค้ด (Unicode, Universal chracter encoding)}\gindex{ยูนิโค้ด}\gindex{unicode} เป็นชุดรหัสอักขระที่รวมอักขระของภาษาต่างๆเข้าไว้ด้วยกันเป็นชุดเดียว. รหัสที่มอบหมายให้อักขระพื้นฐานมีค่าตั้งแต่ 0x0000 ถึง 0xFFFD จะเรียกว่า \emph{Basic Multilingual Plane (BMP)}\gindex{basic multilingual plane@Basic Multilingual Plane}\gindex{bmp@BMP|see{Basic Multilingual Plane}} ซึ่งมีภาษาหลักๆที่ใช้กันทั่วโลกรวมอยู่ในนี้. รหัสอักขระภาษาไทยจะอยู่ในช่วง 0x0E00 - 0x0E7F แต่ค่ารหัสที่ใช้จริงจะอยู่ในช่วง 0x0E01 - 0x0E5B ในรูปที่ \ref{fig:unicode-table}.

ชุดอักขระที่รวมภาษาต่างๆเข้าด้วยกันอีกตัวคือ \emph{ISO 10646}\gindex{iso 10646@ISO 10646} ซึ่งในปัจจุบันได้ทำการตกลงกับยูนิโค้ดรวมเนื้อหาเข้าด้วยกันเพื่อความไม่สับสนของผู้ใจแต่ยังใช้ชื่อแยกกันอยู่. ชุดรหัสอักขระยูนิโค้ดแบบ BMP จะใช้ข้อมูลขนาด 2 ไบต์ (16 บิต) แทนอักขระหนึ่งตัวซึ่งเพียงพอต่อภาษาหลักๆที่มีอยู่ในโลก. และสามารถขยายเพิ่มขึ้นอีกมีขนาดสูงสุด 4 ไบต์ (32 บิต) ซึ่งเป็นยูนิโค้ดชุดสมบูรณ์.


\subsection{การเข้ารหัสอักขระ}
คอมพิวเตอร์จะรับรู้การนำข้อมูลอักขระในรูปของสายข้อมูลไบต์ซึ่งเรียกว่า\emph{การเข้ารหัสอักขระ\gindex{การเข้ารหัสอักขระ} (character encoding)\gindex{character encoding}}. วิธีการเข้ารหัสอักขระที่ง่ายที่สุดคือใช้รหัสที่กำหนดไว้ในชุดรหัสอักขระตรงๆเช่นข้อมูลของอักขระ ``ก'' เมื่อเข้ารหัสอิงตามชุดรหัสอักขระ TIS-620 แล้วจะมีค่าเป็น 0xA1 เป็นต้น. การใช้รหัสแสดงข้อมูลแบบนี้มีผลเสียที่ว่าคอมพิวเตอร์ไม่สามารถรับรู้ประเภทของอักขระว่าเป็นภาษาไทยหรือภาษาลาติน. ถ้าเป็นการส่งข้อความผ่านทางเมลและไม่มีการบอกให้โปรแกรมอ่านเมลรู้ว่ารหัสที่ใช้เป็นภาษาไทย, ตัวโปรแกรมจะถือว่าเป็นรหัส ISO 8859-1 แทนที่จะเป็น TIS-620 เพราะรหัส ISO 8859-1 ใช้กันแพร่หลายมากกว่าภาษาไทยเป็นผลทำโปรแกรมอ่านเมลแสดงรูปทรงอักขระไม่ถูกต้อง.

สำหรับชุดอักขระยูนิโค้ดแบบ BMP ถ้าจะใช้ค่ารหัสลงรหัสอักขระตรงๆจะใช้พื้นที่ 2 ไบต์ต่อหนึ่งอักขระเช่น ``ก'' เมื่อเข้ารหัสอักขระแล้วมีค่าเป็น 0x0E01. วิธีการเข้ารหัสอักขระแบบนี้มีชื่อเรียกว่า \emph{UCS-2}\gindex{ucs-2@UCS-2}. ในทำนองเดียวกัน, ชุดอักขระยูนิโค้ดแบบสมบูรณ์จะใช้พื้นที่ 4 ไบต์ต่อหนึ่งอักขระในการเก็บข้อมูลเช่น ``ก'' เมื่อเข้ารหัสอักขระแล้วมีค่าเป็น 0x00000E01. วิธีการเข้ารหัสอักขระแบบนี้มีชื่อเรียกว่า \emph{UCS-4}\gindex{ucs-4@UCS-4}.

วิธีการเข้ารหัสอักขระแบบ UCS-2 และ UCS-4 มีข้อเสียคือใช้เนื้อที่เก็บข้อมูลเกินความจำเป็นทำให้มีการคิดค้นวิธีเข้ารหัสที่มีประสิทธิภาพยิ่งขึ้นโดยการแปลงค่ารหัสอักขระที่เรียกว่า \emph{UTF (Unicode Transformation Format)}\gindex{utf@UTF}\gindex{unicode transformation format@Unicode Transformation Format}. วิธีเข้ารหัสอักขระ UTF มีวิธีหลายวิธีแยกย่อยไปอีกได้แก่ UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32, UTF-32BE และ UTF-32LE.\mymemo{LE ย่อมาจาก Little Endian. BE ย่อมาจาก Big Endian} วิธีเข้ารหัสอักขระที่นิยมใช้กันได้แก่ \emph{UTF-8}\gindex{utf-8@UTF-8} ซึ่งมีข้อดีหลายประการและมีคุณสมบัติเด่นๆคือ.
\begin{itemize}
\item ค่ารหัสที่เข้ารหัสแล้วของอักขระในช่วง 0x0000 - 0x007F จะเหมือนกับค่ารหัสอักขระ ASCII. ทำให้วิธีการประมวลผลข้อมูลภาษาอังกฤษไม่เปลี่ยนแปลงถึงแม้ข้อมูลที่ใช้จะเป็นยูนิโค้ด.
\item รหัสอักขระยูนิโค้ดตั้งแต่ 0x0080 จะถูกแปลงเป็นข้อมูลในหน่วย 1 ไบต์เรียงต่อกัน 2 หรือ 3 ตัวขึ้นอยู่กับช่วงของอักขระ. อักขระลาตินหนึ่งตัวจะถูกแปลงเป็นข้อมูล 2 ไบต์. ส่วนอักขระภาษาไทยหนึ่งตัวจะถูกแปลงเป็นข้อมูล 3 ไบต์. ตัวอย่างเช่น ``ก'' ซึ่งมีค่ารหัสยูนิโค้ด 0x0E01 เวลาเข้ารหัสแบบ UTF-8 จะเป็น 0xE0 0xB8 0x81 (11100000 10111000 10000001).
\item ค่าที่เข้ารหัสแล้วมีกฏเกณฑ์ที่แน่นอนสามารถบอกจำนวนไบต์ที่ต้องแปลงกลับเป็นรหัสยูนิโค้ดได้.
\end{itemize}
ในที่นี้จะไม่อธิบายวิธีการเอ็นโค้ดแบบ UTF-8 แต่สามารถหาอ่านได้จาก RFC 2279 \cite{rfc2279}.

\begin{table}[!tb]
\center
\caption{ค่ารหัสอักขระยูนิโค้ดช่วงต่างๆหลังจากเข้ารหัสแบบ UTF-8.}
\medskip
\begin{tabular}{ll}
\toprule
\multicolumn{1}{c}{ช่วงรหัสยูนิโค้ด BMP} & \multicolumn{1}{c}{ค่าหลังจากที่เข้ารหัส UTF-8 (แสดงด้วยเลขฐานสอง)}\\
\midrule
\cmd{0x0000 - 0x007F} & \cmd{0\textit{xxxxxxx}}\\
\cmd{0x0080 - 0x07FF} & \cmd{110\textit{xxxxx} 10\textit{xxxxxx}}\\
\cmd{0x0800 - 0xFFFF} & \cmd{1110\textit{xxxx} 10\textit{xxxxxx} 10\textit{xxxxxx}}\\
\bottomrule
\end{tabular}
\end{table}

ปัจจุบันโปรแกรมที่ต้องรองรับภาษานานาชาติมักจะเก็บข้อมูลในรูป UTF-8 เช่นเว็บเพจ, ไฟล์ XML. ผลดีคือสามารถแสดงภาษาหลายภาษาได้ด้วยชุดอักขระตัวเดียว. สำหรับภาษาไทยมีข้อเสียเล็กน้อยที่ขนาดของข้อมูลที่เก็บจะเพิ่มขึ้น 3 เท่าเนื่องจากการเอ็นโค้ดแบบ UTF-8. และนี่เป็นเหตุผลหนึ่งที่คนทั่วไปยังใช้เอ็นโค้ดแบบ TIS-620 อยู่เพราะกินพื้นที่ต่อหนึ่งอักขระแค่ 1 ไบต์. อย่างไรก็ตาม, ยูนิโค้ดและการเข้ารหัสแบบ UTF-8 เป็นที่ยอมรับและนิยมใช้กันอย่างกว้างขวางในปัจจุบันและอาจเรียกได้ว่าเป็นมาตรฐานไปแล้ว.

\subsection{การเปลี่ยนการเข้ารหัสด้วย \cmd{iconv}}
การเข้ารหัสของภาษาไทยที่นิยมใช้กันมีอยู่สองแบบคือ TIS-620\mymemo{เนื่องจากการเข้ารหัสแบบ ISO-8859-11 ให้ผลเหมือนกับ TIS-620 ในที่นี้จะเรียกการเข้ารหัสสองแบบนี้รวมกันเป็น TIS-620.} และ UTF-8. ในกรณีที่ต้องการเปลี่ยนการเข้ารหัสของข้อมูลจะใช้คำสั่ง \cmd{iconv}\cindex{iconv}\refcmd{iconv}.
\begin{MyExample}[แปลงข้อมูล TIS-620 เป็น UTF-8.]
\begin{MyEx}
$ \cin{iconv -f TIS-620 -t UTF-8 -o thai_utf8.txt thai_tis620.txt}
\end{MyEx}
\end{MyExample}%$
ตัวเลือก \cmd{-f} (from) ใช้ระบุการเข้ารหัสของข้อมูลนำเข้าและตัวเลือก \cmd{-t} (to) ใช้ระบุการเข้ารหัสของผลลัพธ์ที่ต้องการ. คำสั่ง \cmd{iconv} จะรับข้อมูลจาก stdin ถ้าไม่ระบุชื่อไฟล์และจะส่งผลลัพธ์ออกทาง stdout ถ้าไม่ระบุชื่อไฟล์ที่ต้องการเก็บผลลัพธ์. ชื่อการเข้ารหัสที่คำสั่ง \cmd{iconv} สามารถแปลงได้ดูได้จากตัวเลือก \cmd{-l}.
\begin{MyExample}[ชื่อการเข้ารหัสต่างๆที่รองรับในคำสั่ง \cmd{iconv}]
\begin{MyEx}
$ \cin{iconv -l}
\abb
  TCVN5712-1, TCVN5712-1:1993, TIS-620, TIS620-0, TIS620.2529-1, TIS620.2533-0,
  TIS620, TS-5881, TSCII, UCS-2, UCS-2BE, UCS-2LE, UCS-4, UCS-4BE, UCS-4LE,
  UCS2, UCS4, UHC, UJIS, UK, UNICODE, UNICODEBIG, UNICODELITTLE, US-ASCII, US,
  UTF-7, UTF-8, UTF-16, UTF-16BE, UTF-16LE, UTF-32, UTF-32BE, UTF-32LE, UTF7,
  UTF8, UTF16, UTF16BE, UTF16LE, UTF32, UTF32BE, UTF32LE, VISCII, WCHAR_T,
\abb
\end{MyEx}
\end{MyExample}%$
ชื่อการเข้ารหัสที่เกี่ยวข้องกับภาษาไทยได้แก่ TIS-620, TIS620-0, TIS620.25259-1, TIS620.2533-0, TIS620 และ CP874. การเข้ารหัสแบบ TIS-620 มีหลายชื่อให้เลือกแต่ผลที่ได้ไม่มีความแตกต่างกันและสามารถระบุชื่อการเข้ารหัสด้วยตัวอักษรตัวเล็กเช่น tis-620 ได้ด้วย. CP874 เป็นการเข้ารหัสอักขระภาษาไทยในระบบปฏิบัติการวินโดวส์ซึ่งคล้ายเหมือนกับ TIS-620.

คำสั่งที่คล้ายกับ \cmd{iconv} อีกตัวคือคำสั่ง \cmd{convmv}\cindex{convmv} ใช้สำหรับแปลงการเข้ารหัสอักขระของชื่อไฟล์.



\section{โลแคล}
\emph{โลแคล (locale)}\gindex{locale}\gindex{โลแคล} คือแนวคิดการกำหนดสภาพแวดล้อมภาษารวมถึงวัฒนธรรมของผู้ใช้ในระบบคอมพิวเตอร์. แนวคิดนี้มีเริ่มใช้ในมาตรฐาน ISO 9899 ซึ่งเป็นมาตรฐานสากลของภาษา C. แนวคิดเรื่องโลแคลมีผลดีต่อผู้พัฒนาซอฟต์แวร์และผู้ใช้. สำหรับผู้พัฒนาซอฟต์แวร์สามารถพัฒนาซอฟต์แวร์โดยไม่ต้องคำนึงถึงการประมวลผลที่เกี่ยวกับภาษา. ฟังก์ชันไลบรารีมาตรฐานในภาษา C เช่น \cmd{isalnum}, \cmd{isdigit}, \cmd{tolower} ฯลฯ จะรับรู้ข้อมูลเกี่ยวกับภาษาที่ต้องการประมวลผล. ผู้พัฒนาไม่ต้องเขียนโค้ดเพื่อประมวลผลสิ่งเหล่านี้เองเมื่อสภาพแวดล้อมของภาษาเปลี่ยนไป. ในแง่ของผู้ใช้โปรแกรม, สามารถเลือกภาษาที่ใช้ในการแสดงผลตามต้องการ ฯลฯ.

\begin{figure}[!htb]
\plfigurethree{.55}{zenity-calendar-en.eps}{zenity-calendar-th.eps}{zenity-calendar-ja.eps}{การแสดงข้อความในโปรแกรมเมื่อสภาพแวดล้อมโลแคลต่างกัน.}{zenity-calendar}
\end{figure}

\subsection{ชื่อโลแคล}
ในระบบที่รองรับการใช้โลแคลจะมีฐานข้อมูลโลแคลของภาษาต่างๆแยกตามชื่อโลแคล. ชื่อโลแคลมีรูปแบบทั่วไปดังนี้.
\begin{MyVerbatim}
\textit{language}[_\textit{territory}][.\textit{codeset}]
\end{MyVerbatim}
ตัวอย่างชื่อโลแคลเช่น \cmd{th}, \cmd{th\_TH}, \cmd{th\_TH.TIS-620}, \cmd{th\_TH.UTF-8}. ส่วนที่ประกอบเป็นชื่อโลแคลได้แก่.
\begin{itemize}
\item \cmdit{language} --- ชื่อภาษาเช่นภาษาไทย \cmd{th}, ภาษาอังกฤษ \cmd{en}, ภาษาญี่ปุ่น \cmd{ja} เป็นต้น. ชื่อภาษานี้เป็นชื่ออักษรภาษาอังกฤษ 2 ตัวตามมาตรฐาน ISO639.
\item \cmdit{territory}\gindex{territory} --- ชื่อประเทศที่ใช้ภาษานั้น. ภาษาเช่นภาษาอังกฤษใช้กันแพร่หลายในประเทศ. ประเทศสหราชอณาจักรอังกฤษใช้ภาษาอังกฤษ, ประเทศสหรัฐอเมริกาก็ใช้ภาษาอังกฤษ. ถึงแม้ว่าจะใช้ภาษาอังกฤษเหมือนกันแต่ภาษาหรือวัฒนธรรมที่ใช้ในแต่ละท้องถิ่นมีความแตกต่างกันในรายละเอียด. และส่วนที่เรียกว่า territory นี้เป็นตัวบ่งบอกสถานที่ที่ใช้ภาษานั้น. ตัวอย่างเช่น \cmd{TH} (Thailand), \cmd{GB} (Great Britain), \cmd{US} (United State of America), \cmd{JP} (Japan) ฯลฯ. ชื่อ territory จะเป็นอักษรภาษาอังกฤษตัวใหญ่สองตัวตามมาตรฐาน ISO3166. สำหรับภาษาที่มีใช้ในประเทษเดียวเท่านั้นเช่นภาษาไทยสามารถละเลยชื่อโลแคลส่วนนี้ได้. ถ้าต้องการใช้ส่วน territory ให้เขียนใช้เครื่องหมาย \cmd{\_} ต่อจากชื่อภาษา. ตัวอย่างชื่อโลแคลที่มีส่วน territory เช่น \cmd{th\_TH}, \cmd{en\_GB}, \cmd{en\_US}, \cmd{ja\_JP} เป็นต้น.
\item \cmdit{codeset} --- ส่วนสุดท้ายในชื่อโลแคลได้แก่การเข้ารหัสที่ใช้ในโลแคล.
\end{itemize}

คำสั่ง \cmd{locale}\cindex{locale}\refcmd{locale} เป็นคำสั่งสำหรับแสดงฐานข้อมูลโลแคลในระบบเช่นแสดงชื่อโลแคลในระบบ (ตัวเลือก \cmd{-a}) หรือแสดงชื่อการเข้ารหัสอักขระต่างๆ (ตัวเลือก \cmd{-m}). ถ้าสั่งคำสั่งโดยไม่ระบุอาร์กิวเมนต์ใดๆจะแสดงโลแคลของผู้ใช้.
\begin{MyExample}[แสดงชื่อโลแคลในฐานข้อมูลที่มีในระบบ.]
\begin{MyEx}
$ \cin{locale -a}
C
POSIX
aa_DJ
aa_DJ.iso88591
\abb
tg_TJ.koi8t
th_TH
th_TH.tis620 \mycomment{หรือ \cmd{th_TH.TIS620}, \cmd{th_TH.TIS-620}}
th_TH.utf8 \mycomment{หรือ \cmd{th_TH.UTF8}, \cmd{th_TH.UTF-8}}
thai
ti_ER
\abb
\end{MyEx}
\end{MyExample}%$

ชื่อโลแคล \cmd{C} หรือ \cmd{POSIX} เป็นชื่อโลแคลพิเศษซึ่งไม่เกี่ยวข้องกับภาษาใดๆ. หมายถึงให้ระบบประมวลผลข้อมูลโดยที่ไม่ต้องคำนึงถึงเรื่องเกี่ยวกับภาษาและวัฒนธรรม.

สำหรับโลแคลบางตัวเช่นภาษาไทยสามารถมีการเข้ารหัสอักขระได้มากกว่าหนึ่งแบบดังนั้นชื่อโลแคลควรระบุให้ชัดเจนเช่น \cmd{th\_TH.TIS-620} หรือ \cmd{th\_TH.UTF-8}. ชื่อโลแคลเช่น \cmd{th\_TH} และ \cmd{thai} ที่ไม่ระบุการเข้ารหัสอักขระเป็นชื่อโลแคลแบบย่อ (alias) ที่กำหนดในไฟล์ \cmd{/usr/share/locale/locale.alias} หรือ \cmd{/usr/\wbr{}lib/\wbr{}X11/\wbr{}locale/\wbr{}locale.alias}\findex{locale.alias}.

\subsection{สร้างโลแคล}
ในระบบบางระบบอาจจะไม่มีฐานข้อมูลของโลแคลทุกตัว. ผู้ดูแลระบบสามารถสร้างฐานข้อมูลโลแคลเพิ่มเติมได้ด้วยคำสั่ง \cmd{localedef}\cindex{localedef}\refcmd{localedef}. การสร้างฐานโลแคลใหม่ต้องการข้อมูลเกี่ยวกับโลแคลอย่างน้อยสองอย่างคือข้อมูลดิบเกี่ยวกับตัวโลแคลและข้อมูลเกี่ยวกับการเข้ารหัสอักขระ. ในระบบที่รองรับการใช้โลแคลจะมีข้อมูลดิบของโลแคลเป็นไฟล์ชื่อโลแคลต่างๆเก็บไว้ในไดเรกทอรี \cmd{/usr/share/i18n/locales}. ข้อมูลเกี่ยวกับการเข้ารหัสอักขระจะเก็บไว้ในไดเรกทอรี \cmd{/usr/share/i18n/charmaps} ในรูปของไฟล์ที่บีบอัดด้วย \cmd{gzip}.

ตัวอย่างต่อไปนี้เป็นการสร้างโลแคล \cmd{th\_TH.TIS-620} ด้วยคำสั่ง \cmd{localedef}. หลังจากที่สร้างโลแคลแล้วสามารถตรวจสอบโลแคลที่สร้างใหม่ด้วยคำสั่ง \cmd{locale -a}. ในบางดิสโทรมาคำสั่งเฉพาะสำหรับสร้างโลแคลเช่น Debian มีคำสั่ง \cmd{locale-gen}\cindex{locale-gen} ซึ่งเป็นเชลล์สคริปต์และเรียกใช้คำสั่ง \cmd{localedef} เช่นกัน.

\begin{MyExample}[สร้างโลแคลในระบบ.]
\begin{MyEx}
# \cin{gzip -dc /usr/share/i18n/charmaps/TIS-620.gz > /tmp/TIS-620}
# \cin{localedef -f /tmp/TIS-620 -i /usr/share/i18n/locales/th_TH th_TH.TIS-620}
\end{MyEx}
\end{MyExample}

\subsection{ตัวแปรสภาพแวดล้อมที่เกี่ยวกับโลแคล}
การทำงานของโลแคลจะอิมพลีเมนต์ (implement) อยู่ในไลบรารีภาษา C ของ GNU (GNU C library). ผู้ใช้สามารถกำหนดสภาพแวดล้อมภาษาของตนเองที่ต้องการใช้ด้วยตัวแปรสภาพแวดล้อมต่างๆดังต่อไปนี้.
\begin{itemize}
\item \cmd{LC\_CTYPE} --- ตัวแปรสภาพแวดล้อมเกี่ยวกับการแยกแยะประเภขของอักขระ. เช่นในภาษาอังกฤษ, โปรแกรมสามารถแปลงอักษร ``A'' ให้เป็นตัวอักษรตัวเล็ก ``a'' ได้ซึ่งมีความหมายเดียวกัน. แต่ในสภาพแวดล้อมภาษาไทยเช่น ``ก'' ไม่มีแนวคิดเรื่องอักษรตัวใหญ่หรือตัวเล็ก.
\item \cmd{LC\_COLLATE} ---  ตัวแปรสภาพแวดล้อมเกี่ยวกับการจัดลำดับข้อมูล. ถ้าค่าของตัวแปรไม่เหมาะสมกับภาษาที่ใช้, โปรแกรมจัดลำดับข้อมูลอาจจะทำงานผิดพลาดได้. เช่นการใช้คำสั่ง \cmd{sort} เรียงลำดับคำภาษาไทยในสภาพแวดล้อมภาษาอังกฤษจะให้ผลไม่ถูกต้องเพราะวิธีเรียงลำดับข้อมูลแตกต่างตามภาษาที่ใช้.
\begin{MyExample}[ผลกระทบของภาษากับการเรียงลำดับข้อมูล.]
\begin{MyEx}
$ \cin{cat unsorted.txt}
zebra
\thtt{ไก่}
\thtt{กา}
\thtt{ช้าง}
\thtt{กบ}
ant
$ \cin{LC_COLLATE=C sort unsorted.txt} \mycomment{เรียงลำดับข้อมูลโดยไม่คำนึงถึงภาษา}
ant
zebra
\thtt{กบ}
\thtt{กา}
\thtt{ช้าง} \mycomment{เรียงลำดับผิด}
\thtt{ไก่}
$ \cin{LC_COLLATE=th_TH.TIS-620 sort unsorted.txt}
ant
zebra
\thtt{กบ}
\thtt{กา}
\thtt{ไก่}
\thtt{ช้าง}
\end{MyEx}
\end{MyExample}%$
\item\cmd{LC\_MESSAGES} --- โปรแกรมสามารถแสดงข้อความด้วยภาษาที่ระบุในตัวแปรสภาพแวดล้อมนี้เช่นในรูปที่ \ref{fig:zenity-calendar}.

\item\cmd{LC\_MONETARY} --- ตัวแปรสภาพแวดล้อมสำหรับแสดงสกุลเงินตรา.
\item\cmd{LC\_NUMERIC} --- ตัวแปรสภาพแวดล้อมเกี่ยวกับการแสดงตัวเลขเช่นจุดทศนิยม.

\begin{figure}[!htb]
\plfiguretwo{.4}{gnucash-fr.eps}{gnucash-th.eps}{การแสดงตัวเลขและสกุลเงินตราตามโลเคล.}{gnucash}
\end{figure}

\item\cmd{LC\_TIME} --- แสดงวันเดือนปีตามภาษาที่กำหนด. เช่นประเทศแถบยุโรปมักจะแสดงเวลาแบบ 24 ชั่วในขณะที่สหรัฐอเมริการแสดงเวลาเป็น 12 ชั่วโมง (AM/PM).
\item\cmd{LC\_ALL} --- ตัวแปรสภาพแวดล้อมพิเศษสำหรับบังคับการกำหนดค่าโลแคลของตัวแปรสภาพแวดล้อมที่ขึ้นต้นด้วย \cmd{LC\_} ตัวอื่นๆ. สมมติว่าเดิมกำหนดค่า \cmd{LC\_MESSAGES} เป็น \cmd{th\_TH} แต่มีการกำหนดค่า \cmd{LC\_ALL} เป็น \cmd{en}. ค่าตัวแปลสภาพแวดล้อมที่ขึ้นต้นด้วย \cmd{LC\_} รวมถึง \cmd{LC\_MESSAGES} ด้วยจะใช้ค่าที่กำหนดด้วยตัวแปรสภาพแวดล้อม \cmd{LC\_ALL}.
\item\cmd{LANG}\gindex{lanf@\cmd{LANG}} --- ตัวแปรสภาพแวดล้อมพิเศษคล้ายกับ \cmd{LC\_ALL} แต่จะมีผลกับตัวแปรสภาพแวดล้อมที่ขึ้นต้นด้วย \cmd{LC\_} ที่ไม่ได้ตั้งค่าไว้หรือมีค่าเป็น \cmd{en} หรือ \cmd{POSIX} เท่านั้น. ตัวอย่างเช่น \cmd{LC\_MESSAGES} ไม่มีค่าตั้งไว้แต่มีการตั้งค่า \cmd{LANG} เป็น \cmd{th\_TH}. ระบบจะถือว่า \cmd{LC\_MESSAGES} มีค่าเป็น \cmd{th\_TH} โดยปริยาย.
\end{itemize}

หลังจากที่รู้จัดตัวแปรสภาพแวดล้อมต่างๆที่เกี่ยวข้องกับโลแคลแล้วเราสามารถปรับแต่งสภาพแวดล้อมได้อย่างมีประสิทธิภาพขึ้น. ตัวอย่างเช่นเราต้องการใช้สภาพแวดล้อมที่เป็นภาษาไทยเท่าที่เป็นไปได้แต่ไม่ต้องการแสดงวันเวลาเป็นภาษาไทยก็สามารถตั้งค่าตัวแปรสภาพแวดล้อมได้ดังนี้.
\begin{MyExample}[การปรับแต่งค่าโลแคล.]
\begin{MyEx}
$ \cin{export LC_TIME=en_US}
$ \cin{export LANG=th_TH}
$ \cin{locale}
LANG=th_TH
LC_CTYPE="th_TH"
LC_NUMERIC="th_TH"
LC_TIME=en_US \mycomment{ยังเป็นภาษาอังกฤษหลังจากตั้งค่า \cmd{LANG}}
LC_COLLATE="th_TH"
LC_MONETARY="th_TH"
LC_MESSAGES="th_TH"
LC_PAPER="th_TH"
LC_NAME="th_TH"
LC_ADDRESS="th_TH"
LC_TELEPHONE="th_TH"
LC_MEASUREMENT="th_TH"
LC_IDENTIFICATION="th_TH"
LC_ALL=
\end{MyEx}
\end{MyExample}%$

\begin{figure}[!htb]
\plfigure{.43}{gnome-th.eps}{สภาพแวดล้อมเดสก์ท็อป GNOME ในโลแคลไทย.}{gnome-th}
\end{figure}


\section{การแสดงอักขระภาษาไทย}
จากช่วงที่ผ่านมาเราได้ทำความรู้จักกับอักขระภาษาไทย, การเข้ารหัสอักขระข้อมูล, ตลอดจนวิธีการระบุสภาพแวดล้อมที่ใช้งานด้วยโลแคล. สิ่งที่เราควรจะทำความรู้จักต่อไปคือการแสดงผลอักขระภาษาไทยทางหน้าจอ. การแสดงผลภาษาไทยสามารถทำได้ทั้งในเท็กซ์โหมด (คอนโซล) และในระบบ X วินโดว์. ในที่นี้จะเน้นอธิบายการแสดงอักขระภาษาไทยในระบบ X วินโดว์เป็นหลัก.

ฟอนต์แบบดั้งเดิมที่ใช้ในระบบ X วินโดว์เป็นฟอนต์แบบบิตแมปและมีความสัมพันธ์กับชุดรหัสอักขระที่ต้องการใช้.

\subsection{ประวัติฟอนต์ภาษาไทยที่ใช้ในลินุกซ์}
%คำว่า ``ฟอนต์ภาษาไทยที่ใช้ในลินุกซ์'' เป็นคำที่คลุมเครือ. คำที่เหมาะสมมากกว่าคือ ``ฟอนต์ภาษาไทยที่ใช้ในระบบ X วินโดว์''.
ฟอนต์ภาษาไทยในยุคแรกๆสร้างขึ้นมาเพื่อใช้กับระบบ X วินโดว์บนระบบปฏิบัติการยูนิกซ์. เท่าที่ผู้เขียนสืบประวัติได้ฟอนต์ในยุคแรกสร้างขึ้นในปี พ.ศ.2535 โดย คุณวรเดช เย็นบุตร\gindex{วรเดช เย็นบุตร} มหาวิทยาลัยวอชิงตัน. ฟอนต์นี้เป็นฟอนต์บิตแมป BDF ชื่อ thai8x13 และ thai9x13 มีรูปทรงแบบเดียวคือรูปตัวตรงและไม่ใช้ชื่อฟอนต์ตามหลัก XFLD. ฟอนต์นี้ต่อมาเผยแพร่ทางเว็บไซด์ของกลุ่มนักเรียนไทยในมหาวิทยาลัย Tokyo Institute of Techonology (TIT) นำโดยคุณมานพ วงศ์สายสุวรรณ\gindex{มานพ วงศ์สายสุวรรณ}และคุณวุฒิชัย อัมพรอร่ามเวทย์\gindex{วุฒิชัย อัมพรอร่ามเวทย์}.

\begin{figure}[!htb]
\plfigure{1.0}{thai9x13.eps}{ฟอนต์ thai9x13.}{thai9x13}
\end{figure}


ในปี พ.ศ.2537 คุณมานพเพิ่มแก้ไขฟอนต์บิตแมปของโครงการบรรณาธิกรณ์ \cmd{mule}\mymemo{บรรณาธิกรณ์ \cmd{mule} เป็นบรรณาธิกรณ์ที่สร้างต่อเติมจาก \cmd{emacs} รองรับการใช้ภาษานานาชาติเช่น ภาษาญี่ปุ่น, ภาษาไทย ฯลฯ. ปัจจุบันได้รวมกลับเข้ามาในรหัสต้นฉบับของ \cmd{emacs} แล้ว.} โดยเพิ่มสร้างฟอนต์ส่วนที่เป็นภาษาไทยเพิ่มเข้าไปแล้วตั้งชื่อฟอนต์ใหม่สำหรับใช้กับภาษาไทย 3 ฟอนต์ได้แก่ฟอนต์ thai6x14, thai7x18 และ thai8x20. ฟอนต์เหล่านี้มีชื่อตาม XFLD และใช้ชุดรหัสอักขระเป็น tis620.25259-1 และสิทธิ์อนุญาตการใช้เป็น public domain. ในขณะเดียวกันกลุ่มนักเรียนไทยใน TIT ได้แปลงฟอนต์ทรูไทป์ภาษาไทย DBThaiText ให้เป็นฟอนต์บิตแมปแบบ BDF เพื่อใช้กับระบบ X วินโดว์อีกด้วย. รูปทรงฟอนต์ DBThaiText ที่แปลงมาจากฟอนต์ทรูไทป์ไม่ค่อยสวยงามนักเพราะเป็นการแปลงฟอนต์โดยการใช้โปรแกรมแปลงฟอนต์แต่มีข้อดีที่ว่ามีฟอนต์หลายขนาดและมีรูปทรงที่สำคัญๆครบถ้วนได้แก่ตัวหนาและตัวเอียง.

\begin{figure}[!htb]
\plfigure{1.0}{thai6x14.eps}{ฟอนต์ thai6x14.}{thai6x14}
\end{figure}


ในปี พ.ศ.2539 กลุ่มนักเรียนในมหาวิทยาลัย The University of Electro-communications, Tokyo เริ่มโครงการ ``สื่อไทย''\gindex{สื่อไทย} (ZzzThai)\gindex{zzzthai@ZzzThai} มีจุดประสงค์ส่งเสริมการใช้ภาษาไทยกับคอมพิวเตอร์ในแพล็ตฟอร์มหลักๆได้แก่ยูนิกซ์, วินโดวส์ และแมคอินทอช. โครงการนี้รวบรวมฟอนต์และจัดทำเอกสารในรูปของเว็บไซด์อธิบายการติดตั้งและใช้งานภาษาไทยเป็นขั้นเป็นตอนพร้อมรูปประกอบ. โครงการที่สืบต่อมาจากโครงการสื่อไทยและเกี่ยวข้องกับลินุกซ์ได้แก่โครงการ \emph{Thai Extension}\gindex{thai extension@Thai Extension} หรือเรียกย่อๆว่า TE\gindex{te@TE|see{Thai Extension}} เป็นโครงการรวมฟอนต์, โปรแกรมต่างๆที่เกี่ยวกับภาษาไทยรวมเป็นแพ็กเกจสำหรับติดตั้งเพิ่มในลินุกซ์ดิสทริบิวชันที่มีอยู่แล้วให้ใช้ภาษาไทยได้ทันที. โครงการนี้ร่วมกันทำโดยคุณ ไพศาล เตชะจารุวงศ์.\gindex{ไพศาล เตชะจารุวงศ์} และผู้เขียน. มีการแก้ไขฟอนต์ต่างๆให้เช่นชื่อ XFLD ของฟอนต์ที่มีมาให้ถูกต้องและเผยแพร่ฟอนต์บิตแมปใหม่ที่สร้างโดยคุณไพศาลเช่นฟอนต์ phaisarn-sanserif, phaisarn-thaismall, phaisarn-thaicom, phaisarn-thaimedia ฯลฯ. ฟอนต์ไพศาลบางตัวแตกต่างจากฟอนต์ที่เคยมีมาตรงที่มีอักขระพิเศษเพิ่มเติมเช่นมีวรรณยุกต์ 3 ชุดสำหรับการแสดงผลในตำแหน่งต่างๆให้สวยขึ้นเป็นต้น.

\begin{figure}[!htb]
\plfigure{1.0}{phaisarn-sanserif.eps}{ฟอนต์ -phaisarn-sanserif-medium-r-normal--14-140-100-100-p-80-tis620-2.}{phaisarn-sanserif}
\end{figure}

ในปี พ.ศ.2542 ศูนย์เทคโนโลยีอิเล็กทรอนิกส์และคอมพิวเตอร์แห่งชาติหรือ NECTEC ได้เริ่มโครงการฟอนต์แห่งชาติและเผยแพร่ฟอนต์ที่สำคัญๆได้แก่ฟอนต์ nectec-fixed หรือเรียกสั้นๆว่า nectec18 เป็นฟอนต์บิตแมปที่ความกว้างของอักขระทุกตัวเท่ากัน, ยกเว้นสระและวรรณยุกต์บางตัวที่มีความกว้างเป็นศูนย์. รูปทรงอักขระของฟอนต์นี้อ้วน, อ่านง่ายและเป็นฟอนต์ที่มีรูปร่างครบถ้วนได้แก่ตัวธรรมดา, ตัวหนา, ตัวเอียงและตัวหนาเอียง. ฟอนต์นี้นิยมใช้กับเทอร์มินอลเอมิวเลเตอร์ที่รองรับอักขระไทยเช่น \cmd{xiterm} ที่ได้รับการแพชท์แล้ว.

\begin{figure}[!htb]
\plfigure{1.0}{nectec18.eps}{ฟอนต์ nectec-fixed.}{nectec18}
\end{figure}

นอกจากฟอนต์บิตแมปแล้วเนคเทคยังเผยแพร่ฟอนต์แห่งชาติแบบทรูไทป์สำหรับใช้กับระบบ X วินโดว์บนลินุกซ์ได้แก่ฟอนต์ นรสีห์ (Norasi), ครุฑ (Garuda) และกินรี (Kinnari). ฟอนต์เหล่านี้มีตัวหนา, เอียงครบทุกชุด, ช่วยให้การแสดงผลอักขระภาษาไทยในระบบ X วินโดว์สวยงามขึ้นโดยเฉพาะระบบ X วินโดว์ที่รองรับการแสดงอักขระแบบแอนติอเลียส.

\begin{figure}[!htb]
\plfigure{1.0}{garuda.eps}{ฟอนต์ Garuda.}{garuda}
\end{figure}

หลังจากที่มีโครงการลินุกซ์ดิสทริบิวชันภาษาไทยลินุกซ์ทะเล (Linux TLE), หนึ่งในทีมพัฒนาลินุกซ์ทะเลคือคุณศิริชัย เลิศวรวุฒิ\gindex{ศิริชัย เลิศวรวุฒิ} ได้สร้างฟอนต์ทรูไทป์ตัวใหม่ชื่อฟอนต์ โลมา (Loma) ในปี พ.ศ.2546. ฟอนต์นี้รวมอยู่ในลินุกซ์ทะเลเผยแพร่ด้วยสิทธิ์การอนุญาตแบบ GPL. ฟอนต์นี้รูปทรงอ้วนกลมอ่านง่ายและเป็นฟอนต์โดยปริยายในลินุกซ์ทะเล.

\begin{figure}[!htb]
\plfigure{.9}{loma.eps}{ฟอนต์ Loma.}{loma}
\end{figure}

ฟอนต์ทรูไทป์ภาษาไทยที่ใช้กันในลินุกซ์มักจะเป็นฟอนต์ที่อักขระมีความกว้างไม่คงที่และฟอนต์ภาษาไทยยังขาดฟอนต์ทรูปไทป์ที่อักขระมีความกว้างคงที่อยู่. ในปี พ.ศ.2546 หลังจากที่ทีมงานลินุกซ์ทะเลเริ่มสร้างฟอนต์โลมาได้ไม่นาน, ผู้เขียนได้สร้างฟอนต์ทรูไทป์ที่อักขระทุกตัวมีความกว้างเท่ากันชื่อ TlwgMono และเผยแพร่ด้วยสิทธิ์การใช้แบบ GPL. ฟอนต์นี้นำส่วนอักขระภาษาอังกฤษมาจากฟอนต์ FreeMono และสร้างส่วนที่เป็นอักขระภาษาไทยด้วยโปรแกรม \cmd{fontforge}\mymemo{โปรแกรม \cmd{fontforge} เดิมชื่อ \cmd{pfaedit}.} ซึ่งเป็นซอฟต์เสรี.

\begin{figure}[!htb]
\plfigure{1.0}{tlwgmono.eps}{ฟอนต์ TlwgMono.}{tlwgmono}
\end{figure}

ปัจจุบัน, ฟอนต์ทรูไทป์ภาษาไทยที่แนะนำไปแล้วรวมไว้อยู่ในโครงการ thaifonts-scalable ได้รับการดูแลและพัฒนาต่อเติมเช่นเพิ่มตาราง OpenType, ปรับแต่งรูปร่างของอักขระ โดยอาสาสมัครกลุ่ม Thai Linux Working Group มี คุณเทพพิทักษ์ การุณบุญญานันท์\gindex{เทพพิทักษ์ การุณบุญญานันท์} เป็นแกนนำ.

\subsection{กลีฟ}
%ชื่อฟอนต์แบบ XFLD จะมีส่วนที่เกี่ยวข้องกับชุดรหัสอักขระเช่นชื่อฟอนต์ -nectec-fixed-medium-r-normal--18-180-72-72-c-90-tis620-0 เป็นฟอนต์สำหรับแสดงชุดอักขระ TIS 620. การแสดงอักขระ ``ก'' ซึ่งมีค่ารหัสเป็น 0xA1 จะเลือกอักขระที่มีค่าตรงกับรหัสอักขระ 0xA1 มาแสดง.
กลีฟคือรูปทรงอักขระในฟอนต์สำหรับแสดงผลทางหน้าจอ. โดยปรกติ, กลีฟจะมีความกว้างเฉพาะแต่ละตัว. แต่ถ้าอักขระภาษาไทยทุกตัวมีความกว้าง, เวลาแสดงผลตำแหน่งของสระและวรรณยุกต์บางตัวจะผิดปรกติตามที่แสดงในรูปที่ \ref{fig:thai-chars-fixed}. โปรแกรมที่ต้องการฟอนต์ที่อักขระทุกตัวมีความกว้างเท่ากันเช่น \cmd{xterm} และโปรแกรมเทอร์มินอลเอมิวเลเตอร์ต่างๆและตัวโปรแกรมจะจัดการแสดงผลเอง. ฟอนต์ภาษาไทยที่อักขระทุกตัวมีความกว้างเท่ากันหมดได้แก่ TlwgMono, -misc-fixed-medium-r-normal-{}-18-120-100-100-c-90-iso10646-1\mymemo{ฟอนต์ misc-fixed ที่มีอักขระภาษาไทยเป็นฟอนต์ที่รวมอยู่ในแพ็กเกจของ X เซิร์ฟเวอร์.} เป็นต้น.

\begin{figure}[!htb]
\plfigure{2.0}{thai-chars-fixed.eps}{ฟอนต์ที่กลีฟแต่ละตัวมีความกว้าง.}{thai-chars-fixed}
\end{figure}

สระและวรรณยุกต์บางตัวในฟอนต์ภาษาไทยส่วนใหญ่มักจะมีความกว้างเป็นศูนย์และตำแหน่งของกลีฟที่แสดงผลจะเยื้องไปหาพยัญชนะที่แสดงผลไปแล้ว. ฟอนต์ที่มีกลีฟในลักษณะนี้ช่วยให้โปรแกรมแสดงผลอักขระได้ทันทีโดยที่ตัวโปรแกรมไม่ต้องจัดลำดับอักขระเอง. ฟอนต์ภาษาไทยที่กลีฟแบบนี้เช่น ฟอนต์แห่งชาติ, Loma, Tlwg Typewriter, phaisarn-sanserif, ฟอนต์ทรูไทป์ในระบบปฏิบัติการวินโดวส์ เป็นต้น.

\begin{figure}[!tb]
\plfigure{2.0}{thai-chars-zero.eps}{กลีฟสระภาษาไทยที่มีความกว้างเป็นศูนย์.}{thai-chars-zero}
\end{figure}

\medskip
กลีฟในฟอนต์ภาษาไทยบางตัวจะมีสระและวรรณยุกต์บางตัวมากกว่าหนึ่งชุดเพื่อการแสดงผลที่สวยงาม. ตัวอย่างเช่นไม่เอกในรูปที่ \ref{fig:thai-chars-render} มีตำแหน่งที่เป็นไปได้สามที่คือ ตำแหน่งปรกติ, low และ low\_left. โปรแกรมที่รับรู้กลีฟเหล่านี้และสามารถจัดระดับสระและวรรณยุกต์ได้ถูกต้องจะไม่เกิดปัญหาที่เรียกว่าสระลอย. การจัดระดับสระวรรณยุกต์ไม่จำกัดเฉพาะสระที่อยู่บนพยัญชนะเท่านั้นการจัดระดับนี้รวมถึงสระอุ, สระอูตำแหน่งที่ต่ำกว่าปรกติสำหรับใช้กับพยัญชนะที่มีหางยาว ``ฎ'', ``ฏ''. ตัว ``ญ'' และ ``ฐ'' ที่ลดรูปเช่นคำว่า ``กตัญญู'' เป็นต้น.

ฟอนต์ภาษาไทยแบบดั้งเดิมได้แก่ฟอนต์บิตแมปจะมีส่วนขยายชื่อฟอนต์ XFLD เป็น tis620-0 หรือ tis620-2. จากชื่อฟอนต์เช่น -thai-fixed-medium-r-normal-{}-16-114-100-100-p-100-tis620-0 สามารถบอกได้ว่าเป็นฟอนต์ที่ใช้กับชุดรหัสอักขระ TIS-620 และไม่มีกลีฟพิเศษสำหรับจัดระดับสระวรรณยุกต์. ฟอนต์เช่น -phaisarn-sanserif-medium-r-normal-{}-14-140-100-100-p-80-tis620-2 เป็นฟอนต์ที่ใช้กับชุดรหัสอักขระ TIS-620 เช่นกันแต่มีกลีฟพิเศษสำหรับการจัดระดับสระวรรณยุกต์ในตำแหน่งรหัส 0x80 - 0x9F. ฟอนต์ภาษาไทยในระบบ fontconfig ซึ่งเป็นฟอนต์ทรูไทป์และเป็นฟอนต์แบบยูนิโค้ดจะมีกลีฟพิเศษในทำนองเดียวกันแต่เก็บไว้ในช่วงรหัสที่เรียกว่า \emph{PUA (Private Use Area)}\gindex{pua@PUA|see{Private Use Area}}\gindex{private use area@Private Use Area}. PUA เป็นช่วงรหัสในฟอนต์ที่ใช้เก็บกลีฟพิเศษไม่มีกฏเกณฑ์ที่แน่นอน. สำหรับฟอนต์ภาษาไทยจะนิยมเก็บกลีฟพิเศษต่างๆไว้ในช่วงรหัส 0xF700 - F71A. โปรแกรมสมัยใหม่ที่สามารถใช้ความสามารถของ OpenType จะไม่มีกลีฟพิเศษอีกต่อไปแต่จะใช้ข้อมูลการจัดระดับอักขระต่างจากตารางที่เรียกว่า \emph{GPOS (Glyph Positioning)}\gindex{glyph positioning@Glyph Positioning}\gindex{gpos@GPOS|see{Glyph Positioning}} และ \emph{GSUB (Glyph Substitution)}\gindex{gsub@GSUB|see{Glyph Substitution}}\gindex{glyph substitution@Glyph Substitution} ในฟอนต์แบบ OpenType.

\begin{figure}[!tb]
\plfigure{1.5}{thai-chars-render.eps}{การจัดระดับตำแหน่งสระและวรรณยุกต์.}{thai-chars-render}
\end{figure}

การจัดระดับสระวรรณยุกต์และแสดงผลภาษาไทยในสภาพแวดล้อมเดสก์ท็อป \mbox{GNOME} จะใช้ไลบรารีที่เรียกว่า \emph{Pango}\gindex{pango}. ไลบรารี Pango เป็นไลบรารีที่เกี่ยวกับกับการแสดงผลอักขระภาษานานาชาติและมีเกี่ยวข้องโดยตรงกับ GTK+, Xft และ fontconfig. ในส่วนที่เกี่ยวข้องกับการแสดงผลภาษาไทยเริ่มแรกเป็นการร่วมพัฒนาของ คุณชูกิจ วนาธรรม\gindex{คุณชูกิจ วนาธรรม} และต่อมามี คุณเทพพิทักษ์ พัฒนาต่อในปัจจุบัน.


\section{การป้อนข้อมูล}
ถ้าเราพิจารณาการแสดงผลอักขระภาษาไทยเช่นคำว่า ``ที่'' จะสังเกตเห็นว่าเกิดจากการรวมตัวของอักขระ 3 ตัวซึ่งถ้าใช้เครื่องพิมพ์ดีดพิมพ์สามารถพิมพ์ได้สองวิธีและให้ผลเหมือนกันได้แก่ ท -ี -่ หรือ ท -่ -ี. การแสดงผลของทั้งสองวิธีให้ผลเหมือนกันเนื่องจากกลีฟของสระอีและไม้เอกไม่มีความกว้าง. แต่ในแง่ของการป้อนข้อมูลให้กับคอมพิวเตอร์ ท -ี -่ (0x0E17 0x0E35 0x0E48) และ ท -่ -ี (0x0E17 0x0E48 0x0E35) เป็นสายข้อมูลที่แตกต่างกันอย่างสิ้นเชิง. ดังนั้นการป้อนข้อมูลให้ถูกต้องจึงมีความสำคัญสำหรับคอมพิวเตอร์โดยเฉพาะอย่างยิ่งการค้นหาข้อมูลจะเป็นปัญหาใหญ่ถ้าการป้อนข้อมูลผิดพลาดไม่เป็นมาตรฐานทำให้หาข้อมูลไม่เจอทั้งๆที่มีข้อมูลจริงแต่เรียงลำดับผิด. ปัญหาการป้อนข้อมูลผิดพลาดอย่างอื่นเช่นการป้อนข้อมูลซ้ำ. คำว่า ``ที่'' ถ้ามีไม้เอกสองตัวก็ยังเห็นเป็นคำว่า ``ที่'' เหมือนมีไม้เอกตัวเดียว.


กลวิธีการป้อนข้อมูลหรือในทางเทคนิคเรียกว่า \emph{Input Method (IM)}\gindex{input method@Input Method}\gindex{im@IM|see{Input Method}} เป็นกลวิธีในระบบ X วินโดว์ที่ใช้รับข้อมูลที่ป้อนเข้ามาทางแป้นพิมพ์ส่งต่อให้โปรแกรมหรือเซิร์ฟเวอร์ประมวลผลก่อนที่จะแปลงเป็นข้อมูลใช้งานจริง. การป้อนข้อมูลในลักษณะมักจะใช้ในการป้อนข้อมูลภาษาที่ซับซ้อนและไม่สามารถป้อนข้อมูลโดยตรงจากแป้นพิมพ์เช่น ภาษาญี่ปุ่น, ภาษาจีน และภาษาเกาหลี. กลวิธีของ IM เองสามารถแบ่งได้เป็น 2 แบบคือ
\begin{itemize}
\item XIM (X Input Method) --- เป็นกลวิธีการป้อนข้อมูลดั้งเดิมที่ใช้ในระบบ X วินโดว์และยังใช้กันในปัจจุบันได้. ไลบรารทูลคิด GUI ทั่วไปรับรู้การป้อนข้อมูลแบบนี้. การใช้งานทำได้โดยการตั้งค่าตัวแปรสภาพแวดล้อม \cmd{XMODIFIERS}.
\item IMmodule --- เป็นกลวิธีการป้อนข้อมูลสมัยใหม่ในเชิงโมดูลใช้กับทูลคิดสมัยใหม่เช่น GTK+. สามารถเลือกใช้งานได้โดยการตั้งค่าตัวแปรสภาพแวดล้อม \cmd{GTK\_IM\_MODULE} หรือตั้งค่าในแอพพลิเคชันเฉพาะราย. การใช้งานภาษาไทยแบบ IMmodule ยังไม่สมบูรณ์.
\end{itemize}



\subsection{X Input Method}
\emph{XIM (X Input Method)}\gindex{x input method@X Input Method}\gindex{xim@XIM|see{X Input Method}} ช่วยการป้อนข้อมูลภาษาไทยให้ถูกต้องโดยกรองข้อมูลที่ได้จากแป้นพิมพ์, ตรวจสอบประเภทของอักขระว่าสามารถเป็นข้อมูลนำเข้าได้หรือไม่ก่อนที่จะส่งข้อมูลให้โปรแกรมต่อไป. ก่อนใช้ XIM กับภาษาไทย, ผู้ใช้ต้องตั้งแค่โลแคลของตัวแปรสภาพแวดล้อม \cmd{LC\_CTYPE} ให้เป็นโลแคลภาษาไทยด้วยเพราะมีการตรวจสอบประเภทของอักขระที่ป้อนข้อมูลเข้าจากแป้นพิมพ์. ตามที่ได้แนะนำไปแล้วว่าค่าของ \cmd{LC\_CTYPE} สามารถตั้งค่าทับด้วยตัวแปรสภาพแวดล้อม \cmd{LANG} หรือ \cmd{LC\_ALL} ก็ได้.

การใช้ XIM ทำได้โดยการตั้งค่าตัวแปรสภาพแวดล้อม \cmd{XMODIFIERS}\gindex{xmodifiers@\cmd{XMODIFIERS}} โดยมีรูปแบบดังต่อไปนี้.
\begin{MyVerbatim}
export XMODIFIERS="@im=\textit{method}"
\end{MyVerbatim}
ผู้ใช้จะระบุ \cmdit{method} ซึ่งเป็นชื่อวิธีการใช้ XIM แบบต่างๆ. สำหรับการใช้ XIM ภาษาไทยมีค่าที่ระบุได้ดังต่อไปนี้.
\begin{itemize}
\item \cmd{Passthrough} --- XIM จะไม่ตรวจสอบอักขระที่ป้อนทางแป้นพิมพ์, จะส่งอักขระที่ได้รับจากแป้นพิมพ์ให้โปรแกรมต่อไป. ผู้ใช้สามารถป้อนข้อมูลที่ไม่เหมาะสมได้เช่นพิมพ์วรรณยุกต์โดยไม่มีพยัญชนะหรือสระที่เหมาะสมนำหน้าเป็นต้น. การตั้งค่าตัวแปร \cmd{XMODIFIERS="@im=none"} ให้ผลเช่นเดียวกับ Passthrough.
\item \cmd{BasicCheck} --- XIM จะตรวจสอบลำดับการป้อนข้อมูลเบื้องต้นว่าเหมาะสมหรือไม่. ตัวอย่างเช่น
\begin{itemize}
\item ปฏิเสธการป้อนข้อมูลที่ไม่เหมาะสม. เช่นไม่สามารถพิมพ์ไม่เอกตามหลังสระอา เป็นต้น.
\item แก้ไขลำดับอักขระถ้าเป็นไปได้. เช่นถ้าพิมพ์ ท -่ -ี ก็จะแปลงลำดับอักขระให้ถูกต้องเป็น ท -ี -่ โดยอัตโนมัติ.
\end{itemize}
\item \cmd{Strict} --- เพิ่มกฏที่ช่วยให้การพิมพ์ภาษาไทยถูกต้องยิ่งขึ้นเช่น XIM แบบ BasicCheck สามารถพิมพ์อักขระที่ไม่มีความหมายเช่น ``ก\char229{}'' แต่ใน XIM แบบ Strict จะสามารถพิมพ์ ``\char229{}'' ตามหลัง ``ฤ'' หรือ ``ฦ'' ได้เท่านั้น.
\end{itemize}

รูปที่ \ref{fig:xim-passthrough} แสดงตัวอย่างโปรแกรม \cmd{gedit} ที่รันด้วยคำสั่ง\\
 \noindent\cmd{LANG=th\_TH} \cmd{XMODIFIERS="@im=Passthrough"} \cmd{gedit}
จะเห็นได้ว่าผู้ใช้สามารถพิมพ์ผิดลำดับได้เช่น ท -่ -ี. ผู้ใช้สามารถสังเกตเห็นสิ่งปรกติได้เพราะไลบรารี Pango ช่วยเติมเครื่องหมาย dotted circle\gindex{dotted circle} บ่งบอกว่าหน้าสระอีต้องการอักขระที่เหมาะสม. ถ้าใช้ XIM แบบ BasicCheck หรือ Strict ตัวโปรแกรมจะแก้ลำดับให้ถูกต้องโดยอัตโนมัติ.

\begin{figure}[!htb]
\plfigure{.5}{xim-passthrough.eps}{โปรแกรม \cmd{gedit} ใช้ XIM แบบ Passthrough.}{xim-passthrough}
\end{figure}

ในสภาพแวดล้อมโลแคลภาษาไทยถ้าไม่มีการตั้งค่า \cmd{XMODIFIERS} จะถือว่าตัวแปรสภาพแวดล้อมนี้ใช้ XIM แบบ BasicCheck โดยปริยาย.

\subsection{IM module}
การป้อมข้อมูลแบบ IM module ใช้ในแอพพลิเคชันที่ใช้ไลบรารี GTK+ เช่นโปรแกรมต่างๆในสภาพแวดล้อมเดสก์ท็อป GNOME. การเลือกโมดูลสามารถทำได้โดยการตั้งค่าตัวแปรสภาพแวดล้อม \cmd{GTK\_IM\_MODULE} หรือเลือกจากแอพพลิเคชันเช่นในรูปที่ \ref{fig:immodule}.

\begin{figure}[!htb]
\plfigure{.4}{immodule.eps}{การเลือก IM module ในโปรแกรม \cmd{gedit}.}{immodule}
\end{figure}

โมดูลการป้อนข้อมูลภาษาไทยยังไม่สมบูรณ์และไม่สามารถใช้ได้. ซึ่งในขณะที่เขียนหนังสือนี้คุณเทพพิทักษ์จาก Thai Linux Working Group พยายามจะแก้ไขประสานงานกับนักพัฒนาของ GNOME อยู่. อย่างไรก็ตาม IM module มีโมดูลสำหรับเชื่อมต่อใช้ XIM ตามปรกติ. ถ้าเลือก X Input Method จากเมนูก็จะเหมือนการใช้ XIM ตามปรกติ.

%\section{การพิมพ์ภาษาไทยออกทางเครื่องพิมพ์}

\section{สรุปท้ายบท}
\begin{itemize}
\item รหัสอักขระที่เป็นมาตรฐานและเกี่ยวข้องกับภาษาไทยได้แก่ TIS-620, ISO8859-11 และ ยูนิโค้ด.
\item การเข้ารหัสอักขระมีหลายวิธี. การเข้ารหัสแบบ TIS-620 เป็นการใช้ค่ารหัสอักขระตรงๆในการเข้ารหัสอักขระ, ทำให้ซ้ำกับการเข้ารหัสอักขระภาษาอื่นๆเช่น ISO8859-1.
\item การเข้ารหัสแบบยูนิโค้ดเช่น UCS-2, UCS-4, UTF-8 ฯลฯ มีข้อดีที่รหัสอักขระของภาษาต่างๆไม่ซ้ำกัน.
\item โลแคลเป็นกลวิธีที่ใช้ปรับแต่งสภาพแวดล้อมการใช้งานโปรแกรมต่างๆให้เป็นภาษาและวัฒนธรรมที่ต้องการ. โลแคลภาษาไทยที่ใช้กันทั่วไปได้แก่ \cmd{th\_TH.TIS-620} และ \cmd{th\_TH.UTF-8}.
\item การติดปรับแต่งค่าโลแคลจะใช้ตัวแปรสภาพแวดล้อมที่ขึ้นต้นด้วย \cmd{LC\_}, \cmd{LC\_ALL} หรือ \cmd{LANG}.
\item Input Method หรือ IM เป็นวิธีที่จัดการข้อมูลอักขระที่ได้รับจากแป้นพิมพ์, ตรวจสอบข้อมูล, ประมวลผลแล้วส่งต่อให้โปรแกรมต่อไป.
\item IM ที่เกี่ยวข้องกับการป้อนข้อมูลภาษาไทยในปัจจุบันคือ XIM (X Input Method) สามารถเรียงลำดับอักขระที่ป้อนเข้ามาจากแป้นพิมพ์ให้ถูกต้อง, หรือปฏิเสธการป้อนข้อมูลที่ไม่เหมาะสม.
\item วิธีการใช้ XIM ทำได้โดยการตั้งค่าตัวแปรสภาพแวดล้อม \cmd{XMODIFIERS}.
\end{itemize}
