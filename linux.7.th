\chapter{ระบบ X วินโดว์}
ยูสเซอร์อินเทอร์เฟสแบบกราฟิกหรือที่เรียกกันว่า GUI (Graphical User Interface) มีบทบาทอย่างยิ่งต่อผู้ใช้คอมพิวเตอร์ในปัจจุบัน. ระบบ GUI อำนวยความสะดวกต่างๆด้วยการแสดงผลนอกเหนือจากอักษรได้แก่รูปภาพสองมิติหรือสามมิติ, แสดงโปรแกรมต่างๆด้วยระบบหน้าต่าง (window) และโต้ตอบกับผู้ใช้โดยใช้อุปกรณ์นอกเหนือจากแป้นพิมพ์ซึ่งได้แก่เมาส์. เมื่อเทียบกับระบบปฏิบัติการยูนิกซ์ในยุคแรก, ระบบปฏิบัติการยูนิกซ์จะใช้แค่แป้นพิมพ์และหน้าจอมีคุณสมบัติแสดงตัวอักษรได้เป็นอินเทอร์เฟสติดต่อกับผู้ใช้ผ่านทางเชลล์. ระบบปฏิบัติการยูนิกซ์รวมถึงลินุกซ์ไม่มีระบบการแสดงผลแบบกราฟิกเป็นอินเทอร์เฟสมาตรฐาน. อินเทอร์เฟสมาตรฐานระหว่างผู้ใช้กับเคอร์เนลคือเชลล์. ระบบ GUI จะเป็นส่วนเพิ่มเติมของระบบในรูปของโปรแกรมซึ่งไม่ได้รวมอยู่ในเคอร์เนล. จุดนี้จะต่างกับระบบปฏิบัติการวินโดวส์ (Microsoft Windows) ซึ่งมีระบบ GUI รวมอยู่ในตัวระบบปฏิบัติการ.

ระบบแสดงผลแบบกราฟิกที่เป็นที่ยอมรับและใช้กับระบบปฏิบัติยูนิกซ์มานานได้แก่ระบบ X วินโดว์ (X Window system).\mymemo{คำว่า Window ไม่มี s ต่อท้าย.} ในบทนี้จะอธิบายเกี่ยวกับระบบ X วินโดว์และนำเสนอการใช้งานแอพพลิเคชัน (application) ต่างๆ.

\section{ประวัติระบบ X วินโดว์}
ระบบ X วินโดว์เริ่มสร้างและพัฒนาที่ Massachusetts Institute of Tecnology (MIT) ในปีค.ศ. 1984 ในโครงการที่เรียกว่า Athena. ระบบ X วินโดว์รับแนวคิดต้นแบบจากระบบหน้าต่างที่ชื่อว่า ``W'' ที่พัฒนาโดยมหาวิทยาลัย Stanford. ดังนั้นชื่อตัวอักษร ``X'' ยังมีความหมายถึงระบบวินโดว์ที่สร้างต่อมาจากระบบวินโดว์ ``W'' ด้วย. โครงการพัฒนาระบบ X วินโดว์นี้ได้รับทุนวิจัยสนับสนุนจากบริษัทเอกชนได้แก่ Digital Wquipment Corporation (DEC) และ IBM.

ในปีค.ศ. 1985 ทางโครงการเปิดตัวระบบ X วินโดว์รุ่นที่ 10 สู่สาธารณะ, และในปีถัดไปทาง DEC ได้นำระบบ X วินโดว์ไปใช้ในเครื่องคอมพิวเตอร์ VAXstation II/GPX เชิงพาณิชย์ \cite{xcookbook}. หลังจากนั้นบริษัทผลิตคอมพิวเตอร์ตระกูลยูนิกซ์ทั้งหลายเช่น Hewlett-Packard, Sun, IBM ได้นำระบบ X วินโดว์ไปใช้กับผลิตภัณฑ์ของตัวเองอย่างแพร่หลาย. ด้วยเหตุนี้เองระบบ X วินโดว์จึงเป็นเสมือนระบบกราฟิกมาตรฐานสำหรับยูนิกซ์ในเวลาต่อมา. ในปีค.ศ. 1987 ระบบ X วินโดว์ออกรุ่น 11 ซึ่งรู้จักกันในชื่อ X11. จากนั้นบริษัทคอมพิวเตอร์ต่างๆเห็นความสำคัญของระบบ X วินโดว์นี้จึงได้ร่วมกันจัดตั้ง X consortium เป็นองค์กรกลางที่ได้รับการสนับสนุนจากบริษัทผู้ผลิตคอมพิวเตอร์ต่างๆร่วมกับ MIT. แต่หลังจากนั้น X consortium แยกตัวออกมาจาก MIT เป็นองค์กรอสิระควบคุมมาตรฐานที่เกี่ยวข้องกับระบบ X วินโดว์. ในขณะเดียวกันมีการออกรุ่นย่อยๆของซอฟต์แวร์ X11\gindex{x11@X11} เรียกว่า release และรู้จักกันในชื่อ X11R2, X11R3 ไปเรื่อยๆ. X11R6 เป็นรุ่นที่เสถียรมากและมีคุณสมบัติต่างๆที่สมบูรณ์และเป็นที่นิยมใช้กัน. ปัจจุบันองค์กรที่ควบคุมมาตรฐานของระบบ X วินโดว์ได้แก่ X.org\gindex{x.org@X.org} foundation ซึ่งเป็นหน่วยงานย่อยของ The Open Group อีกทีหนึ่ง. และรุ่นของระบบ X วินโดว์ล่าสุด\mymemo{ข้อมูลสำรวจเดือนธันวาคม ค.ศ. 2004}ได้แก่ X11R6.8.1 ชื่อเรียกเป็นทางการคือ X Window System Version 11 Release 6.8.1.

\subsection{XFree86}
ซอฟต์แวร์ระบบ X วินโดว์ที่ใช้กันในลินุกซ์ตั้งแต่เริ่มแรกได้แก่ซอฟต์แวร์จากโครงการ XFree86\gindex{xfree86@โครงการ XFree86}. โครงการนี้มีจุดมุ่งหมายสร้างระบบ X วินโดว์ที่สามารถจากจ่ายไปโดยเสรีและเป็นแบบโอเพนซอร์ส. ซอฟต์แวร์ของระบบ X วินโดว์ดังกล่าวพยายามที่จะคลอบคลุมฮาร์ดแวร์และซอฟต์แวร์ต่างๆที่มีอยู่, รวมถึงสถาปัตยกรรมคอมพิวเตอร์ต่างๆที่มีอยู่หลากหลายด้วย. ดังนั้นซอฟต์แวร์ระบบ X วินโดว์สามารถใช้ทั้งบนระบบปฏิบัติการลินุกซ์, ไมโครซอฟต์วินโดวส์ ฯลฯ, รองรับกราฟฟิกการ์ดต่างๆ และใช้ได้กับเครื่องเวิร์กสเตชันของบริษัทคอมพิวเตอร์แบบยูนิกซ์ต่างๆด้วย. ซอฟต์แวร์ระบบ X วินโดว์ที่เผยแพร่โดยโครงการ XFree86 รุ่นล่าสุดได้แก่รุ่น 4.4.0 ออกเมื่อเดือนกุมภาพันธ์ค.ศ. 2004.\mymemo{ข้อมูลสำรวจเดือนธันวาคม ค.ศ. 2004.}

ความนิยมของดิสทริบิวชันทั่วไปเริ่มหันไปใช้ซอฟต์แวร์ระบบ X วินโดว์ที่สร้างโดย X.org เพิ่มขึ้นแทน XFree86 แล้วเนื่องจาก XFree86 ประกาศเปลี่ยนหนังสืออนุญาตการใช้งานต้นปีค.ศ. 2004.

\section{พื้นความรู้ระบบ X วินโดว์}
ระบบ X วินโดว์เป็นระบบประกอบด้วยซอฟต์แวร์ที่ทำงานแบบ\emph{ไคล์เอ็นต์เซิร์ฟเวอร์ (client server)}. เราสามารถแยกการทำงานของระบบได้เป็น 2 ส่วนคือโปรแกรมเซิร์ฟเวอร์และโปรแกรมไคลเอ็นต์.

โปรแกรมเซิร์ฟเวอร์ที่เรียกว่า \emph{X เซิร์ฟเวอร์ (X server)}\gindex{x server@x server} เป็นโปรเซสในระบบทำหน้าที่ต่อไปนี้
\begin{itemize}
\item รอรับคำขอ (request) จากไคลเอ็นต์และปฏิบัติการแสดงผลขั้นพื้นฐานเท่านั้นเช่นวาดเส้นตรง, เขียนอักษรบนหน้าจอ ฯลฯ.
\item สร้างหน้าต่าง, จัดตำแหน่งหน้าต่าง, ลบหน้าต่าง.
\item จัดการ\emph{อีเวนท์ (event)}\myvocab{e}{event}{\emph{อีเวนท์}\gindex{event}\gindex{อีเวนท์}. เหตุการณ์ต่างๆที่เกิดขึ้น. เป็นคำศัพท์ที่ใช้ในระบบ GUI. ตัวอย่างเช่นการคลิ้กเมาส์ทำให้เกิดอีเวนท์ (เหตุการณ์) การคลิ้ก. ตัว X เซิร์ฟเวอร์จะส่งข้อมูลเกี่ยวกับเหตุการณ์นั้นไปให้ไคลเอ็นต์.} ต่างๆจากแป้นพิมพ์และเมาส์และส่งข้อมูลเกี่ยวกับอีเวนท์นั้นให้ไคลเอ็นต์รับรู้.
\end{itemize}

โปรแกรมไคล์เอ็นต์ซึ่งหมายถึงแอพพลิเคชันต่างๆที่แสดงผลแบบ GUI จะเป็นโปรเซสที่ติดต่อกับเซิร์ฟเวอร์ผ่านทางเน็ตเวิร์กหรือยูนิกซ์ซ็อกเก็ตโดยใช้ข้อตกลงที่เรียกว่า\emph{เอ็กซ์โปรโตคอล (X protocol)}\gindex{x protocol@X protocol}. ไคลเอ็นต์จะทำหน้าที่สำคัญๆต่อไปนี้ได้แก่
\begin{itemize}
\item ส่งคำร้องขอให้แสดงหรือวาดรูปทรงต่างๆทางหน้าจอ.
\item รับข้อมูลอีเวนท์ที่เกิดขึ้นจากเซิร์ฟเวอร์และตัดสินใจกระทำการต่างๆ.
\item ทำงานต่างๆเฉพาะโปรแกรม. เช่นถ้าเป็นโปรแกรมเบราว์เซอร์ก็จะติดใช้เน็ตเวิร์กดึงข้อมูลมาแสดงผลเป็นต้น. การใช้งานเน็ตเวิร์กในลักษณะนี้ไม่เป็นการทำงานเฉพาะโปรแกรมไม่เกี่ยวกับ X วินโดว์.
\end{itemize}


เนื่องจากโปรเซสที่จัดการเรื่องกราฟิกแสดงผลรวมถึงการรับอีเวนท์ที่เกิดขึ้นจากอุปกรณ์ต่างๆคือเซิร์ฟเวอร์, ดังนันจึงเป็นข้อดีต่อไคลเอ็นต์ที่ไม่จำเป็นต้องรู้เรื่องเกี่ยวกับฮาร์ดแวร์ที่แสดงผลเลย. สิ่งที่ไคลเอ็นต์ต้องรับรู้คือวิธีที่จะติดต่อกับเซิร์ฟเวอร์. โปรแกรมไคลเอ็นต์ต่างๆจะใช้ไลบรารีพื้นฐานได้แก่ \emph{Xlib (X library)}\gindex{xlib@Xlib}. ตัวอย่างไฟล์ไลบรารีเช่น \cmd{/usr/X11R6/lib/libX11.a}. โปรแกรมแบบ GUI จะใช้ไลบรารีนี้เสมอ. และเนื่องจากการติดต่อระหว่างไคลเอ็นต์และเซิร์ฟเวอร์อาศัยเน็ตเวิร์กทำให้สามารถแสดงผลข้ามเครื่องผ่านทางเน็ตเวิร์กได้. เช่นรันแอพพริเคชันที่เครื่อง ก. แต่สั่งให้แสดงผลบนหน้าจอของคอมพิวเตอร์เครื่อง ข. ผ่านทางเน็ตเวิร์กได้ถ้าอนุญาตให้แสดงผล.

\subsection{ทูลล์คิทและไลบรารี}
การเขียนโปรแกรมภาษาซีแบบ GUI จะฟังก์ชันที่เตรียมไว้สำหรับไลบรารี X โดยตรงก็ได้แต่ไม่สะดวกนักเพราะฟังก์ชันเหล่านี้อำนวยความสะดวกขั้นพื้นฐานเท่านั้นเช่นความสามารถการวาดเส้นตรง, วงกลม, เขียนอักษร ฯลฯ. ดังนั้นจึงมีการสร้าง\emph{ทูลล์คิต (toolkit)} ซึ่งเป็นไลบรารีอำนวยความสะดวกสำหรับเขียนโปรแกรมแบบ GUI ขั้นหนึ่ง. ไลบรารีทูลล์คิตช่วงแรกได้แก่ \emph{Xt (X Toolkit Intrinsics)} เป็นไลบรารีช่วยให้สร้างโปรแกรม GUI ใน\emph{เชิงอ็อบเจ็ค (object oriented)} ในภาษาซีได้ง่ายขึ้น. ทำให้การจัดการส่วนประกอบของ GUI ที่เรียกว่า\emph{วิดเจ็ต (widget)}\gindex{widget}\gindex{วิดเจ็ต} สะดวกขึ้น. ลำพังไลบรารี Xt อย่างเดียวยังไม่มีประโยชน์ในการสร้างโปรแกรมแบบ GUI. นอกจากนี้ยังต้องอาศัยไลบรารีที่เตรียมส่วนประกอบของ GUI เช่นปุ่มกด, ช่องเติมข้อความ เป็นต้น.

\begin{figure}[!htb]
\ifthenelse{\isodd{\pageref{fig:tookit}}}%
{\parbox{\headwidth}{\center\scalebox{.5}{\includegraphics{xcalc.eps}~~~~\includegraphics{kcalc.eps}}\caption{ทูลล์คิตแบบ Athena และ Motif}\label{fig:toolkit}}}%
{\leftskip=\moveback\parbox{\headwidth}{\center\scalebox{.5}{\includegraphics{xcalc.eps}~~~~\includegraphics{kcalc.eps}}\caption{ทูลล์คิตแบบ Athena และ Motif}\label{fig:toolkit}}}
\end{figure}

ทูลล์คิตที่ใช้กันในช่วงแรกๆได้แก่ทูลล์คิต Athena\gindex{athena@Athena} และ Motif\gindex{motif@Motif}. ทูลล์คิต Athena หรือที่เรียกว่า \emph{Xaw (X Athena Widget)}\gindex{xaw@Xaw} เป็นวิดเจ็ตแสดงผลเรียบๆธรรมดาเมื่อเทียบกับวิดเจ็ตของ Motif ซึ่งจะมีเงานูนเว้าทำให้ดูสวยน่าใช้กว่า. ปัจจุบันวิดเจ็ด Xaw ยังคงใช้อยู่กับแอพพลิเคชัน X ดั้งเดิมเช่น \cmd{xcalc}\cindex{xcalc}\mymemo{\cmd{xcalc} โปรแกรมเครื่องคิดเลข.}, \cmd{xlogo} เป็นต้น. ส่วนวิดเจ็ตแบบ Motif นั้นเดิมทีเป็นไลบรารีเชิงพาณิชย์. ในลินุกซ์จะใช้ไลบรารี Open Motif\gindex{motif@Motif!Open Motif} หรือ LessTif\gindex{motif@Motif!LeffTif} ซึ่งเป็นทูลล์คิต Motif แบบโอเพนซอร์ส.

โปรแกรมที่ใช้ไลบรารี Xt จะมีตัวเลือกร่วมที่เหมือนกันเช่น \cmd{-display}, \cmd{-geometry} ฯลฯ ตัวเลือกเหล่านี้ถือเป็นทรัพยากร (resource) อย่างหนึ่งในระบบ X วินโดว์. ค่าต่างๆเหล่านี้สามารถเขียนไว้ในไฟล์เริ่มต้นหรือระบุผ่านทางตัวเลือกก็ได้.

ปัจจุบันทูลล์คิตที่นิยมใช้และมีบทบาทอย่างมากได้แก่ Gtk+ (The Gimp Toolkit) และ Qt. ทูลล์คิตสมัยใหม่เหล่านี้ใช้เขียนโปรแกรมแบบ GUI ง่ายกว่าทูลล์คิตสมัยแรกมากและยังใช้ในการสร้าง\emph{สภาพแวดล้อมเดสก์ท็อป (desktop environment)} ที่นิยมใช้กันได้แก่ Gnome และ KDE ด้วย. โปรแกรมที่ใช้ทูลล์คิตสมัยใหม่เหล่านี้จะไม่ใช้ไลบรารี Xt, จะมีชุดตัวเลือกร่วมของทูลล์คิตตัวเองเช่น \cmd{--display=\textit{name}}, \cmd{--screen=\textit{number}} ฯลฯ. ตัวเลือกเหล่านี้จะแตกต่างกันไปตามแต่ละทูลล์คิต. ดังนั้นเวลาใช้ตัวเลือกควรจะระวังด้วยว่าโปรแกรมที่ต้องการใช้ใช้ทูลล์คิตอะไร. ในความเป็นจริงแล้วไม่ต้องกังวลเกี่ยวกับตัวเลือกมากเพราะค่าต่างๆมักปรับได้โดยใช้เมนูของโปรแกรมนั้นๆ.

\begin{table}[!htb]
\center
\caption{ไลบรารีทูลล์คิตสำคัญต่างๆและโปรแกรมที่ใช้ไลบรารีนั้นๆ.}
\begin{tabular}{p{.3\textwidth}p{.3\textwidth}p{.3\textwidth}}
\toprule
\multicolumn{1}{c}{ไลบรารี Xt} &\multicolumn{1}{c}{ไลบรารี Gtk+} &\multicolumn{1}{c}{ไลบรารี Qt}\\
\midrule
\raggedright \cmd{xterm}, \cmd{emacs}, \cmd{xdvi}, \cmd{xlogo}, \cmd{xman}, \cmd{xdpyinfo}, \cmd{xclock}, \cmd{bitmap}, \cmd{xfd}, \cmd{xfontsel}, \cmd{xcalc}, \cmd{xmag} ฯลฯ & \raggedright \cmd{gnome-terminal}, \cmd{gimp}, \cmd{inkscape}, \cmd{ggv}, \cmd{firefox}, \cmd{mozilla}, \cmd{gedit}, \cmd{abiword}, \cmd{gthumb}, \cmd{evolution} ฯลฯ &  \cmd{konsole}, \cmd{konqueror},\wbr  \cmd{kedit}, \cmd{kcalc},\wbr  \cmd{kword}, \cmd{kmail},\wbr  \cmd{kdevelop}, \cmd{kopete},\wbr  \cmd{kppp} ฯลฯ\\
\bottomrule
\end{tabular}
\end{table}


\subsection{หน้าจอและสกรีน}
คำว่า\emph{หน้าจอ (display)} และ\emph{สกรีน (screen)} ในระบบ X วินโดว์มีความหมายต่างกัน. เซิร์ฟเวอร์หนึ่งโปรเซสจะมีหน้าจอเป็นคู่อยู่ด้วยเสมอ.  หน้าจอจะมีความหมายถึงเซิร์ฟเวอร์เช่นการที่ไคลเอ็นต์ติดต่อกับเซิร์ฟเวอร์คือไคลเอ็นต์ติดต่อกับหน้าจอที่ใช้แสดงผล. ส่วนสกรีนจะหมายถึงฮาร์ดแวร์ดีไวซ์ที่ใช้แสดงผล. หน้าจอหนึ่งอาจมีได้หลายสกรีน. ชื่อของหน้าจอมีรูปแบบดังนี้
\begin{MyVerbatim}
[\textit{hostname}]:\textit{display}[.\textit{screen}]
\end{MyVerbatim}
\begin{itemize}
\item hostname คือชื่อโฮสเช่น localhost, mycomputer.net เป็นต้น. ถ้าละเว้นจะถือว่าเป็น localhost.
\item display คือตัวเลขกำกับหน้าจอ. ตัวเลขนี้มีค่ามากกว่าหรือเท่ากับ 0. โดยปรกติเซิร์ฟเวอร์ตัวแรกจะมีหมายเลขหน้าจอเป็น 0. ถ้ามี X เซิร์ฟเวอร์รันอยู่อีกโปรเซสต้องใช้หมายเลขหน้าจออื่นที่ไม่ซ้ำกัน.
\item screen คือตัวเลขสกรีนสามารถละเว้นไม่ระบุได้. ปรกติแล้วจะมีค่าเป็น 0.
\end{itemize}
ชื่อของหน้าจอนี้จะเก็บไว้ในตัวแปรสภาพแวดล้อมชื่อ \cmd{DISPLAY}. โดยปรกติแล้วระบบจะตั้งชื่อหน้าจอให้โดยอัตโนมัติ.
\begin{MyExample}[ชื่อหน้าจอ.]
\begin{MyEx}
$ \cin{printenv DISPLAY} \mycomment{แสดงค่าตัวแปรสภาพแวดล้อม \cmd{DISPLAY}}
:0.0
$ \cin{xlogo &}  \mycomment{รันโปรแกรม \cmd{xlogo}}
$ \cin{unset DISPLAY}
$ \cin{xlogo}
Error: Can't open display \mycomment{ไม่สามารถติดต่อกับ X เซิร์ฟเวอร์ได้}
\end{MyEx}
\end{MyExample}
ในตัวอย่างชื่อหน้าจอคือ \cmd{:0.0}. ถ้าไม่กำหนดตัวแปรสภาพแวดล้อมนี้ตอนรัน X ไคลเอ็นต์เช่นโปรแกรม \cmd{xlogo} ก็จะเกิดข้อผิดพลาดไม่สามารถติดต่อกับหน้าจอ (เซิร์ฟเวอร์) ได้.

นอกจากการระบุหน้าจอของ X เซิร์ฟเวอร์ด้วยตัวแปรสภาพแวดล้อมแล้วเรายังสามารถระบุหน้าผ่านทางตัวเลือกของโปรแกรมที่ใช้ไลบรารี Xt ได้ด้วย. ตัวเลือกนี้ได้แก่ \cmd{-display \textit{displayname}}.

การระบุเซิร์ฟเวอร์ด้วยชื่อหน้าจอมีประโยชน์เวลารันโปรแกรมจากเครื่องคอมพิวเตอร์เครื่องหนึ่งแต่ต้องการแสดงผลบน X เซิร์ฟเวอร์ที่เครื่องอื่น. ตัวอย่างเช่นในรูปที่ \ref{fig:xdisplay} เป็นการใช้เทอร์มินัลเอมิวเลเตอร์ล็อกอินผ่านทางเน็ติเวิร์กจากเครื่อง host1 ไปที่เครื่อง host2 ด้วยคำสั่ง \cmd{telnet}. หลังจากที่ล็อกอินเรียบร้อยแล้วตั้งค่าตัวแปรสภาพแวดล้อม \cmd{DISPLAY} ให้เป็นหน้าจอของเครื่อง host1. เวลารันโปรแกรม GUI ก็จะแสดงผลบนหน้าจอ host1.

\begin{figure}[!htb]
\plfigure{.5}{xdisplay.eps}{การแสดงหน้าต่างแอพพลิเคชันผ่านทางเน็ตเวิร์ก.}{xdisplay}
\end{figure}

จากรูป \ref{xdisplay} ไคล์เอ็นต์ได้แก่โปรแกรม \cmd{xlogo} รันในเครื่อง host2. ส่วนเซิร์ฟเวอร์ได้แก่ X เซิร์ฟเวอร์ที่รันอยู่ในเครื่อง host1. การติดต่อระหว่างไคลเอ็นต์และเซิร์ฟเวอร์ใช้โปรโตคอล X และอาศัยเน็ตเวิร์กเป็นตัวกลาง, ดังนั้นถ้ามีการติดตั้งไฟร์วอลล์ระหว่างเครื่องทั้งสองก็จะไม่สามารถแสดงหน้าต่างข้ามเครื่องได้.

ถึงแม้ว่าจะไม่มีไฟร์วอลล์ระหว่างเครื่องทั้งสอง. ในบางกรณีอาจจะไม่สามารถแสดงหน้าต่างข้ามเครื่องได้เพราะ X เซิร์ฟเวอร์ไม่อนุญาตให้แสดงผล. วิธีแก้ไขคือเปิดเทอร์มินอลในเครื่อง host1 แล้วสั่งคำสั่ง \cmd{xhost}\cindex{xhost}\refcmd{xhost} ซึ่งเป็นโปรแกรมควบคุมการเข้าถึงเซิร์ฟเวอร์ของเครื่องที่ใช้.

\begin{MyExample}[ควบคุมการเข้าถึง X เซิร์ฟเวอร์.]
\begin{MyEx}
$ \cin{xhost +} \mycomment{สั่งคำสั่งที่เครื่อง host1}
access control disabled, clients can connect from any host
\end{MyEx}
\end{MyExample}%$
เครื่องหมาย \cmd{+} หมายถึงอนุญาตให้เครื่องคอมพิวเตอร์ใดๆก็ได้เข้าถึง X เซิร์ฟเวอร์ที่เครื่องตัวเอง (host1). ถ้าต้องการอนุญาตเฉพาะเครื่องก็ให้ระบุชื่อโฮสหรือ IP แอดเดรสตามหลังเครื่องหมาย \cmd{+}. ถ้าไม่อนุญาตการแสดงหน้าต่างจากเครื่องอื่นๆให้ใช้เครื่องหมาย \cmd{-}.


ถ้าเป็นการล็อกอินผ่าน \cmd{ssh}\mymemo{\cmd{ssh} ได้แก่การล็อกอินโดยโดยใช้โปรโตคอล secure shell ข้อมูลสื่อสารระหว่างเครื่องจะเข้ารหัสปลอดภัยกว่า \cmd{telnet}.} จะมีคุณสมบัติ X forwarding ให้. ถ้าเซิร์ฟเวอร์และไคล์เอ็นต์ของ \cmd{ssh} อนุญาตให้ใช้คุณสมบัตินี้ก็จะสามารถส่งผ่านหน้าต่างได้ผ่านโปรโตคอล ssh ไม่ผ่านโปรโตคอล X เหมือนในกรณี \cmd{telnet}. ถ้าใช้คุณสมบัติ X forwarding, โปรแกรม \cmd{ssh} จะจัดการค่าแปรสภาพแวดล้อม \cmd{DISPLAY} ให้โดยอัตโนมัติ. สำหรับระบบที่มีไฟร์วอลล์แต่อนุญาตให้ใช้ \cmd{ssh} วิธีนี้จะสะดวกที่สุด.



\subsection{ระบบหน้าต่าง}
โดยปรกติ, โปรแกรมแบบ GUI ที่เรียกใช้จะแสดงผลบนหน้าจอเป็นหน้าต่าง (วินโดว์). จะมีบางกรณีเท่านั้นที่ไม่แสดงผลเป็นหน้าต่างเช่น \cmd{xhost} จัดเป็นโปรแกรมในระบบ X วินโดว์, มีการติดต่อกับ X เซิร์ฟเวอร์แต่ไม่มีการแสดงผลเป็นหน้าต่าง.

เมื่อ X เซิฟร์เวอร์ทำงาน, ในหน้าจอจะมีหน้าต่างพิเศษปรากฏอยู่เสมอเรียกว่า\emph{รูทวินโดว์ (root window)}. รูทวินโดว์จะมีขนาดเท่าสกรีนที่ใช้. เมื่อมีการสร้างหน้าต่างสำหรับโปรแกรมจะเกิดความสัมพันธ์หน้าต่างขึ้น. เช่นในรูปที่ \ref{fig:window_tree} วินโดว์ A และ B เป็นลูกของรูทวินโดว์. ในวินโดว์ B มีหน้าต่างย่อยลงไปอีก, ก็จะได้ความสัมพันธ์ว่าวินโดว์ B1 เป็นลูกของวินโดว์ B อีกทอดหนึ่ง. ระบบ X วินโดว์จะจัดการหน้าต่างในลักษณะนี้.

\begin{figure}[!htb]
\plfigure{.35}{window_tree.eps}{ความสัมพันธ์ระหว่างวินโดว์ต่างๆ.}{window_tree}
\end{figure}

วินโดว์ที่แสดงในหน้าจอไม่จำเป็นต้องมองเห็นได้ตลอดเวลา. ในบางกรณีไคลเอ็นต์สามารถขอให้เซิร์ฟเวอร์ซ่อนหน้าต่างที่ต้องการและแสดงเมื่อขอร้องเซิร์ฟเวอร์ให้แสดงผล. หรือบางกรณีหน้าต่างอาจจะถูกทับด้วยหน้าต่างอื่นๆ, เซิร์ฟเวอร์จะจัดการการแสดง/ไม่แสดงหน้าต่างโดยอัตโนมัติ. ถ้าหน้าต่างที่ทับหายไป, เซิร์ฟเวอร์ก็จะจัดการวาดหน้าต่างที่ถูกทับให้ปรากฏอีกที.

\subsection{ตำแหน่งหน้าต่าง}
สิ่งที่แสดงบน X วินโดว์จะเป็นกราฟิกแบบ\emph{บิตแมป (bitmap)} คือเป็น\emph{จุดพิกเซล (pixel)}. ความสามารถในการแสดงผลนี้ขึ้นอยู่กับอุปกรณ์เช่นหน้าจอ, กราฟิกการ์ดที่ใช้. ขนาดของหน้าจอมีหน่วยเป็นพิกเซลและระบบพิกัดที่ใช้อ้างอิงตำแหน่งจะมีจุดเริ่มต้นอยู่ที่มุมซ้ายบนของหน้าจอ. แกน x จะเริ่มจากซ้ายไปขวา, และแกน y จะเริ่มจากบนไปล่างตามรูปที่ \ref{fig:geometry}.

\begin{figure}[!htb]
\plfigure{.4}{geometry.eps}{ตำแหน่งพิกัดในระบบ X วินโดว์.}{geometry}
\end{figure}

สำหรับโปรแกรมที่ใช้ไลบรารี Xt สามารถระบุตำแหน่งของหน้าต่างได้ด้วยตัวเลือก \cmd{-geometry} มีรูปแบบดังนี้
\begin{MyVerbatim}
\textit{program} -geometry \textit{width}x\textit{height}+\textit{xoff}+\textit{yoff}
\end{MyVerbatim}
\begin{itemize}
\item width คือความกว้างของหน้าต่างโปรแกรมที่เรียกใช้.
\item height คือความสูงของหน้าต่างโปรแกรมที่เรียกใช้.
\item xoff คือตำแหน่งจากมุมซ้ายบนของรูทวินโดว์ตามแนวแกน x.
\item yoff คือตำแหน่งจากมุมซ้ายบนของรูทวินโดว์ตามแนวแกน y.
\end{itemize}
ค่าตำแหน่งและขนาดนี้สามารถละเว้นบางส่วนได้เช่นระบุขนาดอย่างเดียวแต่ไม่ระบุตำแหน่งเป็นต้น. ตำแหน่งของหน้าต่างโดยปรกติจะอ้างอิงจากมุมซ้ายบนของรูทวินโดว์. ในกรณีที่ต้องการอ้างอิงจากมุมขวาบนหรือมุมขวาล่างของรูทวินโดว์ตามแนวแกน x เปลี่ยนเครื่องหมาย + เป็น -. ในทำนองเดียวกันถ้าต้องการอ้างอิงจากมุมซ้ายล่างหรือมุมขวาล่างของรูทวินโดว์ตามแนวแกน y ให้เปลี่ยนเครื่องหมาย + เป็น -. นอกจากนี้ในระบบ X วินโดว์รับรู้พิกัดพิเศษดังต่อไปนี้ด้วย
\begin{itemize}
\item -0+0 หมายถึงตำแหน่งมุมขวาบนของรูทวินโดว์.
\item +0-0 หมายถึงตำแหน่งมุมซ้ายล่างของรูทวินโดว์.
\item -0-0 หมายถึงตำแหน่งมุมขวาล่างของรูทวินโดว์.
\end{itemize}


ตัวอย่างต่อไปนี้เป็นการแสดง \cmd{xclock}\cindex{xclock}\refcmd{xclock} และ \cmd{oclock}\cindex{oclock}\refcmd{oclock}\mymemo{\cmd{xclock} ใช้แสดงนาฬิกาทรงเหลี่ยม. \cmd{oclock} ใช้แสดงนาฬิกาทรงกลม.} โดยใช้ตัวเลือก \cmd{-geometry} ระบุขนาดและตำแหน่งต่างๆ.
\begin{MyExample}[ใช้ตัวเลือก \cmd{-geometry} ระบุขนาดและตำแหน่ง.]
\begin{MyEx}
$ \cin{xclock -geometry 200x200+100+100 &}
$ \cin{oclock -geometry -100+100 &} \mycomment{ไม่ระบุขนาดหน้าต่าง}
$ \cin{xclock -geometry 100x100-0-0 &} \mycomment{อ้างอิงตำแหน่งมุมขวาล่าง}
$ \cin{oclock -geometry 100x50 &} \mycomment{ไม่ระบุตำแหน่ง}
\end{MyEx}
\end{MyExample}

\begin{figure}[!htb]
\plfigure{.35}{xclock.eps}{ตัวอย่าง \cmd{xclock} และ \cmd{oclock} ในตำแหน่งและขนาดต่างๆ.}{xclock}
\end{figure}

\subsection{ตัวเลือกร่วมของไลบรารี Xt}
โปรแกรม GUI ที่ใช้ทูลล์คิตของ Athena และ Motif จะมีตัวเลือกร่วมที่เหมือนกันเพราะใช้ไลบรารีเหมือนกันคือ Xt. ตัวเลือกที่สำคัญๆของทูลล์คิตได้แก่
\begin{itemize}
\item \cmd{-display [\textit{host}]:\textit{display}[.\textit{screen}]}\\
ระบุหน้าจอ (เซิร์ฟเวอร์) ที่ต้องการแสดงผล.
\item \cmd{-geometry \textit{geometry}}\\
ระบุตำแหน่งและขนาดของหน้าต่างโปรแกรม.
\item \cmd{-fg \textit{color}} หรือ \cmd{--foreground \textit{color}}\\
ระบุสีของฉากหน้าเช่นส่วนที่เป็นรูปทรงหลักของโปรแกรมหรือตัวอักษร (หน้า \pageref{sec:xcolor}).
\item \cmd{-bg \textit{color}} หรือ \cmd{--background \textit{color}}\\
ระบุสีของฉากหลัง (พื้นหลัง) ของโปรแกรม.
\item \cmd{-fn \textit{font}} หรือ \cmd{-font \textit{font}}\\
ระบุชื่อฟอนต์ที่ต้องการใช้ (หน้า \pageref{sec:xfont}).
\item \cmd{-title \textit{title}}\\
ชื่อหน้าต่างส่งต่อให้วินโดว์แมนเนเจอร์แสดงเป็นชื่อของหน้าต่าง.
\item \cmd{-name \textit{instance-name}}\\
ระบุชื่อของโปรแกรมที่รัน. ถ้ามีการกำหนดทรัพยากรที่สอดคล้องกับชื่อนั้นก็จะใช้ค่าทรัพยากรตามที่ระบุซึ่งอาจจะแตกต่างจากการไม่ระบุชื่อได้. (หน้า \pageref{sec:xresource}).
\item \cmd{-iconic}\\
เริ่มต้นการทำงานโดยย่อให้เป็น\emph{ไอคอน (icon)}.
\item \cmd{-xrm \textit{resource}}\\
ระบุชื่อและค่าทรัพยากรที่ต้องการใช้ใ (หน้า \pageref{sec:xresource}).
\end{itemize}


\subsection{เมาส์ในระบบ X วินโดว์}
\begin{figure}[!htb]
\plfigure{.4}{mouse.eps}{เมาส์ทั่วไปที่ใช้ในระบบ X วินโดว์.}{mouse}
\end{figure}
เมาส์ที่ใช้ยูนิกซ์เวิร์กสเตชันเดิมทีมีสามปุ่มคล้ายกับเมาส์ของเครื่องคอมพิวเตอร์ส่วนบุคคลในปัจจุบันซึ่งมักจะมีสามปุ่มและปุ่มตรงการเป็นลูกล้อ (wheel) เลื่อนขึ้นลงได้. การใช้เมาส์ในระบบ X วินโดว์เหมือนกับระบบ GUI อื่นๆคือปุ่มหลักที่ใช้ได้แก่ปุ่มซ้ายซึ่งแสดงด้วยหมายเลข 1 จากรูป \ref{fig:mouse}. ปุ่มที่ 1 ใช้เลือกหน้าต่าง, กดลากและปล่อย (drag and drop) ฯลฯ. ถ้ามีการใช้เมาส์เลือกข้อความในโปรแกรม, สายอักขระที่เลือกจะถูกก็อปปี้ไว้ทันที. ถ้ากดปุ่มที่ 2 (ปุ่มกลาง) ก็จะแปะสายอักษรที่เลือกไว้ลงในหน้าต่างที่ต้องการ. วิธีการตัดแปะสายอักขระแบบนี้เป็นคุณสมบัติของ X วินโดว์ซึ่งแตกต่างจากระบบปฏิบัติการวินโดว์ที่ต้องเลือกสายอักษรที่ต้องการคัดลอกก่อน, คัดลอด (copy) ด้วยคีย์ \cmd{Ctrl+c} หรือจากเมนู, และทำการแปะ (paste) ด้วยคีย์ \cmd{Ctrl+v} หรือจากเมนู. ในสภาพแวดล้อมเดสก์ท็อปเช่น GNOME หรือ KDE ใช้ได้ทั้งการตัดแปะสายอักขระแบบ X วินโดว์และแบบระบบปฏิบัติการอื่นๆ.


การกระทำของปุ่มเมาส์ที่ 3 แล้วแต่แอพพลิเคชันที่ใช้. ในสภาพแวดล้อมเดสก์ท็อปอาจจะแสดงเมนูเมื่อกดปุ่มนี้. ส่วนลูกกลิ้งซึ่งจะถือว่าเป็นปุ่มที่ 4 และ 5 สามารถใช้เลื่อนเนื้อหาที่แสดงในหน้าต่างขึ้นลงได้แล้วแต่โปรแกรม. เมาส์รุ่นเก่าที่มีสองปุ่มสามารถจำลองการกดเมาส์ปุ่มที่สองได้ด้วยการกดเมาส์ปุ่มที่ 1 และ 3 พร้อมๆกัน.

สำหรับโปรแกรมที่ใช้ทูลล์คิต Athena และมี\emph{สกรอลล์บาร์ (scroll bar)} สำหรับเลื่อนหน้าต่างแนวตั้งแนวนอน, วิธีการใช้เมาส์จะไม่เหมือนกับอินเทอร์เฟสสมัยใหม่ที่ใช้ทูลลคิต Gtk+ หรือ Qt ที่สามารถใช้เมาส์ปุ่มที่ 1 จับสกรอลล์บาร์แล้วลากบังคับ. ถ้าต้องการเลื่อนหน้าต่างแสดงผลลงหรือเลื่อนไปทางขวาโดยสกรอลล์บาร์ของทูลล์คิต Athena, ให้คลิ้กเมาส์ปุ่มที่ 1. ในทางกลับกันถ้าต้องการเลื่อนขึ้นหรือเลื่อนไปทางซ้าย, ให้คลิ้กเมาส์ปุ่มที่ 3. เมาส์ปุ่มที่ 2 ใช้จับสกรอลล์บาร์แล้วลากบังคับได้.

\begin{figure}[!htb]
\plfigure{.4}{xman.eps}{การใช้เมาส์ควบคุมสกรอลล์บาร์ของโปรแกรมที่ใช้ทูลล์คิต Athena.}{xman}
\end{figure}





\subsection{สีในระบบ X วินโดว์}\label{sec:xcolor}
การระบุสีในระบบ X วินโดว์ใช้หลักการผสมสีของแสงจากแม่สีสีแดง (Red), สีเขียว (Green) และสีน้ำเงิน (Blue). วิธีแสดงชื่สีเช่นสำหรับให้เป็นอาร์กิวเมนต์ของตัวเลือก \cmd{-fg} หรือ \cmd{-bg} มี 2 วิธีได้แก่
\begin{itemize}
\item \textbf{เลขฐานสิบหก}\\
แสดงเป็นเลขฐานสิบหกในรูปของ \cmd{\#\textit{RRGGBB}} โดยที่ \cmdit{RR}, \cmdit{GG} และ \cmdit{BB} คือตัวเลขฐานสิบหกมีค่าตั้งแต่ 00 ถึง FF. ตัวอย่างเช่น \cmd{\#FF0000} แทนสีแดง, \cmd{\#191970} แทนสีที่มีชื่อว่า Midnight Blue เป็นต้น. ในกรณีจะสมมติว่าความละเอียดของแม่สีแต่ละสีเป็น 8 บิต.
\item \textbf{ชื่อสี}\\
ในระบบ X วินโดว์มีการกำหนดชื่อสีไว้ในไฟล์ \cmd{/usr/X11R6/lib/X11/rgb.txt}. ข้อมูลในไฟล์เป็นข้อมูลเท็กซ์แสดงชื่อสีบรรทัดต่อบรรทัด. ในหนึ่งบรรทัดประกอบด้วยตัวเลขฐานสิบ 3 ตัวแทนค่าของสีแดง, สีเขียว, และสีน้ำเงินตามลำดับ. ตามด้วยชื่อของสีเป็นภาษาอังกฤษ. ในระบบ X วินโดว์จะมีคำสั่งมาตรฐานชื่อ \cmd{showrgb}\cindex{showrgb} แสดงเนื้อหาของไฟล์นี้โดยที่ไม่ต้องรู้ว่าไฟล์นี้อยู่ที่ไหน. นอกจากคำสั่งมาตรฐาน
\begin{MyExample}[ไฟล์ \cmd{/usr/X11R6/lib/X11/rgb.txt}.]
\begin{MyEx}
$ \cin{cat /usr/X11R6/lib/X11/rgb.txt}
! $Xorg: rgb.txt,v 1.3 2000/08/17 19:54:00 cpqbld Exp $
255 250 250             snow
248 248 255             ghost white
248 248 255             GhostWhite
245 245 245             white smoke
245 245 245             WhiteSmoke
\abb
\end{MyEx}
\end{MyExample}%$
ชื่อของสีบางสีในไฟล์อาจจะมีช่องไฟระหว่างชื่อ. เวลาระบุชื่อสีในบรรทัดคำสั่งจะใช้แบบไหนก็ได้. ถ้าเป็นชื่อสีที่มีช่องไฟระหว่างกลางต้องเขียนในเครื่องหมายคำพูด. ชื่อที่ระบุจะใช้ตัวอักษรตัวเล็กหรือตัวใหญ่ก็ได้. ถ้าระบุชื่อสีโดยใช้เลขฐานสิบหกก็ต้องใช้เครื่องหมายคำพูดคล่อมเช่นกันเพราะมีการใช้เครื่องหมาย \cmd{\#}.\mymemo{\cmd{xeyes} เป็นโปรแกรมมาตรฐานแสดงลูกตามองตามตำแหน่งของเมาส์ในหน้าจอ.}
\begin{MyExample}[การระบุชื่อสีในบรรทัดคำสั่ง.]
\begin{MyEx}
$ \cin{xeyes  xeyes -bg "ghost white" -fg "#b0e0e6"}
\end{MyEx}
\end{MyExample}%$
\item \textbf{ชื่อสีในรูปทั่วไป}\\
วิธีสองแบบที่ผ่านมาเป็นวิธีดั้งเดิมที่ใช้ในการระบุสีในระบบ X วินโดว์. ปัจจุบันมีวิธีระบุสีในรูปแบบต่อไปนี้
\begin{MyVerbatim}
<\textit{color space name}>:<\textit{value}>/.../<\textit{value}>
\end{MyVerbatim}

\cmd{<\textit{color space name}>} คือชื่อของ color space ทำให้สามารถระบุสีได้หลายวิธี. การระบุสีโดยใช้แมสีแดง, เขียว, และน้ำเงินเป็นวิธีหนึ่งในหลายๆวิธี. ถ้าจะเขียนในรูปแบบนี้จะเป็น
\begin{MyVerbatim}
rgb:<\textit{red_value}>/<\textit{gree_value}>/<\textit{gree_value}>
\end{MyVerbatim}
ค่าของแม่สีต่างๆเขียนอยู่ในรูปของเลขฐานสิบหก 1 หลัก (4 บิต), 2 หลัก (8 บิต), 3 หลัก (12 บิต), และ 4 หลัก (16 บิต) แล้วแต่ความละเอียด. color space นอกเหนือจาก rgb แล้วได้แก่ rgbi, CIEXYZ\mymemo{CIE ย่อมาจาก Commission Internationale de l'\'Eclairage เป็นองค์กรรับผิดชอบเกี่ยวกับมาตรฐานเรื่องสีและแสง. หารายละเอียดเพิ่มเติมได้จากเรื่องเกี่ยวกับทฤษฎีสี.}, CIEuvY, CIExyY, CIELab, CIELuv และ TekHVC.
\end{itemize}


\subsection{ฟอนต์}
\emph{ฟอนต์ (font)} หรือภาษาไทยเรียกว่าแบบอักษร\mymemo{ในหนังสือเล่มนี้ขอใช้คำสั่งว่าฟอนต์แทนคำว่าแบบอักษร.}คือกลุ่มของรูปทรงตัวอักษร, อักขระต่างๆรวมไว้ในไฟล์. ไฟล์ฟอนต์ที่อยู่ใน\emph{ตระกูล (family)} เดียวกันจะมีรูปร่างคล้ายเหมือนกัน, จะแตกต่างกันที่รูปทรงเช่นทรงตั้งตรง, ทรงหนา, ทรงเอียง เป็นต้น. ฟอนต์ที่ใช้ได้กับ X เซิร์ฟเวอร์แบ่งกว้างๆได้เป็น 2 แบบคือ\emph{ฟอนต์บิตแมป (bitmap)} และ\emph{ฟอนต์เวกเตอร์ (vector)}\gindex{ฟอนต์!เวกเตอร์}. ฟอนต์เวกเตอร์ที่ใช้ใน X วินโดว์ได้แก่\emph{ฟอนต์เอาท์ไลน์ (outline font)}เช่น\emph{ฟอนต์ทรูไทป์ (truetype)} หรือ\emph{ฟอนต์ไทป์ 1 (Type 1)} เป็นต้น.

\begin{figure}[!htb]
\plfigure{.3}{font_type.eps}{ฟอนต์ประเภทต่างๆ.}{font_type}
\end{figure}


\subsubsection{ฟอนต์บิตแมป}\gindex{ฟอนต์!บิตแมป}
ฟอนต์บิตแมปเป็นฟอนต์ดั้งเดิมที่ใช้ที่ในระบบ X วินโดว์. การแสดงอักขระแต่ละตัวจะใช้จุดในการแสดงผล. ดังนั้นฟอนต์แต่ละฟอนต์จะมีขนาดตายตัว. ในกรณีที่ต้องแสดงตัวอักษรหลายขนาดต้องเตรียมไฟล์ฟอนต์ของแต่ละขนาด. หรือจะใช้การย่อขยายฟอนต์ที่มีอยู่ก็ได้แต่จะไม่สวยงามเพราะการแสดงอักขระกำหนดโดยจุดตายตัว. ฟอนต์แบบบิตแมปมีข้อดีที่ว่าไฟล์ฟอนต์แต่ละไฟล์สร้างเฉพาะสำหรับฟอนต์แต่ละขนาด, ดังนั้นจึงแสดงผลได้คมชัดสวยงาม. ความคมชัดของฟอนต์จะเห็นผลชัดเมื่อตัวอักขระที่แสดงมีขนาดเล็ก.

ฟอร์แมตของฟอนต์บิตแมปที่ใช้ใน X วินโดว์ได้แก่ \emph{BDF (Bitmap Distribution Format)}\gindex{bdf@BDF|see{Bitmap Distribution Format}}\gindex{bitmap distribution format@Bitmap Distribution Format} และ \emph{PCF (Portable Compiled Fotmat)}. ไฟล์ฟอนต์ BDF มักจะมีส่วนขยายชื่อไฟล์เป็น \cmd{.bdf} เป็นไฟล์เท็กซ์ธรรมดาสามารถอ่านเข้าใจได้. ส่วนไฟล์ฟอนต์ PCF มักมีส่วนขยายชื่อไฟล์เป็น \cmd{.pcf} เป็นไฟล์ไบนารีที่แปลงมาจากไฟล์ฟอนต์ BDF อีกทีด้วยโปรแกรม \cmd{bdftopcf}. ไฟล์ฟอนต์ที่ใช้จริงในระบบมักจะเป็นไฟล์ PCF ที่บีบอัดด้วย \cmd{gzip} อีกที. ฟอนต์เหล่านี้สามารถสร้างด้วยโปรแกรมเช่น \cmd{xmbdfedit}\cindex{xmbdfedit}, \cmd{fontforge} ฯลฯ.

\subsubsection{ฟอนต์เอาต์ไลน์}\gindex{ฟอนต์!เอาต์ไลน์}
ฟอนต์เอาต์ไลน์ที่เป็นที่รู้จักกันเช่นฟอนต์ฟอร์แมต Type 1 ซึ่งเป็นฟอนต์สำหรับภาษา PostScript %
\myvocab{p}{PostScript}{ภาษาคอมพิวเตอร์สำหรับงานกราฟิก, นิยมใช้ในงานพิมพ์ต่างๆ. ในลินุกซ์จะมีตัวแปลภาษา PostScript ที่เรียกว่า Ghostscript ซึ่งใช้แปลภาษา PostScript แสดงผลในดีไวซ์ต่างๆได้.}%
และฟอนต์ทรูไทป์. ปัจจุบันแนวโน้มการใช้ฟอนต์เริ่มหันไปสู่ฟอนต์แบบ\emph{โอเพนไทป์ (OpenType)} ขึ้นเรื่อยๆ. ฟอนต์เหล่านี้สามารถสร้างด้วยโปรแกรม \cmd{fontforge} ในลินุกซ์.
\begin{itemize}
\item \textbf{ฟอนต์ไทป์ 1}\\
เป็นฟอนต์ที่พัฒนาโดยบริษัท Adobe มีชื่อเรียกทั่วไปว่าฟอนต์ PostScript เพราะเป็นฟอนต์ที่ออกแบบใช้งานกับภาษา PostScript. รูปทรงของอักขระจะสร้างจากเส้นโค้ง Cubic B\'ezier %
\myvocab{b}{Bezier}{เส้นโค้ง B\'ezier เป็นเส้นโค้งคณิตศาสตร์แบบพารามิเตอร์. นิยมใช้ในโปรแกรมกราฟิกต่างๆเช่น Gimp, Inkscape ฯลฯ. รูปทรงของฟอนต์ทรูไทป์เป็นเส้นโค้ง Quadratic Bezier ซึ่งอันดับ (เลขยกกำลัง) ของพารามิเตอร์เป็น 2. ส่วนฟอนต์ PostScript ใช้เส้นโค้ง Cubic Bezier มีอันดับของพารามิเตอร์เป็น 3.}%
 เมื่อย่อหรือขยายจะไม่มีหยักเหมือนฟอนต์บิตแมปเพราะการแสดงผลจะวาดรูปทรงใหม่ตามเส้นโค้งที่กำหนดไว้ในฟอนต์.

ฟอร์ปแมตของฟอนต์ไทป์ 1 มีสองประเภทคือ \emph{PFA (PostScript Font ASCII)}\gindex{postscript font ascii@PostScript Font ASCII}\gindex{pfa@PFA|see{PostScript Font ASCII}} ซึ่งเป็นไฟล์ฟอนต์ข้อมูลเท็กซ์ธรรมดา, และฟอร์แมต \emph{PFB (PostScript Font Binary)}\gindex{pfb@PFB|see{PostScript Font Binary}}\gindex{postscript font binary@PostScript Font Binary} ซึ่งเป็นไฟล์ฟอนต์ข้อมูลไบนารี. ข้อมูลที่เกี่ยวกับตัวอักขระเช่นความกว้าง, การ\emph{เคิร์นนิงค์ (kerning)}\gindex{kerning} %
\myvocab{k}{kerning}{การปรับระดับ, ตำแหน่งของอักขระเมื่อมีการแสดงผลร่วมกับอักขระอื่นให้เหมาะสมสวยงาม. }%
ฯลฯ จะอยู่ในไฟล์แยกต่างหากคือไฟล์ \emph{AFM (Adobe Font Metric)}\gindex{afm@AFM|see{Adobe Font Metric}}\gindex{adobe font metric@Adobe Font Metric}. ฟอนต์ PostScript นี้สามารถเก็บข้อมูลของอักขระได้มากที่สุด 256 ตัว\mymemo{สำหรับฟอนต์ของภาษาไทยที่มีอักขระมากกว่า 256 เช่นภาษาญี่ปุ่นจะใช้เทคนิคอื่นได้แก่ CID (Character IDentifier Keyed Font)}.
\item \textbf{ฟอนต์ทรูไทป์}\gindex{truetype@TrueType}\gindex{ฟอนต์!ทรูไทป์}\\
เป็นฟอนต์ที่บริษัท Apple และ Microsoft ร่วมกันพัฒนาใช้กันอย่างกว้างขวางในระบบปฏิบัติการวินโดวส์และ Mac OS. ฟอนต์ทรูไทป์มีข้อมูลอักขระเป็นเส้นโค้ง Quadratic B\'ezier, ข้อมูลเกี่ยวกับรูปทรงเช่นความกว้าง, ขนาด ฯลฯ จะเก็บไว้ในไฟล์ฟอนต์เดียวกันไม่แยกเหมือนกับฟอนต์ PostScript.
\item \textbf{ฟอนต์โอเพนไทป์}\gindex{opentype@OpenType}\gindex{ฟอนต์!โอเพนไทป์}\\
เป็นฟอนต์ที่เริ่มพัฒนาโดย Microsoft และเข้าร่วมพัฒนาโดย Adobe ภายหลัง. คุณสมบัติเด่นของฟอนต์โอเพนไทป์เช่นอิงการเข้ารหัสอักขระแบบ\emph{ยูนิโค้ด (unicode)}, %
\myvocab{u}{unicode}{มาตรฐานสำหรับการแสดงข้อมูลเท็กซ์หลายภาษาพร้อมๆกัน. เดิมทีข้อมูลในคอมพิวเตอร์ไม่ได้คำนึงถึงการใช้ภาษาอื่นๆทำให้ช่วงแรกๆคอมพิวเตอร์รองรับข้อมูลเท็กซ์เฉพาะภาษาอังกฤษซึ่งต้องการเนื้อที่สำหรับบันทึกอักขระแค่ 7 บิตก็เพียงพอ. ต่อมาคอมพิวเตอร์ใช้กันอย่างแพร่หลายทำให้ต้องเพิ่มเนื้อที่สำหรับภาษาอื่นๆด้วยจึงเกิดมาตรฐานยูนิโค้ดขึ้น. อักขระทุกภาษาสามารถแสดงด้วยข้อมูล 16 บิต.}%
บรรจุข้อมูลอักขระได้มากถึง 65,536 ตัว, มีข้อมูลเฉพาะเกี่ยวกับภาษาประกอบ เป็นต้น.
\end{itemize}

\subsubsection{การแสดงอักขระของฟอนต์เวกเตอร์ทางหน้าจอ}
โดยปรกติหน้าจอหรือเครื่องพิมพ์มักจะแสดงผลเป็นจุด. ข้อมูลฟอนต์แบบเวกเตอร์ต้องมีการแปลงข้อมูลให้แสดงด้วยจุดทางหน้าจอเวลาแสดงผล. การแสดงผลนี้เรียกว่า\emph{การเรนเดอร์ (rendering)}\gindex{rendering}. การเรนเดอร์นี้เป็นการแปลงข้อมูลอนาล็อก (ข้อมูลฟอนต์เวกเตอร์) เป็นข้อมูลดิจิตอล (บิตแมป) ซึ่งบางกรณียากที่จะแสดงผลให้สวยงามเหมือนข้อมูลที่เป็นดิจิตอลเช่นฟอนต์บิตแมปอยู่แล้ว. ส่วนที่มักจะมีปัญหาแสดงผลได้ไม่ดีเช่นส่วนโค้งหรือส่วนเอียงของอักขระ. ปรากฏการณ์ที่แสดงผลได้ไม่สวยงามเพราะการแปลงข้อมูลเช่นนี้เรียกว่า\emph{อเลียสซิงค์ (aliasing)}\gindex{aliasing}. \emph{แอนติอเลียส (anti-alias)}\gindex{anti-alias} เป็นวิธีแก้รอหยักที่เกิดจากอเลียสซิงค์โดยเพิ่มพิกเซลที่มีค่าเฉลี่ยบริเวณส่วนที่หยักทำให้ผลที่ปรากฏทางหน้าจอดูดีขึ้น. ถึงแม้ว่าวิธีแอนติอเลียสจะทำให้ตัวอักขระที่แสดงดูดีขึ้นในระดับหนึ่ง, แต่การเพิ่มพิกเซลนี่เองทำให้บางครั้งตัวอักขระจะดูเลือนลางโดยเฉพาะอักขระที่มีขนาดเล็ก.




สำหรับจอภาพแบบ \emph{LCD (Liquid Crytal Display)} หรือที่เรียกอีกอย่างว่าจอภาพ \emph{TFT (Thin Film Transitor)} จะมีวิธีที่เรียกว่า\emph{ซับพิกเซลเรนเดอริงค์ (sub-pixel rendering)}\gindex{rendering!sub-pixel} ช่วยทำให้คุณภาพการแสดงผลของฟอนต์หรือภาพดีกว่าปรกติ. วิธีนี้อาศัยหลักการที่ว่าจอภาพ LCD ในหนึ่งพิกเซลจะประกอบด้วยจุดย่อยหรือเรียกว่าซับพิกเซลซึ่งเป็นแม่สีสีแดง, สีเขียว, และสีน้ำเงินอีกสามจุด. ทำให้เหมือนกับว่าหน้าจอมีความละเอียดทางแนวนอนหรือทางแนวตั้งเพิ่มเป็น 3 เท่าแล้วแต่จอภาพ. ผลของซับเรนเดอริงค์จะเห็นได้ชัดโดยเฉพาะส่วนที่เป็นเส้นทแยง. เส้นบางเส้นจะใช้ซับพิกเซลช่วยแสดงผลแทนที่จะใช้พิกเซลทั้งหมด, ทำให้ผลที่ได้ดูละเอียดขึ้น.

\begin{figure}[!htb]
\plfigure{.5}{font_smooth.eps}{การแสดงผลของอักขระด้วยการแอนติอเลียส.}{font_smooth}
\end{figure}


\begin{figure}[!htb]
\plfigure{.8}{sub_pixel.eps}{หลักการซับพิกเซลเรนเดอร์ถ้ามองหน้าจอโดยใช้แว่นขยาย.}{sub_pixel}
\end{figure}

การแสดงผลของอักขระให้สวยยังขึ้นอยู่กับฟอนต์ที่ใช้ด้วย. ฟอนต์บางฟอนต์มีข้อมูลภายในเรียกว่า\emph{ฮินท์| (hint)} เป็นข้อมูลช่วยบอกใบ้ให้การแสดงผลอักขระตัวเล็กให้ถูกต้อง. ช่วยให้การแสดงผลในแต่ละพิกเซลอยู่ในตำแหน่งที่สมควร. นอกจากการใช้ฮินท์ช่วยแสดงผลอักขระตัวเล็กๆแล้ว, บางฟอนต์อาจจะมีข้อมูลบิตแมปผังอยู่ในฟอนต์ใช้แสดงผลเมื่ออักขระมีขนาดเล็ก. กล่าวคือมีข้อมูลเวกเตอร์และบิตแมปอยู่ในไฟล์เดียวกัน.



ในระบบ X วินโดว์สมัยใหม่ที่ใช้สภาพแวดล้อมเดสก์ท็อปเช่น GNOME สามารถตั้งค่าคุณสมบัติเพื่อช่วยให้แสดงผลฟอนต์ได้สวยงามขึ้นจากเมนู ``Desktop preference'' > ``Font''.

\begin{figure}[!htb]
\ifthenelse{\isodd{\pageref{fig:rendering}}}%
{\parbox{\headwidth}{\center\scalebox{.45}{\includegraphics{font_preferences.eps}~~~~\includegraphics{font_rendering.eps}}\caption{หน้าจอในสภาพแวดล้อมเดสก์ท็อป GNOME ให้เลือกการเรนเดอร์ฟอนต์แบบต่างๆ.}\label{fig:rendering}}}%
{\leftskip=\moveback\parbox{\headwidth}{\center\scalebox{.45}{\includegraphics{font_preferences.eps}~~~~\includegraphics{font_rendering.eps}}\caption{หน้าจอในสภาพแวดล้อมเดสก์ท็อป GNOME ให้เลือกการเรนเดอร์ฟอนต์แบบต่างๆ.}\label{fig:rendering}}}
\end{figure}







\subsection{แป้นพิมพ์}\label{sec:xkb}
แป้นพิมพ์เป็นฮาร์ดแวร์อย่างหนึ่งในหลายๆตัวที่ใช้ทั่วไปกับคอมพิวเตอร์. เวลาเรากดคีย์ใดคีย์หนึ่งจะมีสัญญาณอิเล็กทรอนิกส์บอกสภาพของคีย์ว่ากำลังถูกกดอยู่หรือกำลังปล่อยหลังจากการกด. สภาพนี้เรียกว่า\emph{อิเวนต์ (event)}\gindex{event}\gindex{อิเวนต์}\mymemo{อิเวนต์ที่เกี่ยวกับแป้นพิมพ์มีชื่อเรียกเฉพาะว่า\emph{คีย์บอร์ดอิเวนต์ (keyboard event)}, อิเวนต์ที่เกี่ยวกับเมาส์มีชื่อเรียกเฉพาะว่า\emph{เมาส์อิเวนต์ (mouse event)}.} และสัญญาณอิเล็กทรอนิกส์ที่ส่งมาจากแป้นพิมพ์เรียกว่า\emph{สแกนโค้ด (scancode)}\gindex{scancode}\gindex{สแกนโค้ด}.

X เซิร์ฟเวอร์จะรับรู้อิเวนต์ของคีย์และสัญลักษณ์หรือค่าที่เรียกว่า\emph{คีย์โค้ด (keycode)}\gindex{keycode}\gindex{คีย์โค้ด} ซึ่งมีแปลงมาจากสัญญาณสแกนโค้ดอีกทีหนึ่ง. คีย์โค้ดนี้เป็นเพียงแค่ค่า, ไม่ใช่สัญลักษณ์ที่แสดงบนคีย์เช่น ``a'', ``b'', ``c''. สัญลักษณ์ที่มีความหมายและมนุษย์รับรู้ได้จะแปลงมาจากคีย์โค้ดอีกทีหนึ่งเรียกว่า\emph{คีย์ซิม (keysym)}\gindex{keysym}\gindex{คีย์ซิม} เช่นการกดคีย์ที่มีอักษร ``a'' อยู่บนคีย์นั้นก็จะได้สัญญลักษณ์ที่ความหมายเป็นตัวอักษร ``a''.

โดยปรกติในแป้นพิมพ์จะมีคีย์พิเศษเช่นคีย์ Control, Caps Lock และ Shift. คีย์เหล่านี้เรียกว่า\emph{คีย์โมดิไฟเออร์ (modifier key)}\gindex{modifier key}\gindex{โมดิไฟเออร์คีย์}. ถ้ากดคีย์โมดิไฟเออร์พร้อมกับกดคีย์ธรรมดาสามารถสร้างสัญลักษณ์ที่เกิดจากคีย์ธรรมดานั้นได้หลายแบบ. เช่นถ้าเรากดคีย์ Shift ค้างไว้และคีย์ ``a'' ตามจะได้คีย์ซิมเป็นสัญลักษณ์ ``A''. ถ้าไม่กดคีย์โมดิไฟเออร์ใดๆก็จะได้สัญลักษณ์คีย์ซิมปรกติของคีย์นั้น. คีย์โมดิไฟเออร์ในระบบ X วินโดว์มีอยู่ด้วยกัน 8 ตัวได้แก่ Control, Shift, Lock, Mod1, Mod2, Mod3, Mod4 และ Mod5. Mod1 ถึง Mod5 เป็นชื่อของคีย์โมดิไฟเออร์ทั่วไป, ไม่มีชื่อเฉพาะและบนแป้นพิมพ์ก็ไม่มีคีย์ที่ชื่อ Mod1, Mod2 ฯลฯ. โดยปรกติแล้ว, คีย์ Alt จะใช้เป็นคีย์โมดิไฟเออร์ Mod1, ส่วนคีย์โมดิไฟเออร์ที่เหลือไม่นิยมใช้.

\begin{figure}[!htb]
\plfigure{1.3}{xkb.eps}{ระดับและกลุ่มในโมดูล XKB ของ X เซิร์ฟเวอร์.}{xkb}
\end{figure}


แป้นพิมพ์ภาษาอังกฤษโดยปรกติจะใช้แค่คีย์โมดิไฟเออร์ Shift ก็เพียงพอที่จะแสดงอักขระได้ทุกตัว. แต่สำหรับภาษาอื่นๆเช่นลาติน (ยุโรป), ไทย ฯลฯ จำเป็นต้องใช้แป้นพิมพ์คนละชุดจึงเกิดความคิดขยายความสามารถของแป้นพิมพ์เป็นโมดูลใช้กับ X เซิร์ฟเวอร์เรียกว่า \emph{XKB (X Keyboard Extension)}\gindex{xkb@XKB|see{X Keyboard Extension}}\gindex{x keyboard extension@X Keyboard Extension}. โมดูล XKB ช่วยปรับแต่งคุณสมบัติของแป้นพิมพ์ในหลายๆด้านนอกจากภาษาด้วยเช่นการปรับผังหรือประเภทของแป้นพิมพ์เป็นต้น. โมดูล XKB ยังแบ่งสัญญลักษณ์ของคีย์ซิมเป็น\emph{ระดับ (level)} และ\emph{กลุ่ม (group)}. ระดับคือสภาพที่บอกว่ามีการใช่คีย์โมดิไฟเออร์ Shift ด้วยหรือไม่. กลุ่มเป็นการแสดงกลุ่มของอักขระที่ต้องการแสดงเช่นกลุ่มภาษาอังกฤษ, กลุ่มภาษาไทย เป็นต้น. การปรับแต่งค่าที่เกี่ยวกับโมดูล XKB นี้ทำได้จากไฟล์ตั้งค่าเริ่มต้นของ X เซิร์ฟเวอร์หรือจากบรรทัดคำสั่งก็ได้. ในบางกรณีเช่นสภาพแวดล้อมเดสก์ท็อป GNOME สามารถติดตั้งคีย์บอร์ดภาษาแบ่งกลุ่มได้จากเมนูหลักแทนที่จะไปติดตั้งในไฟล์เริ่มต้นของ X เซิร์ฟเวอร์.


\subsection{ทรัพยากร}\label{sec:xresource}
เราได้เรียนรู้ไปแล้วว่าโปรแกรม GUI ดั้งเดิมที่ใช้ไลบรารี Xt มีตัวเลือกเหมือนๆกันใช้สำหรับปรับแต่งโปรแกรมเช่นตัวเลือก \cmd{-bg} สำหรับระบุสีที่ใช้เป็นพื้นหลังของตัวโปรแกรม ฯลฯ. คุณสมบัติที่ปรับแต่งได้เหล่านี้ในระบบ X วินโดว์จะเรียกว่า\emph{ทรัพยากร (resource)}. โปรแกรมแต่ละตัวจะมีค่าทรัพยากรโดยปริยายระบุคุณสมบัติต่างๆของโปรแกรมเช่น สีของเส้นที่ใช้, ฟอนต์, ขนาดหน้าต่าง ฯลฯ. ไฟล์ค่าทรัพยากรของโปรแกรมต่างๆในระบบโดยรวมจะอยู่ในไดเรกทอรี \cmd{/usr/X11R6/lib/X11/app-defaults}. เช่นไฟล์ค่าทรัพยากรสำหรับโปรแกรม \cmd{xterm} คือ XTerm, ไฟล์ค่าทรัพยากรสำหรับโปรแกรม \cmd{xman} คือ Xman. ชื่อไฟล์เหล่านี้จริงๆแล้วคือ\emph{ชื่อคลาส (class name)} ของโปรแกรมที่ทำงานอยู่. แอพพลิเคชันทุกตัวในระบบ X วินโดว์จะมี\emph{ชื่ออินสแตนต์ (instance name)} และชื่อคลาส. ชื่ออินสแตนต์อาจจะมีชื่อที่แตกต่างจากชื่อคลาสหรือเหมือนกับชื่อคลาสก็ได้และสามารถตั้งชื่ออินสแตนต์เองได้ด้วยตัวเลือก \cmd{-name \textit{instance-name}}.

ชื่ออินสแตนต์และชื่อคลาสของโปรแกรมสามารถตรวจสอบได้ด้วยโปรแกรม \cmd{xprop}\cindex{xprop}. โปรแกรม \cmd{xprop} เป็นแอพพลิเคชันมาตรฐานใช้บอกคุณสมบัติของโปรแกรมที่ใช้ในระบบ X วินโดว์. เวลารันโปรแกรม, พอยต์เตอร์ของเมาส์จะเป็นเครื่องหมายบวก. ให้ใช้พอยต์เตอร์คลิ้กหน้าต่างที่ต้องการตรวจสอบก็จะแสดงค่าคุณสมบัติต่างๆของหน้าต่างนั้นทางเทอร์มินอลที่รัน \cmd{xprop}.

\begin{MyExample}[ใช้ \cmd{xprop} ดูค่าคุณสมบัติต่างๆของหน้าต่าง.]
\begin{MyEx}
$ \cin{xprop} \mycomment{แล้วใช้เมาส์คลิ้กเลือกหน้าต่าง}
WM_PROTOCOLS(ATOM): protocols  WM_DELETE_WINDOW
_NET_WM_ICON_GEOMETRY(CARDINAL) = 669, 1000, 105, 24
SM_CLIENT_ID(STRING) = "117f000001000110562372800000078480012"
XKLAVIER_STATE(INTEGER) = 0, 0
_NET_FRAME_EXTENTS(CARDINAL) = 1, 1, 21, 5
_NET_WM_DESKTOP(CARDINAL) = 0
_NET_WM_STATE(ATOM) =
WM_STATE(WM_STATE):
                window state: Normal
                icon window: 0x0
WM_COMMAND(STRING) = { "xman" }
WM_LOCALE_NAME(STRING) = "C"
WM_CLASS(STRING) = "topBox", "Xman" \mycomment{ในกรณีนี้ใช้คลิ้กหน้าต่างหลักของ} xman
WM_HINTS(WM_HINTS):
                Client accepts input or input focus: True
                Initial state is Normal State.
                bitmap id # to use for icon: 0x3c00005
WM_NORMAL_HINTS(WM_SIZE_HINTS):
                program specified size: 114 by 71
                window gravity: NorthWest
WM_CLIENT_MACHINE(STRING) = "toybox"
WM_ICON_NAME(STRING) = "Xman"
WM_NAME(STRING) = "xman"
\end{MyEx}
\end{MyExample}%$

ในบรรทัดที่ขึ้นต้นด้วย WM\_CLASS จะแสดงชื่ออินสแตนต์และชื่อคลาส. ในตัวอย่างชื่ออินสแตนต์คือ topBox และชื่อคลาสคือ Xman. เพราะว่าชื่อคลาสของโปรแกรมคือ Xman ดังนั้นค่าทรัพยากรต่างๆจะเขียนอยู่ในไฟล์ชื่อ \cmd{Xman} ที่อยู่ใต้ไดเรกทอรี \cmd{/usr/X11R6/lib/X11/app-defaults}.

\begin{MyExample}[ไฟล์ค่าทรัพยากรของโปรแกรม GUI ที่ใช้ไลบรารี Xt.]
\begin{MyEx}
$ \cin{pwd}
/usr/X11R6/lib/X11/app-defaults
$ \cin{cat XMan}
*input:                         True

*topBox:                        True
*topBox.Title:                  Xman
*topBox.IconName:               Xman

*manualBrowser.Title:           Manual Page
*manualBrowser.IconName:        Manual Page
*manualBrowser.geometry:        600x600

*manualFontBold:                -*-courier-bold-r-*-*-*-120-*-*-*-*-*-*
*manualFontItalic:              -*-courier-medium-o-*-*-*-120-*-*-*-*-*-*
\abb
\end{MyEx}
\end{MyExample}

ข้อมูลในไฟล์ค่าทรัพยากรเป็นข้อมูลเท็กซ์อ่านเข้าใจได้. โดยมีรูปแบบเป็น
\begin{MyVerbatim}
\textit{resource-name}: \textit{value}
\end{MyVerbatim}
ชื่อทรัพยากรจะเป็นชื่ออินสแตนต์ของวิดเจ็ตที่ใช้ในโปรแกรมบ้าง, ชื่อคุณสมบัติต่างๆ. ชื่อเหล่านี้จะใช้เครื่องหมายจุด \cmd{.} เป็นตัวขั้นแสดงโครงสร้าง. ในบางกรณีอาจจะใช้เครื่องหมายดอกจัน \cmd{*} แทนอะไรก็ได้. เช่น \cmd{*font} เป็นค่าทรัพยากรชื่อฟอนต์ที่ต้องการใช้ซึ่งอาจจะเป็นของ \cmd{topBox} หรือ \cmd{manualBrowser} ก็ได้.

วิธีการสำรวจชื่อทรัพยากรของโปรแกรมต่างๆอาจจะใช้โปรแกรม \cmd{editres}\cindex{editres} ช่วย. โปรแกรมนี้จะสามารถแสดงชื่อและค่าทรัพยากรของหน้าต่างที่เลือกเป็นแผนภาพโครงสร้างต้นไม้และยังสามารถตั้งค่าทรัพยากรได้ด้วย.

\begin{figure}[!htb]
\plfigure{.4}{xresources.eps}{โปรแกรม \cmd{editres} แสดงชื่อทรัพยากรและตั้งค่า.}{editres}
\end{figure}

นอกจากโปรแกรม \cmd{editres} แล้ว, ในระบบ X วินโดว์จะมีคำสั่ง \cmd{appres}\cindex{appres} ใช้แสดงฐานข้อมูลของทรัพยากรตามชื่อคลาสหรือชื่ออินสแตนต์ที่ระบุเป็นอาร์กิวเมนต์ด้วย.

\begin{MyExample}[แสดงฐานข้อมูลทรัพยากรด้วยคำสั่ง \cmd{appres}.]
\begin{MyEx}
$ \cin{appres Xman}
*search*manualPage.Label:       Manual Page
*search*dialog*value:   Xman
*search*dialog.Label:   Type string to search for:
*search*cancel.Label:   Cancel
*search*apropos.Label:  Apropos
*search*label.BorderWidth:      0
*search.Label:  Search
*XmLabelGadget.background:      #eaeaea
*XmLabelGadget.foreground:      #000000
\abb
\end{MyEx}
\end{MyExample}%$

\subsubsection{ตั้งค่าทรัพยากรเฉพาะบุคคล}
ไฟล์ที่อยู่ในไดเรกทอรี \cmd{/usr/X11R6/lib/X11/app-defaults} เป็นไฟล์ค่าทรัพยากรของโปรแกรมต่างๆในระบบ. ถ้าต้องการเปลี่ยนคุณสมบัติต่างๆให้แตกต่างจากค่าทรัพยากรที่ระบุในไฟล์เหล่านั้นอาจทำได้โดย\begin{itemize}
\item ใช้ตัวเลือกที่เกี่ยวข้องกับทรัพยากรนั้น\\
ตัวอย่างเช่น \cmd{-bg} จะเกี่ยวข้องกันทรัพยากร \cmd{*background} เป็นต้น. แต่ทรัพยากรทุกตัวไม่สามารถตั้งค่าผ่านทางตัวเลือกได้ทั้งหมดทุกตัว.
\item ใช้ตัวเลือก \cmd{-xrm "\textit{resource-name: value}"}\\
ชื่อทรัพยากรและค่าสามารถเขียนเป็นอาร์กิวเมนต์ของตัวเลือก  \cmd{-xrm} ได้เช่น \cmd{-xrm '*background: black'}.
\item ไฟล์ \cmd{.Xdefaults}\index{command}{.xdefaults@{\thaitext ไฟล์} \cmd{.Xdefaults}} หรือ \cmd{.Xresources}\index{command}{.xresources@{\thaitext ไฟล์} \cmd{.Xresources}} ในโฮมไดเรกทอรี\\
โดยปรกติ, เวลา X เซิร์ฟเวอร์เริ่มทำงานจะมีสคริปต์ตั้งค่าเริ่มต้นทั้งสำหรับระบบและระดับบุคคล. ถ้าเป็นสคริปต์สำหรับระบบโดยรวมแล้วจะใช้คำสั่ง \cmd{xrdb}\cindex{xrdb} ซึ่งเป็นคำสั่งอ่านฐานข้อมูลทรัพยากรจากไฟล์ที่เป็นอาร์กิวเมนต์. และไฟล์ที่อ่านมักจะใช้ชื่อเป็น \cmd{.Xdefaults} หรือ \cmd{.Xresources} ในโฮมไดเรกทอรี. ส่วนจะใช้ไฟล์ \cmd{.Xdefaults} หรือ \cmd{.Xresources} นั้นแล้วแต่ระบบ.
\item ไฟล์ \cmd{.Xdefaults-\textit{hostname}} ในโฮมไดเรกทอรี\\
เวลารันโปรแกรมที่ใช้ไลบรารี Xt จะอ่านไฟล์ค่าทรัพยากรจากไฟล์ \cmd{.Xdefaults-\textit{hostname}} ทุกครั้ง. ถ้าต้องการเปลี่ยนค่าทรัพยากรของแอพพลิเคชันต่างๆให้กำหนดในไฟล์นี้โดยไม่ต้องเรียกคำสั่ง \cmd{xrdb} เหมือนกับไฟล์ \cmd{.Xdefaults} หรือ \cmd{.Xresources}.
\end{itemize}

ไฟล์ \cmd{.Xdefaults}, \cmd{.Xresources} และ \cmd{.Xdefaults-\textit{hostname}} จะมีรูปแบบคล้ายกับไฟล์ค่าทรัพยากรที่อยู่ในไดเรกทอรี \cmd{app-defaults}. สามารถระบุค่าทรัพยากรของโปรแกรมต่างๆได้ในไฟล์เดียวกัน.

\subsubsection{สร้างไฟล์ \cmd{.Xdefault-\textit{hostname}}}
เนื่องจากไฟล์ \cmd{\~{}/.Xdefaults-\textit{hostname}} เป็นไฟล์ที่โปรแกรมที่ใช้ไลบรารี Xt อ่านค่าทรัพยากร. ดังนั้นถ้าต้องการปรับคุณสมบัติของโปรแกรมต่างๆให้ใช้กำหนดในไฟล์นี้.

วิธีการสร้างไฟล์ \cmd{.Xdefaults-\textit{hostname}} สามารถทำได้โดยคัดลอกบรรทัดต่างๆจากไฟล์ที่อยู่ในไดเรกทอรี \cmd{app-defaults} แล้วเติมชื่อคลาสของโปรแกรมที่ต้องการตั้งค่า. ตัวอย่างเช่นถ้าต้องการตั้งค่าทรัพยากรเฉพาะของโปรแกรม \cmd{xterm} ให้คัดลอกเนื้อหาของไฟล์ \cmd{XTerm} มาไว้ใน \cmd{\~{}/.Xdefaults-\textit{hostname}} แล้วเติมชื่อคลาส (XTerm) หรือชื่ออินสแตนต์ (xterm) ต้นบรรทัดทุกบรรทัดที่คัดลอกมา. จากนั้นก็ปรับแต่งค่าตามที่ต้องการ.

วิธีอีกแบบและสะดวกกว่าคือการใช้คำสั่ง \cmd{appres} ช่วยแสดงชื่อและค่าทรัพยากรของโปรแกรม (อินสแตนต์) ที่ต้องการ, เก็บผลลัพธ์ไว้ในไฟล์ \cmd{.Xdefaults-\textit{hostname}}.

\begin{MyExample}[สร้างไฟล์ \cmd{.Xdefault-\textit{hostname}} สำหรับ \cmd{xterm} โดยใช้ \cmd{appres} ช่วย.]
\begin{MyEx}
$ \cin{appres xterm | grep '^xterm' >> .Xdefaults-`hostname`}
$ \cin{tail ~/.Xdefault-`hostname`}
xterm*XmLabel.background:       #eaeaea
xterm*XmLabel.foreground:       #000000
xterm*XmTearOffButtonGadget.background: #eaeaea
xterm*XmTearOffButtonGadget.foreground: #000000
xterm*beNiceToColormap: false
xterm*ScrollbarBackground:      #eaeaea
xterm*foreground:       #000000
xterm*borderColor:      black
xterm*background:       #eaeaea
xterm*ShapeStyle:       Rectangle
\end{MyEx}
\end{MyExample}%$
อาร์กิวเมนต์ของ \cmd{appres} คือชื่ออินสแตนต์ซึ่งในกรณีได้แก่ xterm. คำสั่ง \cmd{appres} จะแสดงทรัพยากรทั่วๆไปด้วยซึ่งจะไม่มีชื่ออินสแตนต์นำหน้า. ดังนั้นจึงใช้คำสั่ง \cmd{grep} กรองเอาเฉพาะบรรทัดที่มีชื่ออินสแตนต์เก็บไว้. หลังจากนั้นผู้ใช้สามารถแก้ไขไฟล์ \cmd{.Xdefault-\textit{hostname}} ด้วยบรรณาธิกรณ์ตามต้องการ. สำหรับชื่อทรัพยากรอื่นๆที่ไม่ได้เขียนไว้ในไฟล์, สามารถเพิ่มเติมได้โดยใช้โปรแกรม \cmd{editres} ช่วย.

อาร์กิวเมนต์ของคำสั่ง \cmd{appres} เป็นได้ทั้งชื่ออินสแตนต์และชื่อคลาสซึ่งจะให้ผลไม่เหมือนกัน. ถ้าจะอาร์กิวเมนต์เป็นชื่อคลาส, ต้องเปลี่ยนคำสั่งที่ใช้สร้างไฟล์ \cmd{.Xdefaults-\textit{hostname}} ใช้ \cmd{sed} ช่วยเพิ่มชื่อคลาสที่ต้นบรรทัดทุกบรรทัด.
\begin{MyExample}[สร้างไฟล์ \cmd{.Xdefault-\textit{hostname}} โดยใช้ชื่อคลาสแทนชื่ออินสแตนต์.]
\begin{MyEx}
$ \cin{appres XTerm | sed -e 's/^\bs{}(\bs{}*.*\bs{})$/XTerm\bs{}1/' >> ~/.Xdefault-`hostname`}
\end{MyEx}
\end{MyExample}

ชื่อคลาสที่ระบุในไฟล์ \cmd{.Xdefaults-\textit{hostname}} มีความสัมพันธ์กับตัวเลือกทั่วไป \cmd{-name \textit{instance-name}}. โดยปรกติถ้าสั่งคำสั่ง \cmd{xterm}, ชื่ออินสแตนต์ของโปรแกรมจะเป็น xterm. ดังนั้นจะใช้ค่าทรัพยากรที่ขึ้นต้นด้วย xterm. ถ้ามีการใช้ตัวเลือก \cmd{-name \textit{instance-name}} เช่น \cmd{xterm -name xterm-big}, โปรแกรมที่รันจะใช้ค่าทรัพยากรที่ขึ้นต้นด้วย xterm-big. ถ้าเราเตรียมค่าทรัพยากรชื่อ xterm-big และปรับแต่งให้ใช้ฟอนต์ตัวใหญ่, เวลารันคำสั่ง \cmd{xterm -name xterm-big} ก็จะได้โปรแกรม \cmd{xterm} ที่มีคุณสมบัติต่างจาก \cmd{xterm} ธรรมดา.


\subsection{วินโดว์แมนเนเจอร์}
หน้าที่หนึ่งของ X เซิร์ฟเวอร์ได้แก่การสร้างหน้าและวาดรูปต่างๆเพื่อแสดงผลตามคำร้องขอจากไคลเอ็นต์. X เซิร์ฟเวอร์ไม่มีหน้าที่จัดตำแหน่งหรือขนาดว่าหน้าต่างใหม่ของโปรแกรมควรจะอยู่ตรงไหนอย่างไร. หน้าที่เหล่านี้เป็นหน้าที่ของโปรแกรมที่เรียกว่า\emph{วินโดว์แมนเนเจอร์ (windows manager)}. ในกรณีที่ไม่มีวินโดว์แมนเนเจอร์เวลาโปรแกรมต่างๆแสดงผลจะไม่มีกรอบควบคุม. ผู้ใช้ไม่สามารถเปลี่ยนขนาดหรือเลื่อนตำแหน่งของโปรแกรมที่ไม่มีวินโดว์แมนเนเจอร์ได้เลยในรูปที่ \ref{fig:wm}(ก).

%\begin{figure}[!htb]
%\ifthenelse{\isodd{\pageref{fig:wm}}}%
%{\parbox{\headwidth}{\center\scalebox{.25}{\includegraphics{windows.eps}~~~~\includegraphics{twm.eps}}\vspace{3mm}
%
%\scalebox{.25}{\includegraphics{fvwm.eps}~~~~\includegraphics{enlightenment.eps}}\caption{วินโดว์แมนเนเจอร์แบบต่างๆ.}\label{fig:wm}}}%
%{\leftskip=\moveback\parbox{\headwidth}{\center\scalebox{.25}{\includegraphics{windows.eps}~~~~\includegraphics{twm.eps}}\vspace{3mm}
%
%\scalebox{.25}{\includegraphics{fvwm.eps}~~~~\includegraphics{enlightenment.eps}}\caption{วินโดว์แมนเนเจอร์แบบต่างๆ.}\label{fig:wm}}}
%\end{figure}


\begin{figure}[!htb]
\ifthenelse{\isodd{\pageref{fig:wm}}}%
{\parbox{\headwidth}{\center\begin{tabular}{cc}
\scalebox{.2}{\includegraphics{windows.eps}} & \scalebox{.2}{\includegraphics{twm.eps}}\\
(ก) ไม่มีวินโดว์แมนเนเจอร์& (ข) วินโดว์แมนเนเจอร์ twm\\
\scalebox{.2}{\includegraphics{fvwm.eps}} & \scalebox{.2}{\includegraphics{enlightenment.eps}}\\
(ค) วินโดว์แมนเนเจอร์ fvwm& (ง) วินโดว์แมนเนเจอร์ enlightenment\\
\end{tabular}\caption{วินโดว์แมนเนเจอร์แบบต่างๆ}\label{fig:wm}
}}%
{\leftskip=\moveback\parbox{\headwidth}{\center\begin{tabular}{cc}
\scalebox{.2}{\includegraphics{windows.eps}} & \scalebox{.2}{\includegraphics{twm.eps}}\\
(ก) ไม่มีวินโดว์แมนเนเจอร์& (ข) วินโดว์แมนเนเจอร์ twm\\
\scalebox{.2}{\includegraphics{fvwm.eps}} & \scalebox{.2}{\includegraphics{enlightenment.eps}}\\
(ค) วินโดว์แมนเนเจอร์ fvwm& (ง) วินโดว์แมนเนเจอร์ enlightenment\\
\end{tabular}\caption{วินโดว์แมนเนเจอร์แบบต่างๆ}\label{fig:wm}
}}
\end{figure}

วินโดว์แมนเนเจอร์ดั้งเดิมได้แก่ \emph{twm (Tab Window Manager)} ที่แสดงในรูปที่ \ref{fig:wm}(ข) และ \emph{mwm (Motif Window Manager)}. วินโดว์แมนเนเจอร์นี้เรียบง่ายเพราะเป็นวินโดว์แมนเนเจอร์ในยุคแรกๆ. อย่างน้อยผู้ใช้สามารถควบคุมตำแหน่งและขนาดหน้าต่างของโปรแกรมต่างๆได้. นอกจากนั้นยังมีเมนูง่ายๆให้ใช้เมื่อคลิ้กพื้นหลังด้วย. ต่อมามีการเพิ่มคุณสมบัติต่างๆให้กับวินโดว์แมนเนเจอร์เช่นเพิ่มเมนูเรียกใช้โปรแกรมต่างๆที่เตรียมไว้, \emph{ทาสก์บาร์ (taskbar)}, \emph{รายการวินโดว์ (window list)}, \emph{เดสก์ท็อปเสมือน (virtual desktop)} %
\myvocab{v}{virtual desktop}{\emph{เดสก์ท็อปเสมือน}. คุณสมบัติของวินโดว์แมนเนเจอร์ที่สามารถขยายเดสก์ท็อปให้มีหลายหน้าทำให้เนื้อที่การใช้งานเดสก์ท็อปกว้างขึ้น. แต่ในความเป็นจริงแล้วมีหน้าจอเพียงหน้าเดียว.}%
ฯลฯ. วินโดว์แมนเนเจอร์ที่อาจจะเรียกได้ว่าเป็นยุคที่สองต่อจาก twm และ mwm ได้แก่ \emph{fvwm (F* Virtual Window Manager)} (รูปที่ \ref{wm}(ค)) \mymemo{Fvwm เป็นการเล่นคำคือให้ตัวอักษร F แทนคำอะไรก็ได้ที่ขึ้นต้นด้วย F ตามแต่จะชอบ.} และหลังจากนั้นมีผู้สร้างวินโดว์แมนเนเจอร์อื่นๆให้มีคุณสมบัติมากขึ้น, สวยขึ้น, ดีขึ้นไปเรื่อยๆเช่น Afterstep, Enlightenment, Sawfish, Fluxbox, Metacity ฯลฯ.

\subsection{สภาพแวดล้อมเดสก์ท็อป}
การมีวินโดว์แมนเนเจอร์ช่วยให้การทำงานแบบกราฟิกโดยเฉพาะด้านเดสก์ท็อปมีความสะดวกมากขึ้น. สำหรับผู้ที่ต้องการใช้เชลล์ก็เรียกใช้เทอร์มินอลเอมิวเลเตอร์มาตรฐานได้แก่ \cmd{xterm} ซึ่งจะจำลองหน้าจอแสดงผลแบบเท็กซ์และเรียกใช้เชลล์ในโปรแกรม. ถึงแม้ว่าว่าวินโดว์แมนเนเจอร์จะอำนวยความสะดวกต่างๆให้ผู้ใช้แต่ก็มีปัญหาบางอย่างเช่น
\begin{itemize}
\item โปรแกรม GUI สามารถเลือกไลบรารีทูลล์คิตที่ได้ตามต้องการ. รูปแบบของอินเทอร์เฟสของแต่ละทูลล์คิตมีความแตกต่างกันไม่เป็นหนึ่งเดียว.
\item วินโดว์แมนเนเจอร์มีให้เลือกใช้มากเกินไปเกิดความสับสนสำหรับผู้ใช้ทั่วไป. บางระบบอาจจะใช้วินโดว์แมนเนเจอร์ที่ไม่เหมือนกันทำให้ผู้ใช้ต้องปรับตัว. ในกรณีเป็นความน่ารำคาญที่ต้องเรียนรู้ใหม่.
\item ขาดความสามารถสื่อสารระหว่างโปรแกรม. เช่นไม่สามารถ\emph{แดรกแอนด์ดรอป (drag \& drop)} ซึ่งมีความจำเป็นสำหรับระบบเดสก์ท็อปชั้นสูง.
\end{itemize}
เนื่องจากปัญหาเหล่านี้จึงมีการสร้างระบบเดสก์ท็อปที่เรียกว่า\emph{สภาพแวดล้อมเดสก์ท็อป (Desktop Environment)}\gindex{desktop environment@Desktop Environment}\gindex{สภาพแวดล้อมเดสก์ท็อป} หรือเรียกย่อๆว่า \emph{DE}\gindex{de@DE|see{Desktop Enviornment}} ทำให้เดสก์ท็อปที่ใช้ดูมีความเป็นหนึ่งเดียว, จัดเตรียมไอคอนเป็นชุดที่มีความเข้ากันได้, มีโปรแกรมสำคัญๆสำหรับงานเดสก์ท็อป, \emph{ธีม (theme)}, วินโดว์แมนเนเจอร์, ความสามารถแดรกแอนด์ดรอป ฯลฯ. สภาพแวดล้อมเดสก์ท็อปที่นิยมใช้ในลินุกซ์ได้แก่ \emph{Gnome (GNU Network Object Model Environment)} และ \emph{KDE (K Desktop Environment)}.


\section{ติดตั้งและปรับแต่ง X เซิร์ฟเวอร์}
ระบบที่ต้องการใช้ X วินโดว์ต้องติดตั้งโปรแกรม X เซิร์ฟเวอร์ก่อน. โดยปรกติเวลาติดตั้งลินุกซ์มักจะมีเมนูให้เลือกติดตั้งและตั้งค่าเริ่มโดยอัตโมมัติ. หรือถ้าไม่ได้ติดตั้งแต่ตอนแรกก็สามารถติดตั้งแพ็กเกจที่เกี่ยวกับ X วินโดว์ภายหลังได้.

โปรแกรมเซิร์ฟเวอร์รวมถึงไคลเอ็นต์มาตรฐาน\mymemo{ไคลเอ็นต์มาตรฐานหมายถึงโปรแกรมที่มาพร้อมกับแพ็กเกจ X วินโดว์.}ในระบบ X วินโดว์มักของในไดเรกทอรี \cmd{/usr/X11R6/bin}. ชื่อโปรแกรมเซิร์ฟเวอร์คือ \cmd{X}\index{command}{x@{\latintext\texttt{X}}} ซึ่งเป็นชื่อทั่วไปและจะเป็นซิมโบลิกลิงก์ไปหาไฟล์โปรแกรมเซิร์ฟเวอร์ตัวจริง. ไฟล์ปรับแต่งค่าเริ่มต้นของของ X เซิร์ฟเวอร์โดยปรกติจะคือไฟล์ \cmd{/etc/X11/xorg.conf}\gindex{xorg.conf@ไฟล์ xorg.conf}. สำหรับบางดิสทริบิวที่ยังใช้ X เซิร์ฟเวอร์ของโปรเจค XFree86 จะเป็นไฟล์ \cmd{/etc/X11/XF86Config}\gindex{xf86config@ไฟล์ XF86Config|see{xorg.conf}}. ข้อมูลของไฟล์ทั้งสองฉบับนี้มีความเข้ากันได้และไม่แตกต่างกันมากนัก. ในที่นี้จะอธิบายการสร้างไฟล์ตั้งค่าเริ่มต้นของ X เซิร์ฟเวอร์โดยสมมติว่าในระบบยังไม่มีไฟล์ \cmd{xorg.conf}. %ลินุกซ์ดิสทริบิวชันส่วนใหญ่จะปรับแต่ระบบ X วินโดว์ให้โดยอัตโนมัติตอนที่ติดตั้ง. แต่ในกรณีที่โปรแกรมติดตั้งไม่สามารถปรับแต่งระบบ X วินโดว์ได้ถูกต้อง, หรือในกรณีที่ใช้ลินุกซ์ดิสทริบิวใช้ที่ต้องปรับแต่งระบบ X วินโดว์เอง,
ผู้ใช้มีความจำเป็นที่ต้องรู้ข้อมูลเกี่ยวกับฮาร์ดแวร์ต่างๆที่จะประกอบกันเป็นระบบ X วินโดว์ได้แก่
\begin{itemize}
\item \textbf{วิดีโอการ์ด (video card)}\\
วิดีโอการ์ดหรือกราฟิกการ์ดเป็นส่วนสำคัญสำหรับระบบ X วินโดว์. ผู้ใช้ควรจะรู้ข้อมูลพื้นฐานได้แก่ บรษัทผู้ผลิต, ชื่อรุ่น, จำนวนหน่วยความจำของวิดีโอการ์ด เป็นต้น. วิดีโอการ์ดที่สามารถใช้ได้กับ X เซิร์ฟเวอร์สามารถตรวจสอบได้จากเว็บไซด์ของ XFree86 หรือจากโปรแกรมช่วยติดตั้งเช่น \cmd{xorgcfg} และ \cmd{xorgxonfig}.
\item \textbf{จอภาพ (monitor)}\\
ผู้ใช้ควรรู้ว่าจอภาพที่ใช้มี\emph{ช่วงความถี่ตามแนวนอน (horizontal sync frequency)}\gindex{ช่วงความถี่ตามแนวนอน}\gindex{horizontal sync frequency} และ\emph{ช่วงความถี่ตามแนวตั้ง (vertical sync)}\gindex{ช่วงความถี่ตามแนวตั้ง}\gindex{vertical sync frequency} เท่าไร. ค่าเหล่านี้อาจจะดูได้จากเลเบลที่ติดไว้หลังจอภาพหรือจากเอกสารคู่มือการใช้จอภาพ.
\item \textbf{แป้นพิมพ์ (keyboard)}\\
แป้นพิมพ์เป็นส่วนที่มีปัญหาน้อยที่สุดเมื่อเทียบกับฮาร์ดแวร์อื่นๆ. แป้นพิมพ์ที่ใช้อาจจะเป็นแบบ \emph{PS/2}\gindex{ps/2@PS/2} %
\myvocab{p}{PS/2}{ย่อมาจากคำว่า Personal System 2 เป็นอินเทอร์เฟสมาตรฐานสำหรับต่ออุปกรณ์แป้นพิมพ์หรือเมาส์สำหรับคอมพิวเตอร์ส่วยบุคคล.}%
หรือแบบ USB (Universal Serial Bus) %
\myvocab{u}{USB}{คำย่อของ Universal Serial Bus เป็นมาตรฐานสำหรับต่ออุปกรณ์คอมพิวเตอร์ต่างๆตั้งแต่แป้นพิมพ์, เมาส์, เครื่องพิมพ์, ฮาร์ดดิสก์ ฯลฯ.}%
ก็ได้. สิ่งที่ต้องเลือกเวลาติดตั้ง X วินโดว์คือประเภทของแป้นพิมพ์เช่นแป้นพิมพ์ของคอมพิวเตอร์ส่วนบุคคลแบบ 101 คีย์ (Generic 101-key PC) ซึ่งมักใช้กันทั่วไปหรือประเภทอื่นๆ. นอกจากนั้นสามารถเลือก\emph{เลย์เอาท์ (layout)} ของแป้นพิมพ์เช่นแป้นพิมพ์ภาษาไทยได้โดยใช้โมดูล XKB (X Keyboard Extension).
\item \textbf{เมาส์ (mouse)}\\
เมาส์ที่ใช้ในระบบ X วินโดว์เป็นแบบ PS/2, Serial %
\myvocab{s}{Serial}{มาตรฐานสำหรับสื่อสาร. ด้านหลังของคอมพิวเตอร์ส่วนบุคคลโดยทั่วไปจะมีซีเรียลอินเทอร์เฟส RS-232 อยู่.}%
หรือ USB. ผู้ใช้ต้องเลือกรายละเอียดปลีกย่อยเช่นประเภทของเมาส์, จำลองปุ่มกลางถ้าเป็นเมาส์แบบสองปุ่ม, เลือกดีไวซ์ไฟล์ที่เมาส์ต่ออยู่เป็นต้น.
\end{itemize}

ในแพกเกจของ X เซิร์ฟเวอร์จะมีโปรแกรมสำหรับช่วยสร้างไฟล์ \cmd{xorg.conf} ได้แก่โปรแกรม \cmd{xorgcfg}, \cmd{xorgconfig} และตัวเซิร์ฟเวอร์ \cmd{X}.

\subsection{\cmd{xorgcfg}}
โปรแกรม \cmd{xf86cfg} (\cmd{xf86cfg}) \cindex{xorgcfg}\index{command}{xf86cfg@\cmd{xf86cfg}|see{\cmd{xorgcfg}}} เป็นโปรแกรมแบบ GUI สำหรับสร้างไฟล์ตั้งค่าเริ่มต้น \cmd{xorg.conf} ใหม่หรือแก้ไขไฟล์ \cmd{xorg.conf} ที่มีอยู่แล้ว. ถ้าโปรแกรมนี้รันอยู่ในเท็กซ์โหมดเพื่อสร้างไฟล์ตั้งค่าเริ่มต้น, ตัวโปรแกรมจะรันคำสั่ง \cmd{X -configure} อีกต่อหนึ่งเพื่อสร้างไฟล์ตั้งค่าเริ่มต้นชื่อ \cmd{xorg.conf.new}\gindex{xorg.conf.new@ไฟล์ \cmd{xorg.conf.new}} ในโฮมไดเรกทอรีของผู้ใช้โดยอัตโนมัติ. และถ้าไฟล์ตั้งค่าเริ่มต้นที่สร้างสามารถใช้งานได้, ก็จะรัน X เซิร์ฟเวอร์และแสดงหน้าจอในรูปที่ \ref{fig:xorgcfg}. ถ้าสามารถใช้เมาส์ได้, ให้ใช้เมาส์เลือกเมนูต่างๆเพื่อปรับค่าต่างๆ. ถ้าไม่สามารถใช้เมาส์ได้แสดงว่าไฟล์ตั้งค่าเริ่มต้นที่สร้างโดยอัตโนมัติมีข้อผิดพลาด. แต่ผู้ใช้ยังสามารถดำเนินการต่อไปได้โดยใช้\emph{คีย์แพด (keypad)} แทนเมาส์เลื่อนพอยต์เตอร์หรือคลิ้กที่หน้าต่างแทนเมาส์ได้. เมื่อปรับแต่งค่าต่างๆเรียบร้อยแล้วให้จบการทำงานของโปรแกรมโดยกดปุ่ม ``Quit''. โปรแกรมจะบันทึกค่าไฟล์ตั้งค่าเริ่มต้นให้โดยอัตโนมัติแล้วกลับสู่เท็กซ์โหมดอีกครั้ง.

\begin{figure}[!htb]
\plfigure{.6}{xorgcfg.eps}{โปรแกรม \cmd{xorgcfg} (\cmd{xf86cfg}) ปรับแต่ง X เซิร์ฟเวอร์และตั้งค่าเริ่มต้น.}{xorgcfg}
\end{figure}

จะมีบางกรณีที่โปรแกรมไม่สามารถทำงานได้เพราะไม่สามารถสร้างไฟล์ตั้งค่าเริ่มต้นได้ถูกต้องแต่แรก. เช่นหน้าจอดำแต่ไม่มีอะไรปรากฏ, ในกรณีนี้ให้กดคีย์ \cmd{Ctrt+Alt+BackSpace} เพื่อจบการทำงาน. หรือถ้าไม่โปรแกรมไม่สามารถรันได้แล้วกลับสู่เชลล์พรอมต์, อาจจะต้องแก้ไฟล์ \cmd{xorg.conf.new} ด้วยตัวเองแล้วรันคำสั่ง \cmd{xorgcfg} กับตัวเลือก \cmd{-config \textit{\$HOME/xorg.conf.new}} ใหม่อีกครั้ง. ถ้าไม่สำเร็จ, ให้ใช้วิธีอื่น.

\subsection{\cmd{xorgconfig}}
โปรแกรม \cmd{xorgconfig} (\cmd{xf86config})\gindex{xorgconfig}\gindex{xf86config|see{xorgconfig}} เป็นโปรแกรมบรรทัดคำสั่งแสดงคำถามหรือตัวเลือกต่างๆเกี่ยวกับฮาร์ดแวร์ในระบบ X วินโดว์และให้ผู้ใช้เลือกตอบ. โปรแกรมนี้ใช้รันในเท็กซ์โหมดและลองรัน X เซิร์ฟเวอร์หลังจากที่สร้างไฟล์แล้ว. ถ้าโปรแกรมสร้างไฟล์ตั้งค่าเริ่มต้นให้ไม่ถูกต้องอาจจะต้องแก้ไขต่อด้วยการใช้บรรณาธิกรณ์เปิดไฟล์ \cmd{/etc/X11/xorg.conf} แก้ไขเอง.

\begin{MyExample}[ขั้นตอนการทำงานของโปรแกรม \cmd{xorg.conf}]
\begin{MyEx}
# \cin{xorgconfig}
This program will create a basic xorg.conf file, based on menu selections you
make.

The xorg.conf file usually resides in /usr/X11R6/etc/X11 or /etc/X11. A sample
xorg.conf file is supplied with Xorg; it is configured for a standard
VGA card and monitor with 640x480 resolution. This program will ask for a
pathname when it is ready to write the file.

You can either take the sample xorg.conf as a base and edit it for your
configuration, or let this program produce a base xorg.conf file for your
configuration and fine-tune it.

Before continuing with this program, make sure you know what video card
you have, and preferably also the chipset it uses and the amount of video
memory on your video card. SuperProbe may be able to help with this.

Press enter to continue, or ctrl-c to abort. \cin{}

First specify a mouse protocol type. Choose one from the following list:

 1.  Auto
 2.  SysMouse
 3.  MouseSystems
 4.  PS/2
 5.  Microsoft
\abb
\end{MyEx}
\end{MyExample}


\subsection{\cmd{X}}
โปรแกรมเซิร์ฟเวอร์ \cmd{X} สามารถสร้างไฟล์ตั้งค่าเริ่มต้นให้โดยอัตโนมัติถ้ารันเซิร์ฟเวอร์ด้วยตัวเลือก \cmd{-configure}. คำสั่งนี้ต้องรันด้วย root และจะสร้างไฟล์ตั้งค่าเริ่มต้นชั่วคราว \cmd{xorg.conf.new} ไว้ในโฮมไดเรกทอรีของ root.

\begin{MyExample}[ใช้เซิร์ฟเวอร์เขียนไฟล์ตั้งค่าเริ่มต้น.]
\begin{MyEx}
# \cin{X -configure}
_XSERVTransSocketOpenCOTSServer: Unable to open socket for inet6
_XSERVTransOpen: transport open failed for inet6/toybox:1
_XSERVTransMakeAllCOTSServerListeners: failed to open listener for inet6

This is a pre-release version of the The X.Org Foundation X11.
It is not supported in any way.
\abb
Markers: (--) probed, (**) from config file, (==) default setting,
        (++) from command line, (!!) notice, (II) informational,
        (WW) warning, (EE) error, (NI) not implemented, (??) unknown.
(==) Log file: "/var/log/Xorg.0.log", Time: Fri Jan 21 15:17:03 2005
\abb
        dummy
        fbdev
        v4l
(++) Using config file: "/root/xorg.conf.new"


Xorg detected your mouse at device /dev/mouse.
Please check your config if the mouse is still not
operational, as by default Xorg tries to autodetect
the protocol.

Your xorg.conf file is /root/xorg.conf.new

To test the server, run 'X -config /root/xorg.conf.new'
\end{MyEx}
\end{MyExample}

ตัวโปรแกรมจะแสดงข้อความต่างๆทางหน้าจอ. ข้อความที่สำคัญๆได้แก่
\begin{itemize}
\item บรรทัดที่มีคำว่า ``Log file'' แสดงชื่อล็อกไฟล์ซึ่งในกรณีนี้คือ \cmd{/var/log/Xorg.0.log}. เซิร์ฟเวอร์จะสร้างล็อกไฟล์ทุกครั้งเมื่อทำงานและมีประโยชน์สำหรับตรวจสอบข้อผิดพลาดหรือข้อมูลที่เกี่ยวกับตัวเซิร์ฟเวอร์. ถ้าเกิดข้อผิดพลาดทำให้ X เซิร์ฟเวอร์ไม่สามารถทำงานได้, เราสามารถใช้คำสั่ง \cmd{less} เปิดล็อกไฟล์ดูแล้วหาบรรทัดที่มีคำว่า ``EE'' ซึ่งเป็นบรรทัดบ่งบอกสาเหตุของข้อผิดพลาด. เมื่อแก้ไขข้อผิดพลาดนั้นแล้วก็จะสามารถรัน X เซิร์ฟเวอร์ได้.
\item บรรทัดสุดท้ายบอกวิธีทดสอบการทำงานของเซิร์ฟเวอร์โดยสั่งคำสั่ง \cmd{X -config /root/xorg.conf.new}. ถ้า X เซิร์ฟเวอร์ทำงานได้หน้าจอจะเปลี่ยนเป็นกราฟฟิดโหมดและแสดงพอยเตอร์ของเมาส์. ถ้าสามารถขยับเลื่อนเมาส์ได้ก็แสดงว่า X เซิร์ฟเวอร์ทำงานได้ถูกต้อง. ให้กดคีย์ \cmd{Ctrl+Alt+Del} จบการทำงานของ X เซิร์ฟเวอร์.

มีบางกรณีที่ X เซิร์ฟเวอร์ทำงานได้แต่ทำงานได้ไม่สมบูรณ์เช่นแสดงพอยเตอร์ของเมาส์แต่ไม่สามารถขยับได้, และเป็นหน้าจอดำไม่สามารถทำอะไรต่อได้. ปัญหานี้เป็นเพราะ X เซิร์ฟเวอร์ไม่สามารถปรับแต่งค่าได้ถูกต้องร้อยเปอร์เซ็นต์. ในกรณีแรกอาจจะมีสาเหตุจากชื่อไฟล์ดีไวซ์ที่เมาส์ใช้หรือประเภทของเมาส์ไม่ถูกต้อง. ในกรณีหลังอาจจะเป็นเพราะจอภาพไม่สามารถแสดงผลได้เนื่องจากค่าของความถี่, \emph{ความละเอียดของหน้าจอ (resolution)}ไม่ตรงกัน เป็นต้น. ไม่ว่าในกรณีใดๆ, ให้ใช้บรรณาธิกรณ์เปิดไฟล์ \cmd{xorg.conf.new} แก้ไขส่วนที่เกี่ยวข้องแล้วลองใหม่จนกว่าจะสำเร็จ.
\end{itemize}

ถ้าไม่มีปัญหาใดๆให้ย้ายไฟล์ \cmd{xorg.conf.new} ไปไว้ที่ไดเรกทอรี \cmd{/etc/X11} โดยเปลี่ยนชื่อเป็น \cmd{xorg.conf}.

\section{ไฟล์ \cmd{xorg.conf}}
ไฟล์ \cmd{/etc/X11/xorg.conf} เป็นไฟล์สำคัญที่กำหนดค่าต่างทำให้เซิร์ฟเวอร์ใช้งานได้ถูกต้อง. สำหรับเซิร์ฟเวอร์ของโครงการ XFree86 จะมีชื่อเป็น \cmd{XF86Config}. ไฟล์นี้จะแบ่งเป็นเซกชัน (section) ต่างๆแสดงในตารางที่ \ref{tab:xorg.conf}

\begin{table}[!htb]
\center
\caption{เซกชันต่างๆในไฟล์ \cmd{xorg.conf}}\label{tab:xorg.conf}
\medskip
\begin{tabular}{ll}
\toprule
\multicolumn{1}{c}{ชื่อเซกชัน} & \multicolumn{1}{c}{คำอธิบาย}\\
\midrule
ServerLayout & นิยามโครงสร้างสำคัญที่ประกอบเป็นเซิร์ฟเวอร์.\\
Files & ชื่อพาท (path) ไดเรกทอรีข้อมูลต่างๆเช่นฟอนต์, โมดูล ฯลฯ.\\
Module & โมดูลที่ต้องการใช้กับ X เซิร์ฟเวอร์.\\
InputDevice & นิยามดีไวซ์เช่นแป้นพิมพ์และเมาส์.\\
Monitor & นิยามค่าคุณสมบัติของจอภาพที่ใช้.\\
Device & ค่าคุณสมบัติเกี่ยวกับกราฟิกการ์ด.\\
Screen & นิยามค่าคุณสมบัติของหน้าจอแสดงผลเชิงซอฟต์แวร์.\\
ServerFlags & ปรับแต่งคุณสมบัติโดยรวมของ X เซิร์ฟเวอร์.\\
\bottomrule
\end{tabular}
\end{table}

ตัวอย่างที่ \ref{ex:xorg.conf} แสดงไฟล์ \cmd{xorg.conf} ที่สร้างด้วยคำสั่ง \cmd{X -configure} และปรับแต่งให้ใช้งานได้จริง. โดยปรกติ, แพ็กเกจ X เซิร์ฟเวอร์จะมีตัวอย่างไฟล์ชื่อ \cmd{/etc/X11/xorg.conf.example} (\cmd{/etc/X11/XF86Config.example}) มาให้ด้วยดูเป็นตัวอย่าง. ไฟล์ตัวอย่างนั้นไม่สามารถเอาใช้จริงได้แต่มีประโยชน์ไว้ศึกษาเพราะมีคอมเมนต์อธิบายส่วนต่างๆไว้ด้วย.

\begin{shaded}
\begin{MyExample}[ไฟล์ \cmd{/etc/xorg.conf}]\label{ex:xorg.conf}
\begin{MyEx}
     1  Section "ServerLayout"
     2      Identifier     "XFree86 Configured"
     3      Screen         "Screen0"
     4      InputDevice    "Mouse0" "CorePointer"
     5      InputDevice    "Keyboard0" "CoreKeyboard"
     6  EndSection
     7
     8  Section "Files"
     9      # For XFS, uncomment this and comment the others
    10      # FontPath  "unix/:-1"
    11      RgbPath      "/usr/X11R6/lib/X11/rgb"
    12      ModulePath   "/usr/X11R6/lib/modules"
    13      FontPath     "/usr/share/fonts/misc/"
    14      FontPath     "/usr/share/fonts/Speedo/"
    15      FontPath     "/usr/share/fonts/Type1/"
    16      FontPath     "/usr/share/fonts/CID/"
    17      FontPath     "/usr/share/fonts/75dpi/"
    18      FontPath     "/usr/share/fonts/100dpi/"
    19  EndSection
    20
    21  Section "Module"
    22      Load  "extmod"
    23      Load  "dri"
    24      Load  "dbe"
    25      Load  "record"
    26      Load  "xtrap"
    27      Load  "glx"
    28      Load  "speedo"
    29      Load  "type1"
    30  EndSection
    31
    32  Section "InputDevice"
    33      Identifier  "Keyboard0"
    34      Driver      "kbd"
    35
    36      Option     "XkbModel"      "pc101"
    37      Option     "XkbLayout"     "us,th_tis"
    38      Option     "XkbOptions"    "grp:alt_shift_toggle,grp_led:scroll,\wrap
lv3:ralt_switch"
    39  EndSection
    40
    41  Section "InputDevice"
    42      Identifier  "Mouse0"
    43      Driver      "mouse"
    44      Option      "Protocol" "IMPS/2"
    45      Option      "Device" "/dev/mouse"
    46      Option      "Buttons" "5"
    47      Option      "ZAxisMapping" "4 5"
    48  EndSection
    49
    50  Section "Monitor"
    51      DisplaySize   380   310 # mm
    52      Identifier   "Monitor0"
    53      VendorName   "DEL"
    54      ModelName    "DELL 1901FP"
    55      Option      "DPMS"
    56  EndSection
    57
    58  Section "Device"
    59      Identifier  "Card0"
    60      Driver      "nv"
    61      VendorName  "nVidia Corporation"
    62      BoardName   "Unknown Board"
    63      BusID       "PCI:1:0:0"
    64  EndSection
    65
    66  Section "Screen"
    67      Identifier "Screen0"
    68      Device     "Card0"
    69      Monitor    "Monitor0"
    70      DefaultDepth 24
    71      SubSection "Display"
    72          Depth     16
    73          Modes "1280x1024" "1024x768" "800x600"
    74      EndSubSection
    75      SubSection "Display"
    76          Depth     24
    77          Modes "1280x1024" "1024x768" "800x600"
    78      EndSubSection
    79  EndSection
\end{MyEx}
\end{MyExample}
\end{shaded}

เซกชันละส่วนจะเริ่มต้นด้วยคำว่า Section และลงท้ายด้วยคำว่า EndSection. ทุกเซกชันจะมีค่า Identifier กำหนดชื่อเฉพาะของแต่ละเซกชัน. ในแต่ละเซกชันสามารถมีเซกชันย่อยแยกออกไปอีกเป็นซับเซกชัน (subsection). ส่วนที่เป็นซับเซกชันจะเริ่มต้นด้วยคีย์เวิร์ด SubSection และจบด้วย EndSubSection.

ในเซกชันหนึ่งๆจะมีชื่อคุณสมบัติและค่าที่ต้องการเซ็ต. ชื่อคุณสมบัติสำหรับแต่ละเซกชันเหล่านี้อธิบายอยู่ใน \cmd{man 5 xorg.conf} (\cmd{XF86Config}) ว่ามีอะไรบ้างและอธิบายประเภทของคุณสมบัติต่างๆว่าต้องเป็นสายอักขระหรือตัวเลข ฯลฯ.

\subsection{เซกชัน ServerLayout}
เซกชัน ServerLayout เป็นช่วงนิยามโครงสร้างส่วนประกอบของ X เซิร์ฟเวอร์และสามารถมีได้มากกว่าหนึ่งส่วน. ปรกติจะมี ServerLayout เดียวเท่านั้น.
\begin{itemize}
\item Identifier ``\textit{name}''\\
ใช้กำหนดชื่อเฉพาะสำหรับแยกแยะเซกชัน.
\item Screen ``\textit{screenid}''\\
ระบุชื่อสกรีนที่ต้องการใช้แสดงผล. สามารถตั้งค่าได้มากกว่าหนึ่งตัวในกรณีที่ต้องการแสดงผลหลายสกรีนและฮาร์ดแวร์รองรับ. ในตัวอย่างบอกให้เซิร์ฟเวอร์ใช้สกรีนที่มีชื่อ (Identifier) เป็น ``Screen0''.
\item InputDevice ``\textit{input-dev-id}'' ``\textit{option}''\\
ระบุดีไวซ์สำหรับข้อมูลนำเข้าเช่นแป้นพิมพ์และเมาส์.
\end{itemize}
ในเซกชันนี้อย่างน้อยต้องกำหนดข้อคุณสมบัติ Identifier และ Screen เพื่อให้ X วินโดว์ทำงานได้.

\subsection{เซกชัน Files}\label{sec:x-files-section}
เป็นช่วงที่ระบุชื่อไดเรกทอรีหรือไฟล์พาทเกี่ยวฐานข้อมูลต่างๆเช่นไฟล์ฐานข้อมูลสี, ไดเรกทอรีที่เก็บฟอนต์ หรือ ไดเรกทอรีที่เก็บโมดูลของ X เซิร์ฟเวอร์. ค่าของพาทที่ระบุในที่นี้สามารถระบุเปลี่ยนได้จากตัวเลือกเวลารันโปรแกรม X เซิร์ฟเวอร์.
\begin{itemize}
\item RgbPath ``\textit{rgb-file}''\\
ระบุชื่อไฟล์ฐานข้อมูลสี. ในตัวอย่างได้แก่ไฟล์ \cmd{/usr/X11R6/lib/X11/rgb.txt} ซึ่งละเว้นส่วนขยายชื่อไฟล์ได้.
\item ModulePath ``\textit{path}''\\
ชื่อไดเรกทอรีที่เก็บไฟล์โมดูลสำหรับ X เซิร์ฟเวอร์. X เซิร์ฟเวอร์สามารถขยายความสามารถเพิ่มเติมโดยอาศัยการโหลดไฟล์โมดูลซึ่งแยกคอมไพล์ต่างหากกับ X เซิร์ฟเวอร์. การเลือกใช้โมดูลจะระบุในเซกชัน Module ภายหลัง.
\item FontPath ``\textit{path}''\\
ค่านี้สามารถเปลี่ยนโดยตัวเลือก \cmd{-fp} ของ X เซิร์ฟเวอร์เวลารัน. ในตัวอย่างระบุไดเรกทอรีที่เก็บไฟล์ฟอนต์ซึ่งเป็นการบอกให้เซิร์ฟเวอร์รู้ว่าฟอนต์อยู่ที่ไหน. ในกรณีที่ใช้ฟอนต์เซิร์ฟเวอร์\mymemo{ฟอนต์เซิร์ฟเวอร์, ดูหน้า \pageref{sec:xfs}.}, จะระบุฟอนต์เซิร์ฟเวอร์แทนชื่อไดเรกทอรี.
\end{itemize}

\subsection{เซกชัน Module}
ในเซกชันนี้จะระบุโมดูลที่ต้องการโหลดใช้กับ X เซิร์ฟเวอร์.
\begin{itemize}
\item Load ``\textit{module}''\\
ระบุชื่อโมดูลที่ต้องการใช้เช่น
\begin{itemize}
\item extmod เป็นโมดูลเพิ่มความสามารถพิเศษหลายอย่างให้กับเซิร์ฟเวอร์.
\item dri (Direct Rendering Infrastructure)\gindex{dri|see{Direct Rendering Infrastructure}}\gindex{direct rendering infrastructure@Direct Rendering Infrastructure} เป็นโมดูลสำหรับเพิ่มความสามารถใช้เซิร์ฟเวอร์เข้าถึงฮาร์ดแวร์กราฟิกได้โดยตรง, ช่วยการแสดงผลด้านสามมิติ (3D).
\item dbe (Double Buffer Extension)\gindex{dbe|see{Double Buffer Extension}}\gindex{double buffer extension@Double Buffer Extension} โมดูลเพิ่มความสามารถช่วยในการแสดงผลภาพเคลื่อนไหวไม่ให้กระพริบไม่ลื่น.
\item record, xtrap โมดูลเพิ่มความสามารถการบันทึกจับโปรโตคอลของ X วินโดว์และอิเวนต์ต่างๆ.
\item glx (OpenGL Extension) โมดูลเพิ่มความสามารถ OpenGL.%
\myvocab{o}{OpenGL}{ย่อมาจาก Open Graphics Library เป็นไลบรารี (ซอฟต์แวร์) อินเทอร์เฟสสำหรับฮาร์ดแวร์กราฟิก, ใช้ในการสร้างภาพสามมิติคุณภาพสูงและเป็นมาตรฐานสากล.}%
\item speedo, type1, freetype โมดูลเพิ่มความสามารถเกี่ยวกับการใช้ฟอนต์แบบเวกเตอร์กับ X เซิร์ฟเวอร์.
\end{itemize}
\end{itemize}
หลังจากที่ X เซิร์ฟเวอร์ทำงานแล้วสามารถดูข้อมูลรายละเอียดเกี่ยวกับโมดูลต่างได้ด้วยคำสั่ง \cmd{xdpyinfo}\cindex{xdpyinfo} กับตัวเลือก \cmd{-queryExtensions} หรือ \cmd{-ext all}.


\subsection{เซกชัน InputDevices}
เซกชัน InputDevices เป็นช่วงสำหรับตั้งค่าต่างสำหรับแป้นพิมพ์และเมาส์.
\begin{itemize}
\item Identifier ``\textit{name}''\\
ชื่อเฉพาะใช้แยกแยะเซกชัน.
\item Driver ``kbd | mouse''\\
ระบุประเภทของดีไวซ์ข้อมูลนำเข้าว่าเป็นแป้นพิมพ์หรือพอยเตอร์ (เมาส์).
\item Option ``\textit{\textit{name}}'' ``\textit{value}''\\
ตัวเลือกและค่าต่างๆของดีไวซ์. ตัวเลือกของดีไวซ์ยังแบ่งเป็นตัวเลือกสำหรับแป้นพิมพ์ใช้ระบุประเภทและคุณลักษณะของแป้นพิมพ์, และตัวเลือกสำหรับเมาส์ใช้ระบุจำนวนปุ่ม, ชื่อไฟล์ดีไวซ์ ฯลฯ.
\begin{itemize}
\item ``XkbModel'' ``\textit{model}''\\
ระบุประเภทแป้นพิมพ์เช่น pc101 หมายถึงแป้นพิมพ์ประเภทคอมพิวเตอร์ส่วนบุคคลที่มีจำนวนคีย์ 101 คีย์.
\item ``XkbLayout'' ``\textit{layout}''\label{sec:thkb}\\
ระบุผังของแป้นพิมพ์, ภาษาที่ใช้กับแป้นพิมพ์. ตัวอย่างเช่น ``us,th'' เป็นการระบุการใช้แป้นพิมพ์ภาษาอังกฤษ (อเมริกัน) ร่วมกับแป้นพิมพ์ภาษาไทยโดยมีแป้นพิมพ์ภาษาอังกฤษเป็นแป้นพิมพ์หลัก (กลุ่มที่หนึ่ง) และแป้นพิมพ์ภาษาไทยเป็นแป้นพิมพ์รอง (กลุ่มที่สอง). ในกรณีที่ต้องการใช้แป้นพิมพ์มากกว่าสองภาษาสามารถเพิ่มต่อไปได้เรื่อยๆโดยการเขียนชื่อภาษาของแป้นพิมพ์แล้วคั่นด้วยเครื่องหมายลูกน้ำ. ชื่อผังแป้นพิมพ์ของภาษาต่างๆสามารถดูได้จากไฟล์ \cmd{/usr/lib/X11/xkb/rules/xorg.lst}\findex{xorg.lst}.

สำหรับการตั้งผังแป้นพิมพ์ภาษาไทยสามารถ\gindex{แป้นพิมพ์!ภาษาไทย}เลือกได้ 3 แบบได้แก่
\begin{enumerate}
\item \emph{ผังแป้นพิมพ์เกษมณี (Kedmanee)}\gindex{แป้นพิมพ์!เกษมณี}\gindex{ketmanee@Ketmanee|see{Kedmanee}}\gindex{kedmanee@Kedmanee}\mymemo{บ้างก็สะกดว่า Ketmanee ตามนามสกุลผู้คิดออกแบบผังแป้นพิมพ์ คุณสุวรรณประเสริฐ เกษมณี \cite{keyboard}.} (รูปที่ \ref{fig:kedmanee}) เป็นแป้นพิมพ์ดั้งเดิมที่ใช้กันทั่วไปในเครื่องพิมพ์ดีดและคอมพิวเตอร์ส่วนบุคคล. ปรับแต่งใช้แป้นพิมพ์ประเภทนี้โดยระบุคำว่า ``th''\gindex{th}.
\item \emph{ผังแป้นพิมพ์ปัตตะโชติ (Pattachote)}\gindex{แป้นพิมพ์!ปัตตะโชติ}\gindex{pattachote@Pattachote}\gindex{pattajoti@Pattajoti|see{Pattachote}}\mymemo{บ้างก็สะกดว่า Pattajoti ตามนามสกุลผู้คิดออกแบบผังแป้นพิมพ์.} (รูปที่ \ref{fig:pattachote}) เป็นแป้นพิมพ์ที่วิจัยและออกแบบโดยคุณสฤษดิ์ ปัตตะโชติ. แป้นพิมพ์ออกแบบให้การใช้งานของมือทั้งสองใช้งานพอๆกัน, ตำแหน่งคีย์ที่ใช้งานหนักจะอยู่ตรงกับนิ้วที่มีแรงมาก, และการเคลื่อนไหวของมือจะน้อยกว่าแป้นพิมพ์เกษมณี \cite{keyboard}.  ปรับแต่งใช้แป้นพิมพ์ประเภทนี้โดยระบุคำว่า ``th\_pat''\gindex{th\_pat}.
\item \emph{ผังแป้นพิมพ์ มอก. 820 (TIS-820.2538)}\gindex{แป้นพิมพ์!มอก. 820}\gindex{tis-820.2538@TIS-820.2538} (รูปที่ \ref{fig:tis-820}) เป็นแป้นพิมพ์มาตรฐานที่กำหนดโดยสำนักงานมาตรฐานผลิตภัณฑ์อุตสาหกรรม \cite{tis820} โดยพัฒนาต่อจากแป้นพิมพ์เกษมณีแต่สามารถพิมพ์เครื่องหมายพิเศษได้แก่ ๏ (ฟองมัน), ๛ (โคมูตร), ~๎ (ยามักการ) และ ๚ (อังคั่นคู่) ได้ด้วย. ตำแหน่งของเครื่องหมายอังคั่นคู่ไม่ได้กำหนดไว้ในมาตรฐาน มอก. ตายตัว. ในระบบ XKB การพิมพ์อังคั่นคู่จะใช้คีย์เลือกระดับที่สาม (third level chooser) ช่วยซึ่งระบุด้วยตัวเลือก XkbOptions. คีย์ที่ใช้พิมพ์อังคั่นคู่ถูกกำหนดไว้อยู่ในตำแหน่งของตัวอักษรภาษาอังกฤษ ``o''. ปรับแต่งใช้แป้นพิมพ์ประเภทนี้โดยระบุคำว่า ``th\_tis''\gindex{th\_tis}.
\end{enumerate}
\begin{figure}[!hp]
\plfigurelongodd{.9}{kedmanee.eps}{แป้นพิมพ์เกษมณี (Kedmanee).}{kedmanee}
\end{figure}
\begin{figure}[!hp]
\plfigurelongodd{.9}{pattachote.eps}{แป้นพิมพ์ปัตตโชติ (Pattachote).}{pattachote}
\end{figure}
\begin{figure}[!hp]
\plfigurelongodd{.9}{tis-820.2538.eps}{แป้นพิมพ์สมอ 820 (tis-820.2538).}{tis-820}
\end{figure}
\item ``XkbOptions'' ``\textit{option,option,...}''\\
ค่าตัวเลือกของ XKB มีหลายตัวขึ้นอยู่กับประเภทการปรับแต่งได้แก่.
\begin{itemize}
\item grp:\textit{name} \\
สำหรับระบุคีย์ที่ใช้เปลี่ยนกลุ่มของแป้นพิมพ์ (ภาษาที่ใช้กับแป้นพิมพ์) เช่น grp:alt\_shift\_toggle เป็นการระบุสลับแป้นพิมพ์ด้วยการกดคีย์ \cmd{Alt+Shift}.
\item lv3:\textit{name} \\
สำหรับกำหนดคีย์ที่ใช้เลือกระดับที่ 3 (third level chooser). โดยปรกติแป้นพิมพ์ในแต่ละกลุ่มสามารถป้อนข้อมูลอักขระได้สองระดับคือการกด \cmd{Shift} และไม่กด \cmd{Shift}. ในกรณีที่อักขระมีมากและไม่สามารถได้หมดสามารถใช้คีย์เลือกระดับที่สามช่วยได้. ตัวอย่างเช่นแป้นพิมพ์ภาษาไทยแบบ มอก. 820 จะใช้คีย์เลือกระดับที่สามในการพิมพ์เครื่องหมายอังคั่นคู่ (๚) โดยการกดคีย์เลือกระดับที่สามค้างไว้และกดคีย์ ``o''. เช่น lv3:ralt\_switch จะใช้คีย์ \cmd{Alt} ที่อยู่ทางขวามือเป็นคีย์เลือกระดับที่สาม.
\item ctrl:\textit{name} \\
สำหรับปรับพฤติกรรมของคีย์ \cmd{Ctrl} เช่นใช้สลับเปลี่ยนตำแหน่งคีย์ \cmd{Caps Lock} และ \cmd{Ctrl} (ctrl:swapcaps), ตั้งค่าไม่ใช้คีย์ \cmd{Caps Lock} (ctrl:nocaps) เป็นต้น.
\item grp\_led:\textit{name}\\
ระบุใช้ไฟ LED (Light Emitting Diode) เป็นตัวบอกว่ามีสลับเปลี่ยนกลุ่มแป้นพิมพ์. เช่นค่า grp\_led:scroll จะใช้ไฟ LED ของ Scroll lock เป็นตัวบอกสภาพกลุ่มของแป้นพิมพ์.
\end{itemize}
\item ``Protocol'' ``\textit{protocol}''\\
ระบุโปรโตคอลของเมาส์ที่ใช้. ค่าทั่วไปได้แก่ ``Auto'' ซึ่งให้เซิร์ฟเวอร์จัดการโดยอัตโนมัติ. แต่ถ้าไม่สามารถเลื่อนพอยเตอร์ได้ต้องระบุเจาะจงเช่น ``PS/2'' สำหรับเมาส์ธรรมดาที่ต่อกับพอร์ต PS/2, ``IMPS/2'' สำหรับเมาส์ \emph{IntelliMouse}\gindex{intellimouse@IntelliMouse} ที่ต่อกับพอร์ต PS/2 หรือ USB. เมาส์แบบ IntelliMouse คือเมาส์ที่มีล้อ (wheel) ตรงกลางเลื่อนขึ้นลงหรือกดได้.
\item ``Device'' ``\textit{device}''\\
ระบุไฟล์ดีไวซ์ของเมาส์ที่ใช้. ไฟล์ดีไวซ์โดยทั่วไปได้แก่ไฟล์
\begin{itemize}
\item \cmd{/dev/psaux} สำหรับเมาส์ที่ต่อกับพอร์ต PS/2.
\item \cmd{/dev/mouse} มักจะเป็นซิมโบลิกลิงก์ไปหาไฟล์ดีไวซ์ตัวจริง.
\item \cmd{/dev/input/mice} สำหรับเมาส์ที่ต่อกับพอร์ต USB.
\item \cmd{/dev/input/mouse0} สำหรับเมาส์ที่ต่อกับพอร์ต USB.
\item \cmd{/dev/ttyS0} สำหรับเมาส์ที่ต่อกับพอร์ตซีเรียล (serial).
\end{itemize}
วิธีทดสอบว่าเมาส์ที่ใช้ต่อกับไฟล์ดีไวซ์ไหนอาจจะตรวจสอบได้โดยการใช้คำสั่ง \cmd{cat} อ่านไฟล์ดีไวซ์นั้น, แล้วเลื่อนเมาส์ไปมา. ถ้ามีปฏิกริยาโต้ตอบทางหน้าจอแสดงว่าเป็นไฟล์ดีไวซ์นั้น.
\item ``Buttons'' ``\textit{number}''\\
ระบุจำนวนปุ่มของเมาส์ที่ใช้.
\item ``ZAxisMapping'' ``\textit{value}''\\
สำหรับเมาส์ที่มีล้อหมุนเช่นกรณีเมาส์ที่มีสองปุ่มและล้อหมุนหนึ่งอันจะถือว่ามีปุ่มทั้งหมด 5 ปุ่ม. เวลาหมุนล้อขึ้นข้างบนจะเป็นปุ่มที่ 4 และหมุนล้อลงจะเป็นปุ่มที่ 5. ตัวเลือก XAxisMapping จะจับคู่การหมุนล้อให้เข้ากับการเลื่อนเนื้อหาของหน้าต่างขึ้นลง (scroll) ตามที่ต้องการ. ตัวอย่างเช่น ZAxisMappin ``4 5'' ถ้าหมุนล้อไปข้างหน้า (ปุ่มที่ 4) จะเลื่อนหน้าต่างขึ้น (scroll up), ถ้าหมุนล้อไปข้างหลัง (ปุ่มที่ 5) จะเลื่อนหน้าต่างลงเป็นต้น. เมาส์ที่มีจำนวนปุ่มมากกว่า 5 ปุ่มจะมีการปรับแต่งที่แตกต่างจากนี้, สามารถอ่านรายละเอียดได้จากเอกสารการรองรับการใช้งานเมาส์ของ X11R6.8.1 \cite{mouse}.
\end{itemize}
\end{itemize}


\subsection{เซกชัน Monitor}
เป็นเซกชันสำหรับปรับแต่งจอภาพแสดงผล. ถ้าโปรแกรม \cmd{xorgcfg} ตั้งค่าให้โดยอัตโนมัติและใช้งานก็ใช้ค่าที่ตั้งให้ได้เลย. แต่ถ้ามีความจำเป็นต้องปรับค่าเองควรจะหาคู่มือของจอภาพเพื่อรวบรวมข้อมูลต่างๆ.
\begin{itemize}
\item VendorName ``\textit{vendor}''\\
ชื่อของบริษัทผู้ผลิตจอภาพ. ค่านี้เป็นตัวเลือกไม่ระบุก็ได้.
\item ModelName ``\textit{model}''\\
ชื่อรุ่นของจอภาพ. ค่านี้เป็นตัวเลือกไม่ระบุก็ได้เช่นกัน.
\item HorizSync \textit{horizsync-range}\\
ค่าช่วงความถี่ของจอภาพตามแนวนอนในหน่วยกโลเฮิร์ต (kHz) โดยปริยาย. ค่านี้สามารถดูได้จากคู่มือของจอภาพหรือด้านหลังจอภาพอาจจะมีเขียนบอกไว้. ถ้าไม่ระบุคุณสมบัตินี้จะใช้ค่าเป็น 28-33 kHz โดยปริยาย.
\item VertRefresh \textit{vertrefresh-range}\\
ค่าช่วงความถี่ของจอภาพตามแนวตั้งในหน่วยเฮิร์ต (Hz) โดยปริยาย. ถ้าไม่ระบุคุณสมบัตินี้จะใช้ค่าเป็น 43-72 Hz โดยปริยาย.
\item DisplaySize \textit{width} \textit{height}\\
ขนาดความกว้างและความสูงของของภาพในหน่วยมิลลิเมตร. X เซิร์ฟเวอร์สามารถใช้ค่านี้ในการคำนวณความละเอียด DPI (Dot Per Inch) ของหน้าจอได้.
\end{itemize}
ค่าคุณสมบัติอื่นๆที่สำคัญๆได้แก่ Mode และ ModeLine ซึ่งใช้ปรับแต่งจอภาพโดยละเอียดยุ่งยากซับซ้อน. สำหรับจอภาพมาตรฐานโดยทั่วไปแล้วไม่จำเป็นต้องใช้ก็ได้. ถ้ามีความจำเป็นต้องใช้อาจจะใช้โปรแกรม \cmd{xvidtune}\cindex{xvidtune} ช่วยปรับแต่งและสร้างค่า ModeLine ให้ได้. แต่มีข้อควรระวังคือโปรแกรมที่อาจจะทำให้วิดีโอการ์ดหรือจอภาพเสียหายได้.
\begin{figure}[!htb]
\plfigure{.6}{xvidtune.eps}{โปรแกรมช่วยปรับแต่งจอภาพ X เซิร์ฟเวอร์.}{xvidtune}
\end{figure}

\subsection{เซกชัน Device}
เซกชันนี้เป็นการกำหนดค่าคุณสัมบัติต่างๆของวิดีโอการ์ด. ค่าคุณสัมบัติที่จำเป็นต้องมีในเซกชันนี้ได้แก่ Identifier และ Driver.
\begin{itemize}
\item Driver ``\textit{name}''\\
ระบุชื่อไดร์เวอร์ของวิดีโอการ์ดเช่น nv (nVidia), ati, i740 (Intel), i810 (Intel) เป็นต้น. โดยปรกติโปรแกรมช่วยสร้างไฟล์ \cmd{xconf.org} จะเขียนค่าเหล่านี้ให้. สำหรับผู้ใช้ต้องรู้ว่ากราฟิกการ์ดที่ตัวเองใช้มียี่ห้ออะไรรุ่นอะไรเป็นอย่างน้อย.
\end{itemize}
ค่าคุณสมบัติอื่นๆอ่านได้จาก\cmd{man xorg.conf} และตัวเลือกเฉพาะของแต่ละไดร์เวอร์อ่านได้จากเอกสารของ X11R6 ทางเว็บไซด์.
\subsection{เซกชัน Screen}
เซกชันนี้เป็นส่วนสำคัญรวมนิยามส่วนประกอบต่างๆของ X เซิร์ฟเวอร์เข้าด้วยกันได้แก่
\begin{itemize}
\item Device ``\textit{device-id}''\\
ชื่อดีไวซ์ที่ตั้งไว้ในเซกชัน Device.
\item Monitor ``\textit{monitor-id}''\\
ชื่อจอภาพที่ตั้งไว้ในเซกชัน Monitor.
\item DefaultDepth \textit{depth}\\
ระบุความลึกของสีโดยปริยายในกรณีที่มีปรับแต่งให้ใช้ความลึกของสีได้หลายค่า. ความลึกของสีคือจำนวนบิตที่ใช้แสดงสีได้แก่ 8, 16, 24 หรือ 32 บิต.
\end{itemize}
ในเซกชันนี้สามารถแบ่งออกเป็นซับเซกชันชื่อ Display ได้อีกใช้ระบุว่ารายละเอียดของหน้าจอว่ามีความลึกของสีเท่าไร, มีความละเอียดของหน้าจอเป็นอย่างไร.
\begin{itemize}
\item Depth \textit{depth}\\
ความลึกของสีในซับเซกชัน.
\item Modes ``res1'' ``res2'' ...\\
ความละเอีดดของหน้าจอในหน่วยพิกเซลเช่น 1280x1024, 1024x768 เป็นต้น. การเปลี่ยนความละเอียดหน้าจอหลังขณะใช้ X วินโดว์ทำได้โดยกดคีย์ \cmd{Ctrl+Alt} และเครื่องหมาย \cmd{+} หรือ \cmd{-}.
\end{itemize}

\subsection{เซกชัน ServerFlags}
เซกชันนี้เป็นเซกชันไม่บังคับ, ใช้ปรับแต่งคุณสมบัติโดยรวมของเซิร์ฟเวอร์. คุณสมบัติที่อยู่ในเซกชันนี้จะเป็นตัวเลือกทั้งหมด. ตัวเลือกที่น่าสนใจได้แก่.
\begin{itemize}
\item{Option ``DontVTSwitch'' ``on | off''}\\
ปรกติเราสามารถเปลี่ยนเทอร์มินอลเสมือนได้ด้วยการกดคีย์ \cmd{Ctrl+Alt+Fn} โดยที่ \cmd{Fn} คือคีย์ฟังก์ชัน \cmd{F1}, \cmd{F2}, ฯลฯ. ตัวเลือก DontVTSwitch สามารถบังคับให้ผู้ใช้ไม่สามารถเปลี่ยนเทอร์มินอลเสมือนโดยการตั้งค่าเป็น ``on''.
\item{Option ``DontZap'' ``on | off''}\\
ถ้าตั้งค่าเป็น ``on'' จะทำให้ผู้ใช้ไม่สามารถกดคีย์ \cmd{Ctrl+Alt+Backspace} เพื่อจบการทำงานของ X เซิร์ฟเวอร์.
\end{itemize}
ตัวเลือกอื่นๆในช่วง ServerFlags สามารถอ่านได้จาก \cmd{man xorg.conf}.

\section{X เซิร์ฟเวอร์}
%X เซิร์ฟเวอร์คือโปรแกรมที่ใช้แสดงผลกราฟิกสำหรับระบบปฏิบัติการตระกูลยูนิกซ์.
โปรแกรม X เซิร์ฟเวอร์ที่ใช้กันทั่วไปคือโปรแกรมที่มีชื่อว่า \cmd{X} ซึ่งจะแสดงผลกราฟิกทางหน้าจอและใช้เทอร์มินอลเสมือนที่อยู่ในตำแหน่งฟังก์ชันคีย์ \cmd{F7} (รูปประกอบหน้า \pageref{fig:virtual_terminal}). ในระบบสามารถรัน X เซิร์ฟเวอร์ได้มากกว่าหนึ่งโปรเซส. โดยปรกติ X เซิร์ฟเวอร์ตัวแรกจะมีชื่อหน้าจอเป็น \cmd{:0}. X เซิร์ฟเวอร์ตัวถัดไปสามารถใช้ชื่อหน้าจออะไรก็ได้ที่มีชื่อไม่ซ้ำกันและผู้ใช้สามารถสลับเปลี่ยนหน้าจอโดยใช้คีย์ \cmd{Ctrl+Alt+F\textit{n}} โดยที่ \cmd{F\textit{n}} คือฟังชันคีย์ตั้งแต่ 7 เป็นต้นไป.

ในระบบที่มี X วินโดว์ทำงานอยู่แล้วและต้องการรัน X เซิร์ฟเวอร์เพิ่มสามารถสั่งคำสั่ง \cmd{X \textit{display-name}} โดยระบุชื่อหน้าจอที่ไม่ซ้ำกับหน้าจอที่มีอยู่.
\begin{MyExample}[รัน X เซิร์ฟเวอร์เพิ่มจากที่มีอยู่.]
\begin{MyEx}
$ \cin{X :1}
\end{MyEx}
\end{MyExample}%$

จากตัวอย่างเป็นการระบุชื่อหน้าจอ \cmd{:1} ให้เป็นหน้าจอสำหรับ X เซิร์ฟเวอร์ตัวใหม่. หน้าจอของ X เซิร์ฟเวอร์ตัวใหม่จะมีแค่รูทวินโดว์เท่านั้น, ไม่มีประโยชน์สำหรับการใช้งานจริง. ในกรณีที่ต้องการใช้งานจริงให้ใช้คำสั่ง \cmd{startx} แทน. ในกรณีนี้ให้แน่ใจว่ามีไฟล์ตั้งค่าเริ่มต้นเช่น \cmd{\~{}/.xinitrc} ถูกต้อง\mymemo{เกี่ยวกับไฟล์ \cmd{\~{}/.xinitrc} ดูที่หน้า \pageref{sec:.xinitrc}.}.
\begin{MyExample}[รัน X เซิร์ฟเวอร์เพิ่มจากที่มีอยู่โดยใช้คำสั่ง \cmd{startx}.]
\begin{MyEx}
$ \cin{startx -- :1}
\end{MyEx}
\end{MyExample}%$



\section{การเริ่มต้น X เซิร์ฟเวอร์}
การเริ่มทำงานของ X เซิร์ฟเวอร์แบ่งออกกว้างๆได้สองแบบคือสั่งทำงานจากเชลล์และสั่งเริ่มทำงานโดยใช้\emph{ดิสเพลยแมนเนเจอร์ (display manager)}.
\subsection{เริ่มต้น X เซิร์ฟเวอร์จากบรรทัดคำสั่ง}
การเริ่มต้น X เซิร์ฟเวอร์จากบรรทัดคำสั่งหมายถึงการสั่งคำสั่งที่รัน X เซิร์ฟเวอร์จากเชลล์ไม่ว่าจะอยู่ในเท็กซ์โหมดหรือกราฟิกโหมด. โดยปรกติมักจะกระทำเวลาอยู่ในเท็กซ์โหมดเมื่อต้องการใช้ระบบ X วินโดว์. เช่นหลังจากที่สร้างไฟล์เริ่มต้นของ X เซิร์ฟเวอร์แล้วต้องการทดสอบเป็นต้น. นอกจากนั้น, เรายังสามารถรัน X เซิร์ฟเวอร์ในขณะที่มี X เซิร์ฟเวอร์ทำงานอยู่แล้ว (กราฟิก) ก็ได้. ในกรณีที่มี X เซิร์ฟเวอร์ทำงานอยู่แล้วต้องระบุให้เซิร์ฟเวอร์ใช้หน้าจอที่ไม่ซ้ำกับเซิร์ฟเวอร์ที่ทำงานอยู่.

คำสั่งทั่วไปที่ใช้เริ่มต้นการทำงานในระบบ X วินโดว์ได้แก่ \cmd{startx}\cindex{startx}. คำสั่ง \cmd{startx}\refcmd{startx} เป็นเชลล์สคริปต์ที่จะตั้งค่าตัวแปรและเตรียมการเรียกสั่งคำสั่ง \cmd{xinit}\cindex{xinit} ซึ่งเป็นโปรแกรมเริ่มต้น X เซิร์ฟเวอร์ต่อไป. โดยปรกติจะสั่งคำสั่ง \cmd{startx} โดยไม่มีตัวเลือกเพื่อเปลี่ยนการทำงานจากเท็กซ์โหมดเข้าสู่ระบบ X วินโดว์.

คำสั่ง \cmd{startx} จะเรียกใช้คำสั่ง \cmd{xinit} ซึ่งเป็นโปรแกรมเริ่มต้น X เซิร์ฟเวอร์. และคำสั่ง \cmd{xinit} มีไฟล์ตั้งค่าเริ่มต้นได้แก่ไฟล์ \cmd{/etc/X11/xinit/xinitrc}\mycomment{เนื้อหาของไฟล์ในแต่ละดิสโทรอาจแตกต่างกัน.} และจะอ่านไฟล์นี้เหมือนเชลล์สคริปต์ทั่วไป. ถ้าในโฮมไดเรกทอรีของผู้สั่งคำสั่ง \cmd{startx} หรือ \cmd{xinit} มีไฟล์ \cmd{\~{}/.xinitrc}\gindex{.xinitrc@ไฟล์ \cmd{.xinitrc}} ก็จะรันคำสั่งที่อยู่ในไฟล์นั้น.

คำสั่ง \cmd{startx} เป็นอินเทอร์เฟสสำหรับคำสั่ง \cmd{xinit} ช่วยสร้าง\emph{เซสชัน (session)} และอำนวยความสะดวกต่างๆสำหรับรันโปรแกรม \cmd{xinit}. ดังนั้นถ้าต้องการเริ่มต้นระบบ X วินโดว์จากบรรทัดคำสั่ง, ให้ใช้คำสั่ง \cmd{startx} ดีกว่าการใช้คำสั่ง \cmd{xinit} โดยตรง. ตัวอย่างต่อไปนี้ตัวอย่างไฟล์ \cmd{xinitrc} ซึ่งเป็นเชลล์สคริปต์รันโปรแกรมต่างๆที่ต้องการหลังจากเริ่มระบบ X วินโดว์. ไฟล์นี้จะถูกอ่านไม่ว่าจะเริ่มต้นระบบ X วินโดว์ด้วย \cmd{startx} หรือ \cmd{xinit} ก็ตาม.

\begin{MyExample}[ไฟล์ \cmd{xinitrc}]\label{ex:xinitrc}
\begin{MyEx}
$ \cin{cat -n /etc/X11/xinit/xinitrc}
     1  #!/bin/sh
     2  # $Xorg: xinitrc.cpp,v 1.3 2000/08/17 19:54:30 cpqbld Exp $
     3
     4  userresources=$HOME/.Xresources
     5  usermodmap=$HOME/.Xmodmap
     6  xinitdir=/usr/X11R6/lib/X11/xinit
     7  sysresources=$xinitdir/.Xresources
     8  sysmodmap=$xinitdir/.Xmodmap
     9
    10  # merge in defaults and keymaps
    11
    12  if [ -f $sysresources ]; then
    13      xrdb -merge $sysresources \mycomment{ตั้งค่าทรัพยากรจากฐานข้อมูล}
    14  fi
    15
    16  if [ -f $sysmodmap ]; then
    17      xmodmap $sysmodmap \mycomment{ปรับแต่งคีย์ของแป้นพิมพ์}
    18  fi
    19
    20  if [ -f $userresources ]; then
    21      xrdb -merge $userresources \mycomment{ตั้งค่าทรัพยากรจากฐานข้อมูล}
    22  fi
    23
    24  if [ -f $usermodmap ]; then
    25      xmodmap $usermodmap \mycomment{ปรับแต่งคีย์ของแป้นพิมพ์}
    26  fi
    27
    28  # First try ~/.xinitrc
    29  if [ -f "$HOME/.xinitrc" ]; then \mycomment{ถ้ามีไฟล์ \cmd{~/.xinitrc}}
    30          XINITRC="$HOME/.xinitrc"
    31          exec /bin/sh "$HOME/.xinitrc" \mycomment{เปลี่ยนโปรเซสที่กระทำการ}
    32  # If not present, try the system default
    33  elif [ -n "`/etc/X11/chooser.sh`" ]; then
    34          exec "`/etc/X11/chooser.sh`"
    35  # Failsafe
    36  else
    37          # start some nice programs
    38          twm &
    39          xclock -geometry 50x50-1+1 &
    40          xterm -geometry 80x50+494+51 &
    41          xterm -geometry 80x20+494-0 &
    42          exec xterm -geometry 80x66+0+0 -name login
    43  fi
\end{MyEx}
\end{MyExample}

ไฟล์ \cmd{xinitrc} ของระบบตามตัวอย่างที่ \ref{ex:xinitrc} ในช่วงแรกเป็นการใช้คำสั่ง \cmd{xrdb} เพื่อตั้งค่าทรัพยากรต่างๆ, สั่งคำสั่ง \cmd{xmodmap}\cindex{xmodmap} เพื่อปรับแต่งคีย์ต่างๆของแป้นพิมพ์. ช่วงสุดท้ายจะตรวจสอบดูว่าในโฮมไดเรกทอรีมีไฟล์ \cmd{.xinitrc} หรือไม่. ถ้ามีก็จะใช้คำสั่ง \cmd{exec}\cindex{exec} ซึ่งเป็นคำสั่งประกอบภายในเชลล์เปลี่ยนโปรเซสเชลล์ที่ทำงานอยู่ไปเป็นโปรเซสของโปรแกรมที่ต้องการรัน. กล่าวคือหลังจากที่รันคำสั่งนั้นแล้วจะไม่กลับมารันโปรแกรมบรรทัดถัดไปอีก. ตัวอย่างเช่นบรรทัดที่ 31, เมื่อรันคำสั่ง \cmd{exec /bin/sh "\$HOME/.xinitrc"} แล้วโปรเซสที่ทำงานอยู่จะเปลี่ยนเป็นโปรเซสของ \cmd{/bin/sh} ที่สั่งไป, และไม่กลับมารันคำสั่งที่อยู่ในบรรทัดถัดจากบรรทัดที่ 31 อีกต่อไป.

ถ้าไม่มีไฟล์ \cmd{.xinitrc} ในโฮมไดเรกทอรีก็จะตรวจสอบว่ามีไฟล์ \cmd{/etc/X11/chooser.sh}\mymemo{ขั้นตอนเหล่านี้อาจจะไม่เหมือนกันทุกประการ, แล้วแต่ดิสโทรที่ใช้.} หรือไม่. ถ้ามีไฟล์นี้ก็จะรันโปรแกรมต่างๆในไฟล์นี้. สุดท้ายถ้าไม่มีไฟล์อะไรเลยก็จะรัน \cmd{twm}, \cmd{xclock} และ \cmd{xterm} เป็นโปรแกรมเริ่มต้น.

\medskip
ให้สังเกตุว่าการรันโปรแกรมต่างๆจะรันแบบแบ็กกราวน์และโปรแกรมที่รันตัวสุดท้าย (ในตัวอย่างเช่น \cmd{xterm -geometry 80x66+0+0 -name login}) จะรันแบบฟอร์กราวน์และใช้คำสั่งประกอบภายในเชลล์ \cmd{exec} รัน. ถ้าโปรแกรมที่รันตัวสุดท้ายจบการทำงาน, X เซิร์ฟเวอร์ก็จะจบการทำงานกลับสู่สภาพก่อนรันคำสั่ง \cmd{startx} หรือ \cmd{xinit}. ถ้าโปรแกรมตัวสุดท้ายทำงานแบบแบ็กกราวน์, X เซิร์ฟเวอร์จะจบการทำงานทันทีเหมือนไม่มีอะไรเกิดขึ้น.

\subsubsection{ไฟล์ \cmd{\~{}/.xinitrc}}\label{sec:.xinitrc}
ไฟล์ \cmd{\~{}/.xinitrc}\gindex{.xinitrc@ไฟล์ .xinitrc} ก็รูปแบบคล้ายกับไฟล์ \cmd{xinitrc} คือเขียนโปรแกรมที่ต้องการใช้หลังจากเริ่มระบบ X วินโดว์. โดยปรกติโปรแกรมที่เขียนในไฟล์นี้ได้แก่วินโดว์แมนเนเจอร์, โปรแกรมที่ใช้ในระบบ X วินโดว์เช่น \cmd{xterm} ฯลฯ. หรือโปรแกรมเริ่ม\emph{เซสชัน (session)}\gindex{session}\gindex{เซสชัน} ของสภาพแวดล้อมเดกสท็อปเช่น \cmd{gnome-session}, \cmd{startkde}, \cmd{xfce4-session} เป็นต้น.
\begin{MyExample}[ไฟล์ \cmd{\~{}/.xinitrc} ที่ไม่ได้ใช้สภาพแวดล้อมเดกสท็อป.]\label{ex:xinitrc-fvwm}
\begin{MyEx}
$ \cin{cat ~/.xinitrc}
xterm & \mycomment{โปรแกรมที่สั่งต้องอยู่ใน} $PATH
exec fvwm2 \mycomment{วินโดว์แมนเนเจอร์ที่ต้องการใช้}
\end{MyEx}
\end{MyExample}

\begin{figure}[!ht]
\plfigure{.4}{xinitrc-simple.eps}{ภาพหน้าจอหลังจากรันคำสั่ง \cmd{startx} ประกอบกับไฟล์ \cmd{\~{}/.xinitrc} ตัวอย่างที่ \ref{ex:xinitrc-fvwm}.}{xinit-simple}
\end{figure}

ถ้าต้องการใช้สภาพแวดล้อมเดกสท็อป, ให้เขียนโปรแกรมเริ่มเซสชันสภาพแวดล้อมที่ต้องการในไฟล์ \cmd{\~{}/.xinitrc}. ในกรณีนี้โปรแกรมเริ่มต้นจะมีการจัดการวินโดว์แมนเนเจอร์, โปรแกรมที่ต้องการรันเริ่มต้นอยู่แล้ว. ผู้ใช้สามารถปรับแต่งคุณสมบัติเหล่านี้ได้จากเมนูของสภาพแวดแล้วเดกสท็อปนั้นๆ.
\begin{MyExample}[ไฟล์ \cmd{\~{}/.xinitrc} ที่ใช้สภาพแวดล้อมเดกสท็อป.]\label{ex:xinitrc-session}
\begin{MyEx}
$ \cin{cat ~/.xinitrc}
# exec startkde \mycomment{บรรทัดที่ขึ้นต้นด้วย \cmd{#} เป็นคอมเมนต์}
# exec xfce4-session
exec gnome-session \mycomment{โปรแกรมเริ่มเซสชันสำหรับ} Gnome
\end{MyEx}
\end{MyExample}%$
\begin{figure}[!htb]
\plfigure{.4}{xinitrc-session.eps}{ภาพหน้าจอหลังจากรันคำสั่ง \cmd{startx} ประกอบกับไฟล์ \cmd{\~{}/.xinitrc} ตัวอย่างที่ \ref{ex:xinitrc-session}.}{xinit-session}
\end{figure}

การสั่งคำสั่ง \cmd{startx} หรือ \cmd{xinit} มักจะสั่งคำสั่งโดยไม่มีตัวเลือกประกอบ. แต่ถ้าต้องการใช้ตัวเลือกประกอบด้วย, จะแบ่งเป็นเลือกสำหรับไคล์เอ็นต์และตัวเลือกสำหรับ X เซิร์ฟเวอร์โดยมีรูปแบบดังนี้.
\begin{MyVerbatim}
startx [ [\textit{client}] \textit{options} ... ] [ -- [\textit{server}] \textit{options} ... ]
\end{MyVerbatim}

\cmdit{client} คือไฟล์โปรแกรมที่ต้องการรันเป็นไคลเอ็นต์หลังจากเข้าสู่ระบบ X วินโดว์. \cmdit{server} คือไฟล์โปรแกรม X เซิร์ฟเวอร์.

ในสภาพที่มี X เซิร์ฟเวอร์ทำงานอยู่แล้วและต้องการรันโปรแกรม \cmd{firefox} อย่างเดียวในหน้าจอที่ 2 ซึ่งเป็นคนละหน้าจอกับที่ใช้อยู่, สามารถทำได้ตามตัวอย่างต่อไปนี้.

\begin{MyExample}[คำสั่ง \cmd{startx} และตัวเลือกที่เกี่ยวกับไคลเอ็นต์, เซิร์ฟเวอร์.]
\begin{MyEx}
$ \cin{startx /usr/bin/firefox http://linux.thai.net -- :1 -depth 16}
\end{MyEx}
\end{MyExample}%$
ในกรณีนี้ไคลเอ็นต์ที่ทำงานเมื่อเข้าสู่ระบบ X วินโดว์ได้แก่ \cmd{firefox} และมีอาร์กิวเมนต์คือ URL ของเว็บไซด์ที่ต้องการเปิดดู. หลังเครื่องหมาย \cmd{--} จะเป็นส่วนที่เกี่ยวข้องกับ X เซิร์ฟเวอร์และ :1 ได้แก่ชื่อหน้าจอที่สอง (\cmd{:1})\mymemo{หน้าจอที่หนึ่งคือ \cmd{:0}}, ตัวเลือก \cmd{-depth} สำหรับ X เซิร์ฟเวอร์, และไม่มีการระบุโปรแกรม X เซิร์ฟเวอร์ที่ต้องการใช้ซึ่งจะหมายถึง \cmd{/usr/X11R6/bin/X} โดยปริยาย. หน้าจอของ X วินโดว์จะใช้อยู่ที่เทอร์มินอลเสมือนตัวที่ยังไม่ได้ใช้ (ดูรูป \ref{fig:virtual_terminal} หน้า \pageref{fig:virtual_terminal} ประกอบ).

\subsection{เริ่มต้น X เซิร์ฟเวอร์ด้วยดิสเพลยแมเนเจอร์}
การใช้\emph{ดิสเพลยแมนเนเจอร์ (display manager)}\gindex{display manager}\gindex{ดิสเพลยแมนเนเจอร์} เป็นอีกวิธีหนึ่งสำหรับการเริ่มต้นระบบ X วินโดว์. ดิสเพลยแมนเนเจอร์ที่นิยมใช้กันอยู่ในปัจจุบันได้แก่ \cmd{xdm}, \cmd{gdm} และ \cmd{kdm}. \cmd{xdm} เป็นดิสเพลยแมนเนเจอร์มาตรฐานที่มาพร้อมกับ X เซิร์ฟเวอร์, ส่วน \cmd{gdm} และ \cmd{kdm} เป็นโปรแกรมดิสเพลยแมนเนเจอร์ของสภาพแวดล้อม GNOME และ KDE ตามลำดับ.

วิธีการเริ่มต้นของดิสเพลยแมนเนเจอร์และการเลือกประเภทของดิสเพลยแมนเนเจอร์จะแตกต่างกันไปตามดิสโทรที่ใช้.

การเริ่มต้นดิสเพลยแมนเนเจอร์โดยปรกติจะเป็นเชลล์สคริปต์ที่รันตอนบูตเครื่องขึ้นอยู่กับดิสโทรแต่ละค่าย.
ดิสโทรตระกูล Red Hat จะมีเชลล์สคริปต์ \cmd{/etc/X11/prefdm} รันอยู่ในโปรแกรม \cmd{init}\mymemo{เรื่องเกี่ยวกับ \cmd{init} ให้ดูหน้าที่ \pageref{sec:init}.} ซึ่งเขียนอยู่ในไฟล์ \cmd{/etc/inittab}. ประเภทของดิสเพลยแมนเนเจอร์สามารถระบุด้วยตัวแปร \cmd{DISPLAYMANAGER="\textit{type}"} ในไฟล์ \cmd{/etc/sysconfig/desktop} เช่น \cmd{DISPLAYMANAGER="GDM"}.

ดิสโทรตระกูล Debian จะระบุดิสเพลยแมนเนเจอร์ที่ใช้ในไฟล์ \cmd{/etc/X11/default-display-manager}.

ดิสโทรตระกูล Gentoo จะใช้เชลล์สคริปต์ \cmd{/etc/init.d/xdm} เป็นตัวเริ่มต้นดิสเพลยแมนเนเจอร์และเขียนประเภทของดิสเพลยแมนเนเจอร์ที่ต้องการใช้ในไฟล์ \cmd{/etc/rc.conf} เช่น \cmd{DISPLAYMANGER="gdm"} เป็นต้น.

อย่างไรก็ตามเชลล์สคริปต์ต่างๆเหล่านี้จะรันโปรแกรม \cmd{xdm}, \cmd{gdm} หรือ \cmd{kdm} ซึ่งดิสเพลยแมนเนเจอร์ของแต่ละแบบ, และผู้ใช้สามารถรันคำสั่งเหล่านี้ได้จากบรรทัดคำสั่งด้วย.



\subsubsection{XDMCP โปรโตคอล}
หน้าที่หลักของดิสเพลยแมนเนเจอร์คือเป็นอินเทอร์เฟสสำหรับล็อกอินเข้าสู่ระบบแบบกราฟิก. การล็อกอินโดยใช้ดิสเพลยแมนเนเจอร์สามารถล็อกอินได้จากเครื่องตัวเองหรือผ่านทางเน็ตเวิร์กก็ได้. การล็อกแบบกราฟิดผ่านทางเน็ตเวิร์กจะอาศัยโปรโตคอลที่เรียกว่า \emph{XDMCP (X Display Manager Control Protocol)}\gindex{x display manager control protocol@X Display Manager Control Protocol}. สมมติว่ามีเครื่องคอมพิวเตอร์ A และ B และคอมพิวเตอร์ A รัน X เซิร์ฟเวอร์และอนุญาตให้เครื่องคอมพิวเตอร์อื่นติดต่อกับ X เซิร์ฟเวอร์ผ่านทาง XDMCP ได้. จากคอมพิวเตอร์ B สามารถรัน X เซิร์ฟเวอร์และเรียกหน้าจอล็อกอินของคอมพิวเตอร์ A มาแสดงที่หน้าจอคอมพิวเตอร์ได้.


การติดต่อขอหน้าจอล็อกอินด้วยโปรโตคอล XDMCP จะระบุด้วยตัวเลือกตอนที่รัน X เซิร์ฟเวอร์ได้แก่
\begin{enumerate}
\item ติดต่อโฮสโดยตรง (query)\\
ในกรณีที่รู้ชื่อโฮสหรือ IP แอดเดรสของเครื่องที่อนุญาตให้ล็อกอินผ่านโปรโตคอล XDMCP สามารถใช้ตัวเลือก \cmd{-qnuery \textit{host}} เช่นตัวอย่างต่อไปนี้เป็นการรัน X เซิร์ฟเวอร์โดยใช้หน้าจอ \cmd{:1} และเรียกหน้าจอล็อกอินจากเครื่องคอมพิวเตอร์ที่มี IP แอดเดรส 192.168.11.2.
\begin{MyExample}[ขอหน้าจอล็อกอินโดยตรงโดยใช้ XDMCP โปรโตคอล.]
\begin{MyEx}
$ \cin{X -query 192.168.11.2 :1}
\end{MyEx}
\end{MyExample}%$
\item บรอดแคสต์ (broadcast)\\
ใช้วิธี\emph{บรอดแคสต์ (broaadcast)}\gindex{broadcast}\gindex{บอรดแคสต์} ประกาศหาโฮสที่อนุญาตให้ติดต่อหน้าจอล็อกอินในเครือข่ายท้องถิ่นที่ใช้อยู่. X เซิร์ฟเวอร์จะติดต่อกับโฮสเครื่องแรกที่หาเจอด้วยการบรอดแคสต์และแสดงหน้าจอล็อกอินของโฮสนั้น.
\begin{MyExample}[ขอหน้าจอล็อกอินด้วยวิธีบรอดแคสต์โดยใช้ XDMCP โปรโตคอล.]
\begin{MyEx}
$ \cin{X -brodcast :1}
\end{MyEx}
\end{MyExample}%$

\item ติดต่อโฮสโดยทางอ้อม (indirect)\\
วิธีนี้คล้ายกับการบรอดแคสต์แต่จะระบุตัวเลือก \cmd{-indirect \textit{host}} ให้แสดงหน้าจอรายชื่อโฮสที่อนุญาตเปิดรับ XDMCP โปรโตคอล. รายชื่อโฮสนี้ได้มาจากการสอบถามไปที่โฮส \cmdit{host} ที่ระบุเป็นอาร์กิวเมนต์ของตัวเลือก.
\begin{MyExample}[ขอหน้าจอล็อกอินด้วยวิธีอ้อมโดยใช้ XDMCP โปรโตคอล.]
\begin{MyEx}
$ \cin{X -indirect localhost :1}
\end{MyEx}
\end{MyExample}%$

\begin{figure}[!htb]
\plfigure{.4}{xdmcp-indirect.eps}{การขอหน้าจอล็อกอินโดยใช้วิธี indirect.}{xdmcp-indirect}
\end{figure}
\end{enumerate}


\subsubsection{การปรับแต่งดิสเพลยแมนเนเจอร์}
การปรับแต่งดิสเพลยแมนเจอร์สามารถใช้โปรแกรมปรับแต่งเฉพาะของแต่ละระบบได้เช่น \cmd{gdmconfig} หรือ \cmd{kdm\_config}. โปรแกรมเหล่านี้มักจะมีให้เลือกจากเมนูในสภาพแวดล้อมเดกส์ทอปอยู่แล้ว. ส่วนการปรับแต่ง \cmd{xdm} ทำได้โดยการปรับแต่งไฟล์ต่างๆที่เกี่ยวข้องใต้ไดเรกทอรี \cmd{/etc/X11/xdm}\gindex{/etc/X11/xdm@ไดเรกทอรี \cmd{/etc/X11/xdm}} ซึ่งสามารถอ่านได้จาก \cmd{man xdm}.


\section{X เซิร์ฟเวอร์แบบพิเศษ}
นอกจากโปรแกรม X เซิร์ฟเวอร์ที่แสดงผลกราฟิกทางหน้าจอแล้วในระบบ X วินโดว์ยังมีโปรแกรม \cmd{Xnest}, \cmd{Xvfb} และ \cmd{Xvnc} ซึ่งเป็นโปรแกรม X เซิร์ฟเวอร์แต่เป็น X เซิร์ฟเวอร์แบบพิเศษใช้เฉพาะงานต่างกันไป.

\subsection{\cmd{Xnest}}
โปรแกรม \cmd{Xnest}\index{command}{xnest@{\latintext\texttt{Xnest}}} เป็น X เซิร์ฟเวอร์ประเภทหนึ่งที่แสดงหน้าจอเป็นหน้าต่างแอพพลิเคชันในหน้าจอ X วินโดว์ที่ทำงานอยู่. ตัวอย่างการใช้งานเช่นใช้ \cmd{Xnest} ขอหน้าจอล็อกอินจากเครื่องคอมพิวเตอร์เครื่องอื่นผ่านเน็ตเวิร์กเป็นต้น.

\begin{MyExample}[ตัวอย่างการใช้ \cmd{Xnest}.]
\begin{MyEx}
$ \cin{Xnest -indirect localhost :1 &} \mycomment{ใช้เดี่ยวๆ}
$ \cin{startx /usr/X11R6/bin/xlogo -- /usr/X11R6/bin/Xnest :2 &} \mycomment{ใช้กับ \cmd{startx}}
\end{MyEx}
\end{MyExample}%

\begin{figure}[!htb]
\plfigure{.3}{xnest.eps}{หน้าต่างโปรแกรม \cmd{Xnest} ในหน้าจอ X วินโดว์.}{xnest}
\end{figure}

ในสภาพแวดล้อมเดกสท็อป GNOME มีโปรแกรมคล้ายกับ \cmd{Xnest} สำหรับจัดการแสดงผลโปรแกรม \cmd{Xnest} ให้โดยอัตโนมัติที่ผู้ใช้ไม่ต้องรันโปรแกรม \cmd{Xnest} โดยตรงได้แก่โปรแกรม \cmd{gdmXnest}\cindex{gdmXnest}, \cmd{gdmXnestchooser}\cindex{gdmXnestchooser} และ \cmd{gdmflexiserver}\cindex{gdmflexiserver}.

\begin{MyExample}[โปรแกรมเกี่ยวกับ \cmd{Xnest} ในสภาพแวดล้อมเดกสท็อป GNOME.]
\begin{MyEx}
$ \cin{gdmXnest &} \mycomment{แสดงหน้าจอ \cmd{Xnest}}
$ \cin{gdmXnestchooser &} \mycomment{แสดง \cmd{Xnest} กับตัวเลือก \cmd{-indirect}}
$ \cin{gdmflexiserver -n &} \mycomment{แสดงหน้าจอล็อกอิน \cmd{gdm} ใน \cmd{Xnest}}
\end{MyEx}
\end{MyExample}%$

โปรแกรม \cmd{gdmXnest} และ \cmd{gdmXnestchooser} จะแสดงชื่อหน้าจอที่กำหนดให้อัตโนมัติทางเทอร์มินอลที่สั่งคำสั่ง. ผู้ใช้สามารถรันโปรแกรมอะไรก็ได้ให้ไปแสดงผลใน \cmd{Xnest} โดยระบุชื่อหน้าจอนั้น.



\subsection{\cmd{Xvfb}}
\cmd{Xvfb}\index{command}{xvfb@{\latintext\texttt{Xvfb}}} ย่อมาจาก X server Virtual Frame Buffer เป็น X เซิร์ฟเวอร์เสมือน, คือไม่มีการแสดงผลให้เห็นทางหน้าจอแต่จะเป็นการจำลองการทำงานของ X เซิร์ฟเวอร์. ในระบบที่ไม่มีอุปกรณ์แสดงผลเช่นไม่มีหน้าจอและไม่มีอุปกรณ์ป้อนข้อมูลเข้า, แต่ในบางกรณีต้องการรันคำสั่งที่ใช้ X เซิร์ฟเวอร์ประมวลผลอะไรสักอย่าง, สามารถใช้โปรแกรม \cmd{Xvfb} ช่วยได้.

สมมติว่าเราล็อกอินเข้าสู่ระบบผ่านทางเน็ตเวิร์กเข้าไปในเครื่องคอมพิวเตอร์เครื่องหนึ่งผ่านทางเทอร์มินอล. และในระบบมีโปรแกรม \cmd{testprogram} ซึ่งจะแสดงผลในระบบ X วินโดว์แต่มีข้อจำกัดทางเทคนิคทำให้ติดต่อกับคอมพิวเตอร์เครื่องนั้นได้ทางเทอร์มินอลเท่านั้น. ในกรณีนี้ถ้าต้องการดูผล (รูป) ของโปรแกรม, สามารถรัน \cmd{Xvfb} สร้าง X เซิร์ฟเวอร์เสมือนก่อนแล้วให้โปรแกรมที่ต้องการรันแสดงผลทางหน้าจอที่ระบุ. จากนั้นใช้โปรแกรม \cmd{xwd}\cindex{xwd}\refcmd{xwd} แปลงการแสดงผลของ X เซิร์ฟเวอร์เป็นไฟล์รูปภาพได้.

\begin{MyExample}[การใช้ \cmd{Xvfb} ในระบบที่ไม่มีจอภาพ.]
\begin{MyEx}
$ \cin{Xvfb :1 -ac &} \mycomment{ไม่มีการแสดงผลทางหน้าจอ}
$ \cin{DISPLAY=:1 testprogram &} \mycomment{แสดงผลไปที่ \cmd{Xvfb}}
$ \cin{xwd -root -display :1 -out testprogram.xwd} \mycomment{จับภาพหน้าจอ}
$ \cin{convert testprogram.xwd testprogram.png} \mycomment{แปลงฟอร์แมตรูป}
\end{MyEx}
\end{MyExample}

\subsection{\cmd{Xvnc}}
\cmd{Xvnc}\index{command}{xvnc@{\latintext\texttt{Xvnc}}} เป็น X เซิร์ฟเวอร์ที่มีคุณสมบัติสามารถผลผ่านทางเน็ตเวิร์กโดยใช้โพรโทคอล \emph{VNC (Vertual Network Computing)}\gindex{vnc@VNC|see{Virtual Network Computing}}\gindex{virtual network computing@Virtual Network Computing} แทน X โพรโตคอล. โปรแกรม X เซิร์ฟเวอร์นี้ไม่ใช่โปรแกรมในระบบ X วินโดว์มาตรฐานแต่เป็นโปรแกรมในแพ็กเกจของ VNC \cite{vnc}. ข้อดีของการใช้โพรโตคอล VNC คือมีไคลเอ็นต์สำหรับควบคุมและดูหน้าจอในหลายแพลตฟอร์มคือสามารถดูหน้าจอได้จากระบบปฏิบัติการใดๆก็ได้ที่มีโปรแกรม VNC viewer.

\begin{figure}[!htb]
\plfigure{.4}{vncviewer-windows.eps}{หน้าต่างโปรแกรม VNC viewer บนระบบปฏิบัติการวินโดวส์.}{vncviewer-windows}
\end{figure}

เวลาใช้งานจะไม่รันคำสั่ง \cmd{Xvnc} โดยตรงแต่จะใช้คำสั่ง \cmd{vncserver}\cindex{vncserver} แทน. โดยระบุชื่อหน้าจอเป็นอาร์กิวเมนต์.

\begin{MyExample}[ใช้งาน \cmd{Xvnc}.]
\begin{MyEx}
$ \cin{vncserver -geometry 800x600 :1}

You will require a password to access your desktops.

Password: \mycomment{ใส่รหัสผ่าน}
Verify:

New 'toybox:1 (poonlap)' desktop is toybox:1 \mycomment{\cmd{toybox} คือชื่อโฮส}

Creating default startup script /home/poonlap/.vnc/xstartup
Starting applications specified in /home/poonlap/.vnc/xstartup
Log file is /home/poonlap/.vnc/toybox:1.log

\end{MyEx}
\end{MyExample}%$

ถ้าเป็นการสั่งคำสั่ง \cmd{vncserver} เป็นครั้งแรก, ตัวโปรแกรมจะสร้างไดเรกทอรี \cmd{\~{}/.vnc} ให้ผู้ใช้ตั้งรหัสผ่านสำหรับเวลาที่ติดต่อแสดงผล. ในไดเรกทอรี \cmd{\~{}/.vnc} จะมีไฟล์ \cmd{xstartup} เป็นไฟล์ที่มีหน้าที่เหมือนกับ \cmd{\~{}/.xinitrc} รันโปรแกรมต่างๆหลังจาก X เซิร์ฟเวอร์เริ่มทำงาน.

การติดต่อดูหน้าจอจะใช้โปรแกรม VNC viewer ใช้ได้ในหลายแพล็ตฟอร์ม, ในระบบปฏิบัติการลินุกซ์ได้แก่โปรแกรม \cmd{vncviewer}\cindex{vncviewer}. วิธีใช้เบื้องต้นให้ใส่ชื่อหน้าจอที่ต้องการติดต่อดูผ่าน VNC โพรโทคอลเป็นอาร์กิวเมนต์ของโปรแกรม. ในกรณีที่ใช้ \cmd{vncviewer} ผ่านทางเน็ตเวิร์ก, ให้ใช้ IP แอดเดรสหรือชื่อโฮสตามด้วยชื่อหน้าจอ. เช่น \cmd{192.168.1.5:1} เป็นต้น.

\begin{MyExample}[ใช้ \cmd{vncviewer} ติดต่อดูหน้าจอ.]
\begin{MyEx}
$ \cin{vncviewer :1} \mycomment{หรือจะใช้ชื่อหน้าจอเป็น \cmd{toybox:1} ก็ได้}
\end{MyEx}
\end{MyExample}%$

นอกจากจะใช้ \cmd{vncviewer} ติดต่อกับ \cmd{Xvnc} แล้วยังสามารถใช้ติดต่อกับหน้าจอของระบบปฏิบัติการใดๆก็ที่รัน VNC เซิร์ฟเวอร์อยู่ เช่นใช้ดูหน้าจอไมโครซอฟต์วินโดวส์ที่รัน VNC เซิร์ฟเวอร์จากลินุกซ์เป็นต้น. ตัวหน้าต่างโปรแกรม \cmd{vncviewer} จะมีคีย์พิเศษ \cmd{F8} เมื่อกดแล้วจะแสดงเมนูเพื่อกระทำการต่างๆเฉพาะกรณีเช่นส่งคีย์ \cmd{Ctrl+Alt+Del} ให้กับเครื่องที่ติดต่ออยู่ปลายทาง, ปรับหน้าจอให้แสดงผลเต็มจอภาพ เป็นต้น.

วิธีการจบการทำงานของ \cmd{vncserver} ทำได้โดยใช้ตัวเลือก \cmd{-kill} และตามด้วยชื่อหน้าจอ.
\begin{MyExample}[จบการทำงานของ \cmd{vncserver}.]
\begin{MyEx}
$ \cin{vncserver -kill :1}
Killing Xvnc process ID 31339
\end{MyEx}
\end{MyExample}%$

โปรแกรม \cmd{vncserver} จะสร้าง X เซิร์ฟเวอร์ตัวใหม่เพิ่มจาก X เซิร์ฟเวอร์ที่มีอยู่โดยใช้โปรแกรม \cmd{Xvnc} ถ้าต้องการแสดงหรือแชร์ (share) หน้าจอที่ทำงานอยู่แล้ว (หน้าจอ \cmd{:0}) ให้ใช้โปรแกรม \cmd{x0vncserver}\cindex{x0vncserver}. โปรแกรมนี้จะแสดงผลหน้าจอ \cmd{:0} หรือหน้าจอที่ระบุด้วยตัวเลือก \cmd{-display=\textit{dpy}}. ตัวเลือกอื่นๆสามารถดูได้จากการใช้ตัวเลือก \cmd{-h} ประกอบ.



\section{ระบบจัดการฟอนต์}
ระบบจัดการฟอนต์เพื่อแสดงอักขระต่างๆในระบบ X วินโดว์แบ่งออกเป็นสองวิธีได้แก่ระบบจัดการฟอนต์ดั้งเดิมที่เรียกกันว่า\emph{ X คอร์ฟอนต์ (X core fonts)} และ Xft. ระบบจัดการฟอนต์ทั้งสองแตกต่างกันที่เซิร์ฟเวอร์จะเป็นตัวจัดการการแสดงผลฟอนต์ในระบบดั้งเดิม, ไคลเอ็นต์จะเป็นตัวจัดการแสดงผลฟอนต์ในระบบ Xft โดยอาศัยไลบรารี. เมื่อเปรียบเทียบเรื่องเกี่ยวกับการเพิ่มฟอนต์หรือปรับแต่งฟอนต์ในระบบ, การดูแลระบบจัดการฟอนต์แบบ Xft จะง่ายกว่าระบบดั้งเดิมมาก. ในช่วงนี้เป็นการแนะนำระบบจัดการฟอนต์ทั้งสองแบบซึ่งมีวิธีการจัดการแตกต่าง. การรู้จักระบบจัดการฟอนต์ทั้งสองแบบช่วยให้ผู้ใช้ทำความเข้าการติดตั้งฟอนต์ใหม่ๆเช่นฟอนต์ภาษาไทยได้ดีขึ้น.

\subsection{ระบบจัดการฟอนต์แบบดั้งเดิม}
ระบบการจัดการฟอนต์แบบดั้งเดิมกระทำโดยตัว X เซิร์ฟเวอร์เองและใช้จัดการแสดงผลฟอนต์แบบบิตแมปเป็นหลัก. ต่อมามีการเพิ่มความสามารถแสดงผลฟอนต์แบบเวกเตอร์เช่นฟอนต์ PostScript หรือทรูไทป์ในรูปของโมดูล. โมดูลที่ช่วยให้ X เซิร์ฟเวอร์สามารถใช้ฟอนต์ทรูไทป์ในช่วงแรกได้แก่ xfstt\gindex{xfstt} และ xfsft\gindex{xfsft} \cite{xfsft}. ผู้ใช้ต้องเลือกใช้ระหว่างโมดูลทั้งสองซึ่งไม่มีความเข้ากัน. ต่อมาความนิยมของ xfsft ซึ่งใช้ไลบรารี FreeType\gindex{freetype@FreeType} \cite{freetype} มีมากขึ้นและถูกรวมไว้ในโครงการ XFree86 ในที่สุด. ในปัจจบันถ้าต้องการใช้ฟอนต์ทรูไทป์ที่จัดการด้วย X เซิร์ฟเวอร์ให้โหลดโมดูล ``freetype'' ในเซกชัน ``Module''.

\subsubsection{ไดเรกทอรีที่เก็บฟอนต์}
การติดตั้งและปรับแต่งฟอนต์จะระบุไดเรกทอรีหรือฟอนต์เซิร์ฟเวอร์ที่เก็บฟอนต์ต่างๆในไฟล์ตั้งค่าเริ่มต้นของเซิร์ฟเวอร์เช่นไฟล์ \cmd{xorg.conf}. ชื่อไดเรกทอรีที่เก็บฟอนต์จะเป็นค่าของพารามิเตอร์ FontPath ในเซกชัน ``Files'' (หน้า \pageref{sec:x-files-section}). ในไดเรกทอรีหรือฟอนต์เซิร์ฟเวอร์ที่เก็บฟอนต์เหล่านั้นจะมีไฟล์ต่างๆที่เกี่ยวข้องกับการติดตั้งฟอนต์ในระบบได้แก่
\begin{itemize}
\item ไฟล์ \cmd{fonts.dir}\gindex{font.dir@ไฟล์ \cmd{font.dir}}\\
เป็นไฟล์ที่สร้างด้วยคำสั่ง \cmd{mkfontdir}\cindex{mkfontdir} บันทึกชื่อไฟล์ฟอนต์และชื่อฟอนต์ที่สัมพันธ์กัน. บรรทัดแรกจะเป็นจำนวนของฟอนต์ทั้งหมดที่บันทึกในไฟล์. คำสั่ง \cmd{mkfontdir} จะตรวจสอบไฟล์ฟอนต์บิตแมป \cmd{.bdf}, \cmd{.pcf}, ไฟล์ฟอนต์ที่บีบอัดด้วย \cmd{gzip} และไฟล์ \cmd{fonts.scale} ที่อยู่ในไดเรกทอรีที่ทำงานอยู่และสร้างไฟล์ \cmd{fonts.dir} ในไดเรกทอรีที่รันคำสั่ง.
\begin{MyExample}[ไฟล์ \cmd{fonts.dir}]
\begin{MyEx}
$ \cin{head /usr/share/fonts/misc/fonts.dir}
516
10x20-ISO8859-1.pcf.gz -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-1
10x20-ISO8859-10.pcf.gz -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-10
10x20-ISO8859-11.pcf.gz -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-11
10x20-ISO8859-13.pcf.gz -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-13
10x20-ISO8859-14.pcf.gz -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-14
10x20-ISO8859-15.pcf.gz -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-15
10x20-ISO8859-16.pcf.gz -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-16
10x20-ISO8859-2.pcf.gz -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-210x20-ISO8859-3.pcf.gz -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-3\end{MyEx}
\end{MyExample}%$


\item ไฟล์ \cmd{fonts.scale}
เป็นไฟล์ที่สร้างด้วยคำสั่ง \cmd{mkfontscale}\cindex{mkfontscale} หรือ \cmd{ttmkfdir}\cindex{ttmkfdir}. คำสั่งเหล่านี้จะตรวจสอบไฟล์ฟอนต์เวกเตอร์เช่นทรูไทป์หรือ PostScript ที่อยู่ในไดเรกทอรีที่ทำงานอยู่แล้วสร้างไฟล์ \cmd{fonts.scale}.  ไฟล์ที่สร้างจะเป็นข้อมูลนำเข้าสำหรับคำสั่ง \cmd{mkfontdir} เพื่อสร้างไฟล์ \cmd{fonts.dir} อีกต่อไป.
\begin{MyExample}[ไฟล์ \cmd{fonts.scale}]
\begin{MyEx}
$ \cin{head /usr/share/fonts/TTF/fonts.scale}
luximb.ttf -b&h-Luxi Mono-bold-r-normal--0-0-0-0-m-0-adobe-standard
luximb.ttf -b&h-Luxi Mono-bold-r-normal--0-0-0-0-m-0-ascii-0
luximb.ttf -b&h-Luxi Mono-bold-r-normal--0-0-0-0-m-0-iso10646-1
luximb.ttf -b&h-Luxi Mono-bold-r-normal--0-0-0-0-m-0-iso8859-1
luximb.ttf -b&h-Luxi Mono-bold-r-normal--0-0-0-0-m-0-iso8859-10
luximb.ttf -b&h-Luxi Mono-bold-r-normal--0-0-0-0-m-0-iso8859-13
luximb.ttf -b&h-Luxi Mono-bold-r-normal--0-0-0-0-m-0-iso8859-15
luximb.ttf -b&h-Luxi Mono-bold-r-normal--0-0-0-0-m-0-iso8859-16
luximb.ttf -b&h-Luxi Mono-bold-r-normal--0-0-0-0-m-0-iso8859-2
\end{MyEx}
\end{MyExample}%$



\item ไฟล์ \cmd{fonts.alias}
ชื่อฟอนต์ในไฟล์ \cmd{fonts.dir} เป็นชื่อฟอนต์มาตรฐานที่เรียกว่า XLFD ซึ่งยาวและเข้าใจยาก. ไฟล์ \cmd{fonts.alias} จะเป็นไฟล์ที่ระบุชื่อสั้นๆ (นามแฝง) ที่ใช้แทนชื่อ XLFD.
\begin{MyExample}[ไฟล์ \cmd{fonts.alias}]
\begin{MyEx}
$ \cin{head /usr/share/fonts/misc/fonts.alias}
! $Xorg: fonts.alias,v 1.3 2000/08/21 16:42:31 coskrey Exp $
fixed        -misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-iso8859-1
variable     -*-helvetica-bold-r-normal-*-*-120-*-*-*-*-iso8859-1
5x7          -misc-fixed-medium-r-normal--7-70-75-75-c-50-iso8859-1
5x8          -misc-fixed-medium-r-normal--8-80-75-75-c-50-iso8859-1
6x9          -misc-fixed-medium-r-normal--9-90-75-75-c-60-iso8859-1
6x10         -misc-fixed-medium-r-normal--10-100-75-75-c-60-iso8859-1
6x12         -misc-fixed-medium-r-semicondensed--12-110-75-75-c-60-iso8859-1
6x13         -misc-fixed-medium-r-semicondensed--13-120-75-75-c-60-iso8859-1
6x13bold     -misc-fixed-bold-r-semicondensed--13-120-75-75-c-60-iso8859-1
\end{MyEx}
\end{MyExample}%$
\end{itemize}

\subsubsection{ฟอนต์เซิร์ฟเวอร์}\label{sec:xfs}
การระบุไดเรกทอรีที่เก็บฟอนต์ด้วยพารามิเตอร์ FontPath ในไฟล์ \cmd{xorg.conf} เป็นวิธีการเบื้องต้นสำหรับบอกให้ X เซิร์ฟเวอร์รู้แหล่งที่เก็บฟอนต์. วิธีการนี้เข้าใจง่ายแต่มีข้อเสียบางอย่างได้แก่
\begin{itemize}
\item ฟอนต์ใหม่ที่เพิ่มเข้าไปในระบบไม่สามารถใช้งานได้ทันทีจนกว่าจะเริ่มต้น X เซิร์ฟเวอร์ใหม่อีกครั้ง.
\item ฟอนต์ที่สามารถใช้ได้ขึ้นอยู่กับ X เซิร์ฟเวอร์ว่ามีฟอนต์อะไรใช้ได้บ้าง. ในกรณีที่ใช้โพรโตคอล XDMCP ล็อกอินข้ามโฮส, เครื่องที่ติดต่อสำหรับล็อกอินกับ X เซิร์ฟเวอร์ที่แสดงผลเป็นคนละเครื่องกัน. ดังนั้นเครื่องที่ติดต่อล็อกอินกับฟอนต์ที่ X เซิร์ฟเวอร์สามารถแสดงผลได้อาจจะไม่เหมือนกันหรือฟอนต์บางตัว X เซิร์ฟเวอร์ที่ใช้แสดงผลอาจจะไม่มี.
\end{itemize}
ปัญหาเหล่านี้สามารถแก้ได้โดยการใช้\emph{ฟอนต์เซิร์ฟเวอร์ (X font server)}\gindex{ฟอนต์!เซิร์ฟเวอร์}\gindex{x font server@X font server}. ในกรณีที่ใช้ฟอนต์เซิร์ฟเวอร์จะสามารถใช้ฟอนต์ใหม่ที่เพิ่มเข้าสู่ระบบได้ทันทีโดยไม่ต้องเริ่ม X เซิร์ฟเวอร์ใหม่เพียงแต่เริ่มต้นการทำงานของฟอนต์เซิร์ฟเวอร์เท่านั้น. และสามารถใช้ฟอนต์ผ่านทางเน็ตเวิร์กได้ด้วย.

โปรแกรมสำหรับรันฟอนต์เซิร์ฟเวอร์ได้แก่ \cmd{xfs}\cindex{xfs} ซึ่งจะมีไฟล์ตั้งค่าเริ่มต้นโดยปริยายได้แก่ \cmd{/usr/X11R6/lib/X11/fs/config}. โดยปรกติผู้ใช้จะไม่รันฟอนต์เซิร์ฟเวอร์ด้วยคำสั่ง \cmd{xfs} โดยตรงแต่จะใช้ init script \mymemo{init script, ดูหน้า \pageref{sec:initscript}} เช่น \cmd{/etc/init.d/xfs} เป็นเชลล์สคริปต์สำหรับเริ่มต้นทำงานฟอนต์เซิร์ฟเวอร์และไฟล์ตั้งค่าเริ่มต้นจะเป็น \cmd{/etc/X11/fs/{\wbr}config}\findex{config}.

\begin{MyExample}[ไฟล์ตั้งค่าเริ่มต้นฟอนต์เซิร์ฟเวอร์.]
\begin{MyEx}
$ \cin{cat /etc/X11/fs/config}
#
# X Font Server configuration file
#

# \thtt{อนุญาตให้ไคล์เอ็นต์ติดต่อกับเซิร์ฟเวอร์ได้ไม่เกิน 4 ตัว}
#client-limit = 4

# \thtt{ไม่ใช้ \cmd{tcp}, ใช้ \cmd{socket} เท่านั้น}
no-listen  =  tcp

# \thtt{ถ้ามีการติดต่อใช้เซิร์ฟเวอร์เกินกำหนดให้สร้างเซิร์ฟเวอร์ตัวใหม่}
clone-self = on

# \thtt{ฟอนต์เซิร์ฟเวอร์อื่นสำหรับให้ไคลเอ็นต์ใช้}
#alternate-servers = foo:7101,bar:7102

# \thtt{ระบุไดเรกทอรีที่เก็บฟอนต์}
#
catalogue = /usr/share/fonts/75dpi,
        /usr/share/fonts/100dpi,
        /usr/share/fonts/misc,
        /usr/share/fonts/Type1,
        /usr/share/fonts/truetype,
        /usr/share/fonts/TTF

# \thtt{ขนาดฟอนต์ปริยาย, 12 พอยต์}
default-point-size = 120

# 100 x 100 \thtt{และ} 75 x 75
default-resolutions = 75,75,100,100

# \thtt{บันทึกล็อก}
use-syslog = on

# \thtt{ควบคุม \cmd{cache}. หน่วยเป็น \cmd{KB}}
cache-hi-mark = 2048
cache-low-mark = 1433
cache-balance = 70
\end{MyEx}
\end{MyExample}%$

ส่วนที่สำคัญในไฟล์ \cmd{config} ได้แก่ค่าพารามิเตอร์ catalogue ใช้สำหรับระบุไดเรกทอรีที่เก็บฟอนต์ต่างๆ. ในกรณีที่ระบุไดเรกทอรีมากกว่าหนึ่งที่ให้ใช้เครื่องหมายลูกน้ำ (,) คั่น.

ฟอนต์เซิร์ฟเวอร์จะเริ่มทำงานโดยอัตโนมัติเมื่อระบบเริ่มต้นทำงาน, แต่ถ้าต้องการรันหรือหยุดการทำงานของฟอนต์เซิร์ฟเวอร์ด้วยตนเองสามารถใช้สคริปต์ \cmd{/etc/init.d/xfs} และใช้อาร์กิวเมนต์ start, stop หรือ restart ซึ่งจะเหมือนกับการรันเซิร์ฟเวอร์โดยใช้ init script ทั่วไป.

\begin{MyExample}[การรันฟอนต์เซิร์ฟเวอร์โดยตรง.]
\begin{MyEx}
# \cin{/etc/init.d/xfs start}
 * Scanning font directories...                                           [ ok ]
 * Starting X Font Server...                                              [ ok ]
# \cin{/etc/init.d/xfs restart}
 * Stopping X Font Server...                                              [ ok ]
 * Scanning font directories...                                           [ ok ]
 * Starting X Font Server...                                              [ ok ]
# \cin{/etc/init.d/xfs stop}
 * Stopping X Font Server...                                              [ ok ]
\end{MyEx}
\end{MyExample}

\subsubsection{ปรับแต่งให้ระบบใช้ฟอนต์เซิร์ฟเวอร์}
การปรับแต่งให้ X เซิร์ฟเวอร์ใช้ฟอนต์เซิร์ฟเวอร์ทำได้โดยเขียนชื่อฟอนต์เซิร์ฟเวอร์ในพารามิเตอร์ FontPath ในไฟล์ \cmd{xorg.conf} โดยมีรูปแบบดังนี้.
\begin{MyVerbatim}
\textit{trans}/\textit{hostname}:\textit{port-number}
\end{MyVerbatim}
\textit{trans} หมายถึง transport type คือวิธีติดต่อกับฟอนต์เซิร์ฟเวอร์ว่าจะติดต่อผ่านยูนิกซ์โดเมนซ็อกเก็ตหรือผ่านโพรโตคอล tcp. %
\myvocab{t}{tcp}{ย่อมาจากคำว่า Transfer Control Protocol เป็นโปรโตคอลมาตรฐานสำหรับควบคุมข้อมูลที่ส่งผ่านทางอินเทอร์เน็ต. มีระบบสร้างคอนเน็กชันระหว่างโฮส, ตรวจเช็กข้อมูล ฯลฯ}%
ถ้าเครื่องที่รัน X เซิร์ฟเวอร์มีฟอนต์เซิร์ฟเวอร์ทำงานอยู่ด้วย, สามารถติดต่อกับเครื่องตัวเองด้วยยูนิกซ์โดเมนซ็อกเก็ต. ในกรณีนี้จะเขียนเป็น
\begin{MyVerbatim}
FontPath        "unix/:-1"
\end{MyVerbatim}
ถ้าใช้การติดต่อเซิร์ฟเวอร์ผ่าน tcp ไปยังเครื่องอื่นจะเขียนเป็น
\begin{MyVerbatim}
FontPath        "tcp/\textit{hostname-or-ip}:7100"
\end{MyVerbatim}
\textit{hostname-or-ip} เป็นชื่อโฮสหรือ IP แอดเดรส. ตัวเลขที่อยู่หลังเครื่องหมาย : คือหมายเลขพอร์ตของฟอนต์เซิร์ฟเวอร์ซึ่งปรกติจะมีค่าเป็น 7100.




\subsubsection{ชื่อฟอนต์แบบ XLFD}\label{sec:xfont}
ชื่อฟอนต์ที่ใช้ในระบบ X วินโดว์แบบดั้งเดิมมีชื่อเรียกว่า \emph{XLFD (X Logical Font Description)}\gindex{x logical font description@X Logical Font Description}\gindex{xlfd@XLFD|see{X Logical Font Description}} และคำสั่งที่ใช้แสดงชื่อฟอนต์ในระบบได้แก่ \cmd{xlsfonts}\cindex{xlsfonts}\refcmd{xlsfonts}.
\begin{MyExample}[แสดงชื่อฟอนต์แบบ XLFD ในระบบ.]
\begin{MyEx}
$ \cin{xlsfonts}
-adobe-courier-bold-o-normal--0-0-100-100-m-0-iso10646-1
-adobe-courier-bold-o-normal--0-0-100-100-m-0-iso8859-1
-adobe-courier-bold-o-normal--0-0-100-100-m-0-iso8859-10
\abb
10x20 \mycomment{ชื่อฟอนต์แบบไม่เป็นทางการ, นามแฝง}
12x24
12x24kana
12x24romankana
5x7
\abb
\end{MyEx}
\end{MyExample}%$

เนื่องจากชื่อฟอนต์แบบ XLFD ยาวมากและยากที่จำ, ชื่อฟอนต์บางตัวอาจจะมีนามแฝง (alias) ได้เช่น \cmd{10x20} ก็เป็นชื่อฟอนต์ที่ใช้ได้ในระบบเช่นกัน. ชื่อฟอนต์แบบ XLFD ประกอบด้วยส่วนต่างๆคั่นด้วยเครื่องหมาย \cmd{-} โดยมีรูปแบบดังต่อไปนี้.
\begin{MyVerbatim}
-\textit{fndry}-\textit{fmly}-\textit{wght}-\textit{slant}-\textit{sW}-\textit{adstyl}-\textit{pxlsz}-\textit{ptSz}-\textit{resx}-\textit{resy}-\textit{spc}-\textit{avgW}-\textit{reg}-\textit{enc}
\end{MyVerbatim}
\begin{itemize}
\item Foundry (\cmd{fndry})\\
ผู้สร้างฟอนต์เช่น adobe, bitstream, mise ฯลฯ.
\item Font family (\cmd{fmly})\\
ชื่อตระกูลฟอนต์เช่น times, angsana, fixed ฯลฯ.
\item Weight (\cmd{wght})\\
แสดงความหนาของตัวอักขระในฟอนต์ได้แก่ bold, demibold, medium, regular และ small.
\item Slant (\cmd{slant})\\
แสดงความเอียงของตัวอักขระในฟอนต์ได้แก่ i (italic), o (oblique) และ r (roman). รูปทรง italic และ oblique ดูคล้ายกันซึ่งจริงๆแล้วมีความหมายไม่เหมือนกัน. รูปทรง italic หมายถึงรูปทรงวาดให้อักขระเอียงและมีความเป็นโค้ง (cursive) ปรับแต่งให้สวยงามด้วย. ส่วน oblique นั้นเป็นเพียงแค่รูปทรงที่จับให้เอียงเช่นการทำให้รูปทรงตรงเอียง. ทรง roman คืออักขระภาษาอังกฤษแต่ในที่นี้จะหมายถึงรูปทรงอักขระตั้งตรง.
\item Set-width name (\cmd{sW})\\
ความกว้างของตัวอักษรเช่น normal, condensed, semicondensed, narrow, double wide เป็นต้น.
\item Additional style (\cmd{adstyl})\\
ทรงเพิ่มเติมเช่น ja, ko, sans หรือเว้นว่างไว้.
\item Pixel size (\cmd{pxlsz})\\
ความสูงในหน่วยพิกเซล.
\item Point size (\cmd{ptSz})\\
ความสูงในหน่วย 10 เท่าของพอยต์ (point). เช่นค่า 100 หมายถึงฟอนต์ขนาด 10 พอยต์\mymemo{1 พอยต์มีค่าเท่ากับ 1/72 นิ้ว}
\item Dots-per-inch (\cmd{resx} และ \cmd{resy})\\
ค่า dpi (dot per inch) ในแนวนอนและแนวตั้ง.
\item pppSpacing (\cmd{spc})\\
ระยะตัวอักษรได้แก่ c (character cell), m (monospace) และ p (proportional)\mymemo{monospace มีชื่อเรียกอีกอย่างว่า fixed-width. ส่วน proportional มีชื่อเรียกอีกอย่างว่า variable-width.}. monospace หมายถึงอักขระทุกตัวในฟอนต์มีความกว้างเท่ากันทุกตัวซึ่งตรงข้ามกับประเภท propotional ซึ่งความกว้างของทุกอักขระไม่จำเป็นต้นเท่ากัน. สำหรับฟอนต์แบบ proportional, อักขระบางตัวอาจจะไม่มีความกว้างเช่นสระหรือวรรณยุกต์บางตัวไม่มีความกว้าง. ฟอนต์แบบ character cell เป็นฟอนต์แบบ monospace แบบหนึ่งแต่ออกแบบมาให้ใช้กับเทอร์มินอลเช่น \cmd{xterm} โดยเฉพาะ.
\item Average width (\cmd{avgW})\\
ความกว้างโดยเฉลี่ยของอักขระในหน่วย 10 เท่าของพิกเซล.
\item Character registry (\cmd{reg})\\
ประเภทของอักขระแบ่งตามภาษา. เช่น iso8859 เป็นฟอนต์สำหรับภาษาที่ใช้ในยุโรป, iso10646 เป็นฟอนต์แบบยูนิโค้ดมีอักขระของหลายชาติรวมในฟอนต์เดียว, tis620 เป็นฟอนต์ภาษาไทย เป็นต้น.
\item Encoding (\cmd{enc})\\
รายละเอียดย่อยของประเภทอักขระแบ่งตามภาษา. มีค่าเป็นตัวเลขและใช้ร่วมกับค่า character registry. เช่น iso8859-1 หมายถึงฟอนต์ลาติน (ภาษาอังกฤษและอักขระลาติน), tis620-0 หมายถึงฟอนต์ภาษาไทยพื้นฐาน เป็นต้น.
\end{itemize}


\subsubsection{การเลือกฟอนต์}
ในระบบ X วินโดว์มีโปรแกรมมาตรฐานที่ใช้เลือกฟอนต์แบบดั้งเดิมโดยระบุส่วนประกอบต่างๆเพื่อสร้างชื่อฟอนต์ XLFD ได้แก่โปรแกรม \cmd{xfontsel}\cindex{xfontsel}. โปรแกรมนี้จะแสดงตัวอย่างรูปทรงของอักขระให้เห็นด้วย.

\begin{figure}[!htb]
\plfigure{.6}{xfontsel.eps}{เลือกฟอนต์ด้วยโปรแกรม \cmd{xfontsel}.}{xfontsel}
\end{figure}


ในกรณีที่ต้องการตรวจสอบดูว่าฟอนต์หนึ่งๆประกอบด้วยอักขระอะไรบ้างและมีรูปร่างอย่างไร, ให้ใช้คำสั่ง \cmd{xfd}\cindex{xfd}\refcmd{xfd} และระบุชื่อฟอนต์ที่ต้องการตรวจสอบด้วยตัวเลือก \cmd{-fn \textit{fontname}}. ส่วนที่เป็นชื่อฟอนต์จะเป็นชื่อแบบ XLFD หรือนามแฝงก็ได้. ในหน้าจอจะแสดงอักขระต่างอยู่ในตาราง, ถ้าคลิ้กอักขระใดอักขระหนึ่งก็จะแสดงค่าของอักขระนั้นด้วยเลขฐานต่างๆให้ดูด้วย.

\begin{figure}[!htb]
\plfigure{.5}{xfd.eps}{แสดงอักขระที่อยู่ในฟอนต์.}{xfd}
\end{figure}

\subsubsection{การติดตั้งฟอนต์ใหม่ในระบบ}
การติดตั้งฟอนต์ใหม่ในระบบดั้งเดิมมีขั้นตอนต่อไปนี้.\gindex{ฟอนต์!การติดตั้ง}
\begin{enumerate}
\item สร้างไดเรกทอรีสำหรับเก็บฟอนต์\\
ผู้ใช้สามารถไดเรกทอรีสำหรับเก็บฟอนต์ไว้ที่ไหนก็ได้ไม่มีกำหนดตายตัว. ฟอนต์ของระบบโดยรวมมักจะอยู่ที่ \cmd{/usr/share/fonts} ซึ่งใต้ไดเรกทอรีนั้นแบ่งแยกเป็นไดเรกทอรีย่อยต่อไปอีก. สำหรับผู้ใช้ที่ไม่สิทธิ์สร้างไดเรกทอรีย่อยใต้ไดเรกทอรีนั้นสามารถเลือกสร้างไดเรกทอรีไว้ที่ไหนก็ได้.
\item ก็อปปี้ไฟล์ฟอนต์ไว้ในไดเรกทอรีที่ต้องการ\\
ในกรณีที่มีไฟล์ \cmd{.bdf} อาจจะแปลงเป็นไฟล์ \cmd{.pcf} ด้วยคำสั่ง \cmd{bdftopcf}\cindex{bdftopcf}\refcmd{bdftopcf} ก่อนเพื่อให้ขนาดเล็กลง. หลังจากนั้นอาจจะใช้ \cmd{gzip} บีบอักให้มีขนาดเล็กลงอีกก็ได้.
\begin{MyExample}[การแปลงฟอนต์ \cmd{.bdf} ให้เป็น \cmd{.pcf} และบีบอัดข้อมูล.]
\begin{MyEx}
$ \cin{bdftopcf thai8x16.bdf | gzip -c > thai8x16.pcf.gz}
\end{MyEx}
\end{MyExample}%$
ถ้าเป็นฟอนต์แบบทรูไทป์หรือ PostScript ไม่ต้องทำอะไรเพิ่มเติม.
\item สั่งคำสั่ง \cmd{mkfontscale}\\
สำหรับไดเรกทอรีที่มีฟอนต์เวคเตอร์เช่นฟอนต์ทรูไทป์หรือ PostScript, ให้สั่งคำสั่ง \cmd{mkfontscale}\cindex{mkfontscale}\refcmd{mkfontscale} เพื่อสร้างไฟล์ \cmd{fonts.scale}\findex{fonts.scale}.
\begin{MyExample}[สร้างไฟล์ \cmd{fonts.scale}.]
\begin{MyEx}
$ \cin{ls}
TlwgTypewriter.ttf  thai8x16.bdf
$ \cin{mkfontscale -a tis620-0} \mycomment{ระบุรหัสอักขระเพิ่มเติม}
$ \cin{ls}
TlwgTypewriter.ttf  fonts.scale  thai8x16.bdf
$ \cin{cat fonts.scale}
5
TlwgTypewriter.ttf -misc-tlwg typewriter-medium-r-normal--0-0-0-0-p-0-iso10646-1
TlwgTypewriter.ttf -misc-tlwg typewriter-medium-r-normal--0-0-0-0-p-0-iso8859-1
TlwgTypewriter.ttf -misc-tlwg typewriter-medium-r-normal--0-0-0-0-p-0-iso8859-11
TlwgTypewriter.ttf -misc-tlwg typewriter-medium-r-normal--0-0-0-0-p-0-tis620-0
TlwgTypewriter.ttf -misc-tlwg typewriter-medium-r-normal--0-0-0-0-p-0-tis620-2
\end{MyEx}
\end{MyExample}
คำสั่ง \cmd{mkfontscale} จะตรวจสอบไฟล์ฟอนต์แบบเวคเตอร์ที่อยู่ในไดเรกทอรีที่ทำงานอยู่และสร้างไฟล์ \cmd{fonts.scale} ให้. ตัวคำสั่งจะใช้ฐานข้อมูลรหัสอักขระที่อยู่ในไฟล์ \cmd{encodings.dir}\findex{encodings.dir} และโดยปริกติไฟล์นี้จะอยู่ในไดเรกทอรี \cmd{/usr/share/fonts/encodings}. จากตัวอย่าง, ตัวเลือก \cmd{-a tis620-0} เป็นการระบุรหัสอักขระเพิ่มเติมจากค่าปริยาย. ถ้าไม่ระบุ, ตัวโปรแกรมจะตรวจสอบว่ามีฟอนต์นั้นสามารถใช้รหัสอักขระอะไรได้บ้างแล้วเขียนไฟล์ \cmd{fonts.scale} ให้อัตโนมัติ.
\item สั่งคำสั่ง \cmd{mkfontdir}\\
คำสั่ง \cmd{mkfontdir}\cindex{mkfontdir} จะสำรวจฟอนต์บิตแมปที่อยู่ในไดเรกทอรีที่ทำงานอยู่และไฟล์ \cmd{fonts.scale} เพื่อใช้เป็นข้อมูลนำเข้าสร้างไฟล์ \cmd{fonts.dir}\findex{fonts.dir}. X เซิร์ฟเวอร์และฟอนต์เซิร์ฟเวอร์จะใช้ไฟล์นี้เป็นฐานข้อมูลสำหรับจับคู่ชื่อฟอนต์ XLFD และไฟล์ฟอนต์.

\begin{MyExample}[สร้างไฟล์ \cmd{fonts.dir}.]
\begin{MyEx}
$ \cin{mkfontdir}
6
TlwgTypewriter.ttf -misc-tlwg typewriter-medium-r-normal--0-0-0-0-p-0-iso10646-1
TlwgTypewriter.ttf -misc-tlwg typewriter-medium-r-normal--0-0-0-0-p-0-iso8859-1
TlwgTypewriter.ttf -misc-tlwg typewriter-medium-r-normal--0-0-0-0-p-0-iso8859-11
TlwgTypewriter.ttf -misc-tlwg typewriter-medium-r-normal--0-0-0-0-p-0-tis620-0
TlwgTypewriter.ttf -misc-tlwg typewriter-medium-r-normal--0-0-0-0-p-0-tis620-2
thai8x16.bdf -thai-fixed-medium-r-normal--16-114-100-100-p-100-tis620-0
\end{MyEx}
\end{MyExample}%$
\item สร้างไฟล์ \cmd{fonts.alias}\\
ถ้าต้องการตั้งชื่อสั้นๆให้กับชื่อฟอนต์ XLFD ให้สร้างไฟล์ \cmd{fonts.alias} โดยมีรูปแบบดังนี้
\begin{MyVerbatim}
<alias>    <XLFD name>
\end{MyVerbatim}
\begin{MyExample}[ไฟล์ \cmd{fonts.alias}.]
\begin{MyEx}
$ \cin{cat fonts.alias}
thai8x16 -thai-fixed-medium-r-normal--16-114-100-100-p-100-tis620-2
\end{MyEx}
\end{MyExample}%$
\item ทำให้ X เซิร์ฟเวอร์รับรู้ไดเรกทอรีที่เก็บฟอนต์\\
วิธีง่ายที่สุดที่จะทำให้ X เซิร์ฟเวอร์รับรู้ไดเรกทอรีที่เก็บฟอนต์ตัวใหม่อย่างถาวรคือการแก้ไฟล์ \cmd{xorg.conf} เพิ่มพารามิเตอร์ FontPath โดยมีค่าเป็นชื่อไดเรกทอรีที่เก็บฟอนต์ใหม่. ในกรณีนี้จะต้องเริ่มต้น X เซิร์ฟเวอร์ใหม่อีกครั้ง.

ถ้าต้องการตั้งค่า FontPath ให้ X เซิร์ฟเวอร์รับรู้ทันทีแบบชั่วคราว, สามารถทำได้โดยใช้คำสั่ง \cmd{xset}\cindex{xset}\refcmd{xset}. คำสั่ง \cmd{xset} เป็นคำสั่งที่ใช้ปรับแต่งพารามเตอร์ต่างๆเฉพาะบุคคลในระบบ X วินโดว์. เราสามารถเพิ่มค่า FontPath ได้ดังตัวอย่างต่อไปนี้.
\begin{MyExample}[เพิ่ม FontPath ชั่วคราว.]
\begin{MyEx}
$ \cin{xset fp+ ~/xfonts}
$ \cin{xset q}
\abb
Colors:
  default colormap:  0x20    BlackPixel:  0    WhitePixel:  16777215
Font Path:
  /usr/share/fonts/misc/,/usr/share/fonts/Type1/,/usr/share/fonts/75dpi/,/usr/\wrap
share/fonts/100dpi/,\textbf{/home/poonlap/xfonts/} \mycomment{ค่า \cmd{FontPath} ตัวใหม่}
Bug Mode: compatibility mode is disabled
DPMS (Energy Star):
  Standby: 7200    Suspend: 7200    Off: 14400
  DPMS is Disabled
File paths:
  Config file:  /etc/X11/xorg.conf
  Modules path: /usr/X11R6/lib/modules
  Log file:     /var/log/Xorg.0.log
$ \cin{xset fp rehash}
\end{MyEx}
\end{MyExample}%$

ในกรณีที่ใช้ฟอนต์เซิร์ฟเวอร์, ให้แก้ไฟล์ \cmd{/etc/X11/fs/config} เพิ่มไดเรกทอรีที่เก็บฟอนต์ใหม่และสั่งคำสั่ง \cmd{/etc/init.d/xfs restart}.
\item ตรวจสอบฟอนต์ใหม่ที่ติดตั้ง\\
ใช้คำสั่ง \cmd{xlsfonts} หรือโปรแกรม \cmd{xfd} ตรวจสอบดูว่า X เซิร์ฟเวอร์รับรู้ฟอนต์ที่ติดตั้งใหม่หรือไม่.
\end{enumerate}


\subsection{ฟอนต์ในระบบ Xft}
ตามที่ได้แนะนำไปแล้วว่าในระบบฟอนต์แบบดั้งเดิมสามารถใช้ฟอนต์ได้ทั้งแบบบิตแมปและฟอนต์เวกเตอร์. อย่างไรก็ตามวิธีการจัดการฟอนต์แบบดั้งเดิมยังขาดความสมบูรณ์อยู่หลายประการเช่นชื่อฟอนต์แบบ XLFD ยาวยุ่งยากไม่เหมาะกับการใช้งานจริง, วิธีการติดตั้งและระบุการใช้ฟอนต์ยุ่งยาก ฯลฯ. สาเหตุต่างๆเหล่านี้เป็นที่มาของระบบฟอนต์ Xft.

\emph{Xft (X FreeType Interface library)}\gindex{xft@Xft|see{X FreeType Interface library}}\gindex{x freetype interface library@X FreeType Interface library} เป็นไลบรารีสำหรับแสดงรูปทรงอักขระของฟอนต์ในระบบ X วินโดว์โดยใช้ไลบรารี FreeType. ปัจจุบันโปรแกรม GUI สมัยใหม่ที่ใช้ทูลล์คิต Gtk+ หรือ Qt หันมาใช้ไลบรารี Xft เป็นหลักทำให้การกำหนดชื่อฟอนต์ง่ายขึ้น, แสดงผลอักขระแบบแอนติอเลียสได้ ฯลฯ. ในระบบ Xft ยังแยกเป็น Xft1\gindex{xft1@Xft1} และ Xft2 ซึ่งเป็นไลบรารีเดียวกันแต่คนละรุ่น, และ API แตกต่างกันทำให้ผู้ใช้และผู้พัฒนาซอฟต์แวร์ต้องระวังเวลาใช้.

ไลบรารี Xft2 เป็นไลบรารีสำหรับจัดการแสดงผล, ส่วนการจัดการปรับแต่งฟอนต์และการระบุชื่อฟอนต์ที่ต้องการใช้นั้นจะใช้ไลบรารีและชุดคำสั่งต่างหากที่เรียกว่า \emph{fontconfig}\gindex{fontconfig}. การจัดการฟอนต์แบบ fontconfig จะมีไฟล์ปรับแต่งของระบบโดยรวมได้แก่ \cmd{/etc/fonts/fonts.conf}\findex{fonts.conf}. ถ้าเป็นการปรับแต่งในระดับบุคคลจะใช้ไฟล์ \cmd{\~{}/.fonts.conf}\findex{.fonts.conf} ซึ่งมีรูปแบบของไฟล์เหมือนกันเป็นแบบ XML.%
\myvocab{x}{XML}{Extensible Markup Language. รูปแบบข้อมูลเท็กซ์ใช้คำที่กำหนดไว้เรียกว่า tag กำกับส่วนต่างๆให้มีความหมายต่างๆ. XML เป็นฟอร์แมตที่สร้างสืบทอดมาจาก SGML (Standard Generalized Markup Language) เช่นเดียวกันกับ HTML (HyperText Markup Language). HTML จะเป็นซับเซ็ตของ XML.}%

\subsubsection{ไฟล์ \cmd{fonts.conf}}
ในไฟล์ \cmd{fonts.conf} จะมีส่วนที่ระบุไดเรกทอรีที่เก็บฟอนต์ด้วย \cmd{<dir>...</dir>} และมีผลไปถึงไดเรกทอรีย่อยที่อยู่ใต้ไดเรกทอรีที่ระบุด้วย.
\begin{MyExample}[ส่วนที่ระบุไดเรกทอรีฟอนต์ในไฟล์ \cmd{/etc/fonts/fonts.conf}]
\begin{MyEx}
$ \cin{cat /etc/fonts/fonts.conf}
\abb
        <dir>/usr/share/fonts</dir>
        <dir>/usr/local/share/fonts</dir>
        <dir>~/.fonts</dir> \mycomment{ไดเรกทอรีสำหรับเก็บฟอนต์เฉพาะบุคคล}
\abb
\end{MyEx}
\end{MyExample}%$

ในไฟล์ \cmd{fonts.conf} สามารถรวมไฟล์ตั้งค่าเริ่มต้นจากไฟล์อื่นๆได้ด้วยโดยใช้ไวยกรณ์ \cmd{<include>...</include>}. ถ้าต้องการปรับแต่งระบบ fontconfig จะไม่แก้ไฟล์ \cmd{fonts.conf} โดยตรงแต่จะแก้ไขไฟล์ \cmd{/etc/fonts/local.conf}\findex{local.conf} แทน. ส่วนไฟล์ \cmd{\~{}/.fonts.conf} จะเป็นไฟล์ตั้งค่าเริ่มต้นของระบบ fontconfig เฉพาะบุคคล.
\begin{MyExample}[ส่วนที่รวมไฟล์ปรับตั้งค่าเริ่มอื่นๆในไฟล์ \cmd{/etc/fonts/fonts.conf}.]
\begin{MyEx}
$ \cin{cat /etc/fonts/fonts.conf}
\abb
<!--
  Load per-user customization file
-->
        <include ignore_missing="yes">~/.fonts.conf</include>

<!--
  Load local system customization file
-->
        <include ignore_missing="yes">local.conf</include>
\abb
\end{MyEx}
\end{MyExample}%$

\subsubsection{ชื่อฟอนต์สามัญและฟอนต์ที่ใช้จริง}
\begin{figure}[!htb]
\plfigure{.35}{font-family.eps}{ชื่อฟอนต์สามัญที่ใช้ในระบบ fontconfig.}{font-family}
\end{figure}
ในระบบจัดการฟอนต์แบบ fontconfig จะมีตระกูลฟอนต์ (family) ที่เป็นตัวแทนฟอนต์อื่นๆที่ใช้จริงได้แก่
\begin{itemize}
\item Serif\gindex{serif} หมายถึงฟอนต์ที่มีส่วนประดับตรงปลายเส้นของรูปทรงอักขระ.
\item Sans-serif\gindex{sans-serif} หมายถึงฟอนต์ที่ไม่มีส่วนประดับตรงปลายเส้นของรูปทรงอักขระ.
\item Monospace\gindex{monospace} หมายถึงฟอนต์ที่อักขระทุกตัวมีความกว้างเท่ากัน.
\end{itemize}
ในไฟล์ \cmd{fonts.conf} มีส่วนที่กำหนดชื่อฟอนต์จริงที่ใช้แทนชื่อฟอนต์สามัญในช่วง \cmd{<alias>...</alias>}.
\begin{MyExample}[กำหนดชื่อฟอนต์สามัญและชื่อฟอนต์ที่ใช้จริง.]
\begin{MyEx}
$ \cin{cat /etc/fonts/fonts.conf}
\abb
        <alias>
                <family>Bitstream Vera Serif</family>
                <family>Times New Roman</family>
                <family>Luxi Serif</family>
                <family>Kochi Mincho</family>
                <default><family>serif</family></default>
        </alias>
\abb
\end{MyEx}
\end{MyExample}%$
ถ้าในแอพพลิเคชันเลือกใช้ฟอนต์ serif, ระบบ fontconfig จะเลือกฟอนต์ที่ใช้จริงจากรายชื่อฟอนต์ที่กำหนด, ในตัวอย่างได้แก่ ``Bitstream Vera Serif'', ``Times New Roman'' ฯลฯ ตามลำดับ.

\medskip
ความสามารถของ fontconfig อื่นๆในการเลือกฟอนต์ยังมีอีกมากมายเช่นผู้ใช้สามารถตั้งเงื่อนไขถ้าขนาดของฟอนต์เล็กกว่าที่กำหนดแล้วให้ใช้ฟอนต์บิตแมปแทนการแอนติอเลียสเป็นต้น.


\subsubsection{ชื่อฟอนต์}
คำสั่งที่ใช้แสดงชื่อฟอนต์ในระบบ fontconfig ได้แก่ \cmd{fc-list}\cindex{fc-list}.
\begin{MyExample}[แสดงชื่อฟอนต์ในระบบ fontconfig.]
\begin{MyEx}
$ \cin{fc-list}
Luxi Serif:style=Regular
LucidaBright:style=Italic
Utopia:style=Bold Italic
Nimbus Sans L:style=Regular Italic
Bitstream Vera Sans Mono:style=Bold
\abb
\end{MyEx}
\end{MyExample}%$
ชื่อฟอนต์ในระบบ fontconfig มีรูปแบบดังต่อไปนี้.
\begin{MyVerbatim}
\textit{families}-\textit{point}:\textit{name1}=\textit{values1}:\textit{name2}=\textit{values2}...
\end{MyVerbatim}
\begin{itemize}
\item \textit{families}\\
ชื่อตระกูลฟอนต์ (ชื่อฟอนต์) เช่น Times, Luxi Serif ฯลฯ.
\item \textit{point}\\
ขนาดของอักขระในหน่วยพอยต์. ตัวอย่างเช่น ``Times-12'' หมายถึงฟอนต์ Times ขนาด 12 พอยต์.
\item \textit{nameN}, \textit{valueN}\\
ชื่อคุณสมบัติและค่าของฟอนต์.

\begin{longtable}{lp{.75\textwidth}l}
\caption{คุณสมบัติต่างๆของฟอนต์.}\label{tab:fontproperties}\\
\toprule
\multicolumn{1}{c}{ชื่อคุณสมบัติ} & \multicolumn{1}{c}{ความหมาย}\\
\midrule
style & รูปทรงของอักขระเช่น Recular, Italic, Bold, Bold Italic ฯลฯ.\\
weight & ความหนักของอักขระได้แก่ light, medium, demibold, bold หรือ black.\\
size & ขนาดอักขระหน่วยเป็นพอยต์.\\
pixelsize &ขนาดอักขระในหน่วยพิกเซล.\\
spacing & คุณสมบัติความกว้างของอักขระ proportional, monospace หรือ charcell.\\
foundry & ชื่อตระกูลฟอนต์.\\
outline & ฟอนต์นั้นเป็นฟอนต์แบบเอาท์ไลน์ (true) หรือไม่ (false).\\
scalable & ฟอนต์นั้นเป็นฟอนต์ที่ย่อขยายได้ (true) หรือไม่ (false).\\
lang & ภาษาของอักขระในฟอนต์เช่น th, ja ฯลฯ.\\
\bottomrule
\end{longtable}
\end{itemize}

คำสั่ง \cmd{fc-list} นอกจะใช้แสดงชื่อฟอนต์ต่างๆที่มีอยู่ในระบบแล้วยังสามารถแสดงชื่อฟอนต์ตามเงื่อนไขที่ต้องการโดยระบุคุณสมบัติของฟอนต์.
\begin{MyExample}[หาชื่อฟอนต์โดยระบุคุณสมบัติ.]
\begin{MyEx}
$ \cin{fc-list :lang=th:scalable=true} \mycomment{ฟอนต์ภาษาไทยและสามารถย่อขยายได้}
Tlwg Typewriter:style=Bold
Norasi:style=Oblique
TlwgMono:style=Medium
Norasi:style=BoldOblique
DBThaiText:style=Medium
PseudoMono:style=Bold
Loma:style=Oblique
\abb
$ \cin{fc-list :lang=th:scalable=false} \mycomment{ฟอนต์ภาษาไทยแบบบิตแมป}
Fixed:style=Bold
Fixed:style=SemiCondensed
ClearlyU:style=Regular
Fixed:style=Oblique
Fixed:style=Regular
$ \cin{fc-list : family file} \mycomment{แสดงชื่อไฟล์ของฟอนต์และชื่อตระกูลฟอนต์}
/usr/share/fonts/75dpi/UTB___18.pcf.gz: Utopia
/usr/share/fonts/Type1/l048033t.pfa: Luxi Sans
/usr/X11R6/lib/X11/fonts/100dpi/courO12.pcf.gz: Courier
/usr/share/fonts/75dpi/timB12.pcf.gz: Times
\abb
\end{MyEx}
\end{MyExample}%$

โปรแกรมที่ใช้ดูอักขระต่างๆที่อยู่ในฟอนต์ได้แก่ \cmd{xfd} แต่จะใช้ตัวเลือก \cmd{-fa \textit{fontname}} สำหรับระบุชื่อฟอนต์ในระบบ fontconfig. ตัวอย่างเช่นคำสั่ง ``\cmd{xfd -fa Fixed-12:lang=th:scalable=false}'' แสดงอักขระต่างๆของฟอนต์ Fixed ที่เป็นภาษาไทย.

\begin{figure}[!htb]
\plfigure{.7}{xfd-fa.eps}{ระบุชื่อฟอนต์ในระบบ fontconfig ให้กับโปรแกรม \cmd{xfd}.}{xfd-fa}
\end{figure}

\subsubsection{ลำดับการเลือกฟอนต์ในระบบ fontconfig}
สำหรับโปรแกรมที่ใช้ระบบ fontconfig และมีการใช้ฟอนต์เป็นชื่อสามัญเช่น Serif, ระบบ fontconfig จะหาฟอนต์จริงที่เหมาะสมให้กับโปรแกรมใช้แสดงผล. การใช้ชื่อฟอนต์สามัญในลักษณะนี้เป็นการลดภาระของตัวโปรแกรมโดยที่ตัวโปรแกรมไม่ต้องรับรู้ชื่อฟอนต์จริงๆซึ่งถ้าเป็นเครื่องคอมพิวเตอร์คอมคนละเครื่องกันก็ยังใช้ชื่อฟอนต์สามัญเหมือนกันได้.

fontconfig รุ่น 2.3.x จะมีโปรแกรม \cmd{fc-match}\cindex{fc-match} ใช้ตรวจดูว่า fontconfig เลือกฟอนต์อะไรในการใช้งานจริง.

\begin{MyExample}[รายชื่อฟอนต์ที่ fontconfig จะเลือกใช้.]\label{ex:fc-match}
\begin{MyEx}
$ \cin{fc-match :family=serif} \mycomment{แสดงชื่อฟอนต์ที่ใช้จริงสำหรับ \cmd{serif}}
VeraSe.ttf: "Bitstream Vera Serif" "Roman"
$ \cin{fc-match --sort :family=serif} \mycomment{แสดงรายชื่อฟอนต์ที่ใช้จริงสำหรับ \cmd{serif}}
VeraSe.ttf: "Bitstream Vera Serif" "Roman"
n021004l.pfb: "Nimbus Roman No9 L" "Medium"
kochi-mincho-subst.ttf: "Kochi Mincoh" "Regular"
Norasi.ttf: "Norasi" "Regular"
\abb
$ \cin{LANG=th_TH fc-match :family=serif}
Norasi.ttf: "Norasi" "Regular" \mycomment{ฟอนต์ภาษาไทยที่ถูกเลือกเป็นฟอนต์ \cmd{serif}}
\end{MyEx}
\end{MyExample}%$
จากตัวอย่างข้างบนจะเห็นว่าในระบบจะเลือกใช้ฟอนต์ ``Bitstream Vera Serif'' เป็นฟอนต์ serif โดยปริยายและถ้าไม่สามารถใช้ฟอนต์ ``Bitstream Vera Serif'' ได้ก็จะเลือกฟอนต์ที่เหมาะสมถัดมาตามลำดับ.

ในกรณีที่โปรแกรมต้องแสดงผลหลายภาษา, ระบบ fontconfig จะเลือกฟอนต์ที่เหมาะสมกับภาษานั้น. จากตัวอย่างที่ \ref{ex:fc-match}, fontconfig จะใช้ฟอนต์ Norasi เป็นฟอนต์ serif เพราะเป็นฟอนต์แรกในรายการที่สามารถแสดงอักขระภาษาไทยได้. ถ้าต้องการใช้ฟอนต์อื่นเช่น Kinnari เป็นฟอนต์ serif แทนฟอนต์ Norasi ต้องปรับแต่งระบบ fontconfig โดยเพิ่มบรรทัดต่อไปนี้ไฟล์ปรับแต่ง \cmd{\~{}/.fonts.conf} หรือ \cmd{/etc/fonts/local.conf}.

\begin{shaded}
\begin{MyExample}[จัดลำดับฟอนต์ที่ต้องการใช้.]
\begin{MyEx}
<fontconfig>
    <alias>
        <family>serif</family>
        <prefer>
            <family>Bitstream Vera Serif</family>
            <family>Kinnari</family>
            <family>Norasi</family>
        </prefer>
    </alias>
    <alias>
        <family>sans-serif</family>
        <prefer>
            <family>Bitstream Vera Sans</family>
            <family>Loma</family>
            <family>Garuda</family>
        </prefer>
    </alias>
    <alias>
        <family>monospace</family>
        <prefer>
            <family>Bistream Vera Sans Mono</family>
            <family>Tlwg Typewriter</family>
            <family>TlwgMono</family>
        </prefer>
    </alias>
</fontconfig>
\end{MyEx}
\end{MyExample}
\end{shaded}
ชื่อฟอนต์ที่อยู่ในช่วง \cmd{<prefer>...</prefer>} จะเป็นช่วงที่ผู้ใช้กำหนดลำดับฟอนต์ที่ต้องการใช้ให้ fontconfig รับรู้. ในตัวอย่างจะเอาชื่อฟอนต์ภาษาอังกฤษขึ้นนำเป็นตัวแรกเพราะเป็นฟอนต์ที่มีคุณภาพสูงและโปรแกรมที่ใช้ส่วนใหญ่จะเป็นภาษาอังกฤษ. ถ้าโปรแกรมต้องการแสดงภาษาไทยก็จะเลือกฟอนต์ภาษาไทยที่ระบุไว้ถัดมาตามลำดับ.

\begin{MyExample}[ผลของคำสั่ง \cmd{fc-match} หลังจากแก้ไขไฟล์ \cmd{\~{}/.fonts.conf}.]
\begin{MyEx}
$ \cin{LANG=C fc-match :family=serif}
VeraSe.ttf: "Bitstream Vera Serif" "Roman"
$ \cin{LANG=th_TH fc-match :family=serif}
Kinnari.ttf: "Kinnari" "Medium"
$ \cin{LANG=ja_JP fc-match :family=serif}
kochi-mincho-subst.ttf: "Kochi Mincho" "Regular"
\end{MyEx}
\end{MyExample}%$


\section{วิธีการติดตั้งฟอนต์}
วิธีการติดตั้งฟอนต์ของระบบ fontconfig ง่ายกว่าระบบดั้งเดิมมาก. สรุปขั้นตอนต่างๆได้ดังนี้.
\begin{enumerate}
\item ก็อปปี้ไฟล์ฟอนต์ไว้ในไดเรกทอรีที่ระบบ fontconfig รับรู้\\
ถ้าต้องการติดตั้งฟอนต์สำหรับทั้งระบบ, ให้ก็อปปี้ฟอนต์ใหม่หรือสร้างสร้างไดเรกทอรีเก็บฟอนต์ใหม่ใต้ไดเรกทอรีที่กำหนดในช่วง \cmd{<dir>...</dir>} ในไฟล์ \cmd{fonts.conf} เช่นใต้ไดเรกทอรี \cmd{/usr/share/fonts}.

ถ้าเป็นการติดตั้งฟอนต์เฉพาะบุคคล, สามารถก็อปปี้ฟอนต์ใหม่เก็บไว้ในไดเรกทอรี \cmd{\~{}/.fonts}.
\item สั่งคำสั่ง \cmd{fc-cache} เพื่อสร้างฐานข้อมูลฟอนต์\\
คำสั่ง \cmd{fc-cache}\cindex{fc-cache}\refcmd{fc-cache} จะสร้างไฟล์ \cmd{fonts.cache} ในไดเรกทอรีที่เก็บฟอนต์เพื่อเป็นฐานข้อมูลสำหรับการเรียกใช้ฟอนต์. โดยปรกติมักจะใช้ตัวเลือก \cmd{-fv} เพื่อบังคับให้อัปเดตฐานข้อมูลและแสดงข้อมูลการทำงานบนหน้าจอ.
\begin{MyExample}[สร้างฐานข้อมูลฟอนต์ในระบบ fontconfig.]
\begin{MyEx}
$ \cin{fc-cache -fv}
fc-cache: "/usr/X11R6/lib/X11/fonts/Type1": skipping, no write access
fc-cache: "/usr/share/fonts": skipping, no write access
fc-cache: "/usr/local/share/fonts": skipping, no write access
fc-cache: "/usr/X11R6/lib/X11/fonts/75dpi": skipping, no write access
fc-cache: "/usr/X11R6/lib/X11/fonts/100dpi": skipping, no write access
fc-cache: "/home/poonlap/.fonts": caching, 8 fonts, 0 dirs
fc-cache: "/usr/X11R6/lib/X11/fonts/truetype": skipping, no such directory
fc-cache: succeeded
\end{MyEx}
\end{MyExample}%$
จากตัวอย่างจะเห็นว่าตัวโปรแกรมไม่สามารเข้าถึงไดเรกทอรีบางตัวได้สามารถแก้ไขโดยการรันคำสั่งด้วยยูสเซอร์ที่มีสิทธิ์เขียนไฟล์ในไดเรกทอรีนั้นเช่น root.
\end{enumerate}

สำหรับสภาพแวดล้อมเดส์กทอป GNOME, วิธีที่ง่ายๆอีกวิธีหนึ่งคือใช้โปรแกรม \cmd{nautilus} ซึ่งเป็นไฟล์เบราเซอร์เปิดไปที่ \cmd{fonts://} เพื่อแสดงฟอนต์ต่างๆในระบบ. หลังจากนั้นผู้ใช้สามารถดึงและลากฟอนต์ตัวใหม่เข้าไปในหน้าต่างนั้น, จะถือว่าเป็นการติดตั้งฟอนต์ซึ่งให้ผลเหมือนกันก็อปปี้ฟอนต์ไปที่ไดเรกทอรี \cmd{\~{}/.fonts}.
\begin{figure}[!htb]
\plfigure{.5}{nautilus-fonts.eps}{หน้าจอ nautilus แสดงฟอนต์ต่างๆในระบบ.}{nautilus-fonts}
\end{figure}

\section{ปรับแต่งแป้นพิมพ์}
เวลาเรากดคีย์ต่างๆบนแป้นพิมพ์, X เซิร์ฟเวอร์จะรับรู้คีย์ที่กดเป็นคีย์โค้ดและแปลงคีย์โค้ดนั้นเป็นอักขระ (คีย์ซิม) ตามตารางที่เตรียมไว้. ตารางสำหรับแปลงคีย์โค้ดเป็นคีย์ซิมนี้เรียกว่า\emph{คีย์แมป (keymap)}\gindex{คีย์แมป}\gindex{keymap}.

คีย์แต่ละคีย์บนแป้นพิมพ์ที่กดจะมีค่าคีย์โค้ดและคีย์ซิม. ค่าเหล่านี้สามารถสำรวจได้จากโปรแกรม \cmd{xev}\gindex{xev}. โปรแกรม \cmd{xev} เป็นโปรแกรมมาตรฐานในระบบ X วินโดว์สำหรับแสดงอิเวนต์ (event) ต่างๆในระบบ X วินโดว์. ตัวโปรแกรมจะแสดงหน้าต่างว่างๆ, ถ้ามีอิเวนต์ต่างๆเกิดขึ้นเช่นการกดคีย์บนแป้นพิมพ์, คลิ้กเมาส์ ก็จะแสดงรายละเอียดของอิเวนต์ที่เกิดขึ้นทางเทอร์มินอลที่รันโปรแกรมนั้น.
\begin{figure}[!htb]
\plfigure{.5}{xev.eps}{สำรวจค่าคีย์โค้ดและคีย์ซิมด้วย \cmd{xev}.}{xev}
\end{figure}

\begin{MyExample}[สำรวจค่าคีย์โค้ดและคีย์ซิมด้วยคำสั่ง \cmd{xev}.]\label{ex:xev}
\begin{MyEx}
$ \cin{xev &}
\abb
KeyPress event, serial 31, synthetic NO, window 0x2c00001, \mycomment{เกิดการกดคีย์}
    root 0x60, subw 0x2c00002, time 10005895, (24,44), root:(1116,842),
    state 0x0, keycode 38 (keysym 0x61, a), same_screen YES, \mycomment{ค่าคีย์โค้ดและคีย์ซิม}
    XLookupString gives 1 bytes: (61) "a"
    XmbLookupString gives 1 bytes: (61) "a"
    XFilterEvent returns: False

KeyRelease event, serial 31, synthetic NO, window 0x2c00001, \mycomment{เกิดการปล่อยคีย์}
    root 0x60, subw 0x2c00002, time 10005975, (24,44), root:(1116,842),
    state 0x0, keycode 38 (keysym 0x61, a), same_screen YES,
    XLookupString gives 1 bytes: (61) "a"
\abb
\end{MyEx}
\end{MyExample}%$

ถ้ามีการกดคีย์ ``a'', คำสั่ง \cmd{xev} ก็จะแสดงอิเวนต์ตอนกด (KeyPress event) และอิเวนต์ตอนปล่อยคีย์ (KeyRelease event) พร้อมกับค่าคีย์โค้ดและคีย์ซิมของคีย์ที่กดตามตัวอย่างที่ \ref{ex:xev}\mymemo{ถ้าคลิ้กเมาส์ปุ่มต่างๆก็จะแสดงเลขปุ่มของเมาส์ที่คลิ้กเช่นปุ่มซ้ายมีหมายเลขเป็น 1 ฯลฯ.}. เมื่อรู้ค่าคีย์โค้ดของคีย์ที่ต้องการ, ผู้ใช้สามารถปรับแต่งคีย์โค้ดให้สัมพันธ์กับคีย์ซิมตามที่ต้องการด้วยคำสั่ง \cmd{xmodmap}.

คำสั่ง \cmd{xmodmap} เป็นคำสั่งที่ใช้ปรับแต่งคีย์ต่างๆและแสดงคีย์แมปของแป้นพิมพ์ได้ด้วย. ตัวอย่างต่อไปนี้เป็นผลลัพธ์ของคำสั่ง \cmd{xmodmap} กับตัวเลือก \cmd{-pke} แสดงค่าคีย์โค้ดและคีย์ซิมของแป้นพิมพ์ภาษาไทย.
\begin{MyExample}[แสดงคีย์โค้ดและคีย์ซิมด้วยคำสั่ง \cmd{xmodmap}.]
\begin{MyEx}
$ \cin{xmodmap -pke}
keycode   8 =
keycode   9 = Escape
keycode  10 = 1 exclam Thai_baht Thai_lakkhangyao
keycode  11 = 2 at slash Thai_leknung
keycode  12 = 3 numbersign minus Thai_leksong
keycode  13 = 4 dollar Thai_phosamphao Thai_leksam
keycode  14 = 5 percent Thai_thothung Thai_leksi EuroSign
\abb
\end{MyEx}
\end{MyExample}%$
คีย์โค้ดที่แสดงจะเป็นตัวเลขฐานสิบและคีย์ซิมเช่น \cmd{Escape}, \cmd{1}, \cmd{exclam}, \cmd{Thai\_baht} ฯลฯ เป็นสายอักขระที่กำหนดไว้ในไฟล์ \cmd{/usr/include/X11/keysymdef.h}\findex{keysymdef.h}.

จะเห็นได้ว่าคีย์โค้ดหนึ่งสามารถมีค่าคีย์ซิมได้มากกว่าหนึ่งตัว. ถ้าเป็นแป้นพิมพ์ภาษาอังกฤษอย่างเดียวคีย์โค้ดหนึ่งตัวจะมีคีย์ซิมที่ตั้งค่าไว้ไม่เกิน 2 ตัว. คีย์ซิมตัวแรกจะเป็นค่าอักขระเมื่อกดคีย์นั้นและคีย์ซิมตัวที่สองจะเป็นค่าอักขระที่กดคีย์นั้นพร้อมกับคีย์ Shift. ในกรณีที่เป็นแป้นพิมพ์ภาษาอักกฤษกับภาษาที่สองอื่นๆเช่นแป้นพิมพ์ภาษาไทย, คีย์โค้ดหนึ่งตัวจะมีคีย์ซิมที่ตั้งค่าไว้ 2 กลุ่ม, แต่ละกลุ่มจะมีคีย์ซิมอยู่ 2 ค่า. กลุ่มแรกจะเป็นกลุ่มคีย์ซิมที่เกี่ยวข้องกับภาษาอังกฤษและกลุ่มที่สองจะเป็นคีย์ซิมที่เกี่ยวข้องกับภาษาไทย. การปรับแต่งแป้นพิมพ์ให้ใช้ภาษาไทยสามารถใช้คำสั่ง \cmd{xmodmap} ปรับแต่งได้, แต่จะยุ่งยากและถือเป็นวิธีที่ล้าสมัยไปแล้ว. ในปัจจบันมักจะนิยมใช้คุณสมบัติของ X เซิร์ฟเวอร์ได้แก่ XKB ปรับแต่งแป้นคีย์บอร์ดภาษาไทยแทน.

ตัวอย่างการใช้งานจริงของคำสั่ง \cmd{xmodmap} เช่นการสลับตำแหน่งสลับตำแหน่งของคีย์ Control กับตำแหน่งของ Caps Lock. ในกรณีนี้จะต้องเตรียมไฟล์ที่รวมคำสั่งที่ใช้กับ \cmd{xmodmap} และใช้ชื่อไฟล์นั้นเป็นอาร์กิวเมนต์ของคำสั่ง \cmd{xmodmap}.
\begin{MyExample}[สลับตำแหน่งคีย์ Control และ Caps Lock โดยใช้ \cmd{xmodmap}.]
\begin{MyEx}
$ \cin{cat ~/.Xmodmap} \mycomment{ไฟล์ที่เตรียมคำสั่งสำหรับ \cmd{xmodmap}}
remove Lock = Caps_Lock \mycomment{เอาคีย์โมดิไฟเออร์ \cmd{Lock} ออกจากคีย์ซิม \cmd{Caps_Lock}}
remove Control = Control_L \mycomment{เอาคีย์โมดิไฟเออร์ \cmd{Control} ออกจากคีย์ซิม \cmd{Control_L}}
keysym Control_L = Caps_Lock
keysym Caps_Lock = Control_L \mycomment{สลับคีย์ซิมระหว่าง \cmd{Control_L} กับ \cmd{Caps_Lock}}
add Lock = Caps_Lock \mycomment{เพิ่มโมดิไฟเออร์คีย์ \cmd{Lock} ให้คีย์ซิม \cmd{Caps_Lock}}
add Control = Control_L \mycomment{เพิ่มโมดิไฟเออร์คีย์ \cmd{Control} ให้คีย์ซิม \cmd{Control_L}}
$ \cin{xmodmap ~/.Xmodmap}
\end{MyEx}
\end{MyExample}
ในตัวอย่างจะเตรียมไฟล์ชื่อ \cmd{\~{}/.Xmodmap} ซึ่งดิสโทรส่วนใหญ่จะใช้คำสั่ง \cmd{xmodmap} เรียกอ่านไฟล์นี้โดยอัตโนมัติตอนเริ่ม X เซิร์ฟเวอร์.

ผู้อ่านสามารถอ่านรายละเอียดไวยกรณ์ของคำสั่ง \cmd{xmodmap} ได้จาก \cmd{man xmodmap} ซึ่งจะไม่อธิบายในหนังสือเล่มนี้.

\subsection{ปรับแต่งแป้นฟิมพ์ด้วย XKB}
การปรับแต่งแป้นพิมพ์ด้วย \cmd{xmodmap} เป็นวิธีแบบดั้งเดิม, ปัจจุบันจะใช้ XKB ปรับแต่งแป้นพิมพ์แทนซึ่งจะง่ายกว่าแบบเดิม. การปรับแต่งแป้นพิมพ์ด้วย XKB สามารถทำได้ในระบบโดยรวมด้วยการปรับแต่งไฟล์ \cmd{xorg.conf} ซึ่งเป็นไฟล์ตั้งค่าเริ่มต้นของ X เซิร์ฟเวอร์หรือใช้คำสั่งที่เกี่ยวข้องกับ XKB ปรับแต่งแป้นพิมพ์.
\subsubsection{ปรับแต่งแป้นพิมพ์ภาษาไทยสำหรับระบบโดยรวม}
การปรับแต่งแป้นพิมพ์ภาษาไทยสำหรับระบบโดยรวมทำได้โดยเพิ่มบรรทัดต่อไปนี้ในไฟล์ \cmd{xorg.conf} ในเซกชัน ``InputDevice''.
\begin{MyEx}
Option    "XkbLayout"     "us,th_tis"
Option    "XkbOptions"    "grp:alt_shift_toggle,grp_led:scroll,lv3:ralt_switch"
\end{MyEx}
ความหมายของพารามิเตอร์ที่เกี่ยวข้องได้อธิบายไปแล้วในหน้าที่ \pageref{sec:thkb}.

\subsubsection{ปรับแต่งแป้นพิมพ์ภาษาไทยเฉพาะบุคคล}
โปรแกรมคำสั่งที่เกี่ยวข้องกับ XKB มีหลายคำสั่ง, ส่วนคำสั่งที่ใช้ปรับแต่งแป้นพิมพ์โดยตรงซึ่งยูสเซอร์ทั่วไปสามารถใช้ได้ด้วยได้แก่ \cmd{setxkbmap}\cindex{setxkbmap}. คุณสมบัติสำคัญๆที่ปรับแต่งได้ด้วยคำสั่ง \cmd{setxkbmap} ได้แก่
\begin{itemize}
\item ประเภทของแป้นพิมพ์เชิงฮาร์ดแวร์ (model)\\
ถ้าแบ่งประเภทของแป้นพิมพ์ในเชิงฮาร์ดแวร์แล้วสามารถแยกออกไดเป็นหลายประเภท. แป้นพิมพ์บางรุ่นมีปุ่มพิเศษเช่นปุ่มวินโดวส์, บ้างก็ไม่มีปุ่มนี้ ฯลฯ. XKB แบ่งประเภทของแป้นพิมพ์เชิงฮาร์ดแวร์ไว้หลายๆแบบโมเดล (model). ประเภทของแป้นพิมพ์ที่ใช้กันทั่วไปคือ pc101 ซึ่งหมายถึงแป้นพิมพ์ทั่วไปที่มีคีย์ 101 คีย์เช่นตัวอย่างในรูปที่ \ref{fig:kedmanee}. นอกจากนี้ยังมีแป้นพิมพ์ประเภทอื่นๆอีกเช่น pc102, pc104, pc105, jp106, microsoft (Microsoft Natural keyboard) เป็นต้น.

คำสั่ง \cmd{setxkbmap} สามารถใช้เลือกประเภทของแป้นด้วยตัวเลือก \cmd{-model} ตามด้วยชื่อประเภทแป้นพิมพ์ต่างๆในไฟล์ \cmd{/etc/X11/xkb/rules/xorg.lst}\findex{xorg.lst}.

\begin{MyExample}[ปรับแต่งประเภทแป้นพิมพ์.]
\begin{MyEx}
$ \cin{setxkbmap -model microsoft}
\end{MyEx}
\end{MyExample}%$

\begin{figure}[!htb]
\plfigure{.75}{natural_keyboard.eps}{แป้นพิมพ์ Microsoft Natural ซึ่งจำนวนปุ่มและรูปร่างต่างจากแป้นพิมพ์อื่นๆ.}{natural_keyboard}
\end{figure}

\item ผังแป้นพิมพ์ (layout)\\
ผังแป้นพิมพ์คือประเภทของแป้นพิมพ์ในเชิงซอฟต์แวร์, ได้แก่การมอบหมายให้คีย์ต่างๆแทนอักขระที่กำหนดไว้. ผังแป้นพิมพ์ยังเกี่ยวข้องกับภาษาเช่นแป้นพิมพ์แบบ pc101 สามารถเป็นได้ทั้งแป้นพิมพ์ภาษาอังกฤษและแป้นพิมพ์ภาษาไทย. ในบางกรณีแป้นพิมพ์ภาษาเดียวกันยังสามารถมีผังแป้นพิมพ์ได้หลายแบบ. สำหรับภาษาอังกฤษมีผังแป้นพิมพ์หลักๆได้แก่ qwerty\gindex{qwerty} และ dvorak\gindex{dvorak}. สำหรับแป้นพิมพ์ภาษาไทยมีผังแป้นพิมพ์แบบเกษมณี, ปัตตโชติ และ มอก.820.

คำสั่ง \cmd{setxkbmap} ใช้เลือกผังแป้นพิมพ์ด้วยตัวเลือก \cmd{-layout}. ผู้ใช้สามารถระบุชื่อผังแป้นพิมพ์ได้มากกว่าหนึ่งแบบโดยใช้เครื่องหมาย , คั่นระหว่างชื่อผังแป้นพิมพ์.

\begin{MyExample}[ปรับแต่งผังแป้นพิมพ์.]
\begin{MyEx}
$ \cin{setxkbmap -layout us,th_tis,fr} \mycomment{ตั้งผังแป้นพิมพ์ภาษาอังกฤษ, ไทยและฝรั่งเศส}
\end{MyEx}
\end{MyExample}%$
\end{itemize}

\subsubsection{สลับเปลี่ยนผังแป้นพิมพ์}
ในเวลาขณะใดขณะหนึ่ง, ผู้ใช้สามารถเลือกใช้ผังแป้นพิมพ์ได้อย่างเดียวเท่านั้น. การเปลี่ยนผังแป้นพิมพ์มักจะใช้การกดคีย์พิเศษที่กำหนดไว้สลับเปลี่ยนผังแป้นพิมพ์ไปมาเช่นถ้าการกดคีย์ \cmd{Alt+Shift} สำหรับสลับเปลี่ยนผังแป้นพิมพ์. ผู้ใช้สามารถกำหนดคีย์สำหรับเปลี่ยนผังแป้นพิมพ์ได้โดยใช้ตัวเลือก \cmd{-option} กับคำสั่ง \cmd{setxkbmap}.

\begin{MyExample}[ระบุวิธีการเปลี่ยนผังแป้นพิมพ์.]
\begin{MyEx}
$ \cin{setxkbmap -option grp:alt_shift_toggle}
\end{MyEx}
\end{MyExample}%$

ในตัวอย่างเป็นการกำหนดค่า \cmd{grp:alt\_shift\_toggle} หมายถึงการกดคีย์ \cmd{Alt} ค้างไว้แล้วกดคีย์ \cmd{+Shift} สำหรับเปลี่ยนผังแป้นพิมพ์. ระบบ XKB ยังมีวิธีการเปลี่ยนผังแป้นพิมพ์อื่นๆอีกเช่น \cmd{grp:menu\_toggle} กดคีย์เมนู, \cmd{grp:lwin\_toggle} กดคีย์วินโดวส์เป็นต้น. ค่าอื่นๆเหล่าที่สามารถกำหนดได้และคำอธิบายมีเขียนไว้อยู่ในไฟล์ \cmd{xorg.lst}.

\subsubsection{การปรับแต่งแป้นพิมพ์เฉพาะบุคคลในสภาพแวดล้อมเดสก์ท็อป GNOME}
ในสภาพแวดล้อมเดสก์ท็อปเช่น GNOME ผู้ใช้สามารถปรับแต่งแป้นพิมพ์ให้มีคุณสมบัติต่างๆรวมถึงการปรับแต่งแป้นพิมพ์ให้ใช้ภาษาไทยได้จากเมนูปรับแต่งระบบที่เตรียมไว้ด้วยโปรแกรม \cmd{gnome-keyboard-properties}\cindex{gnome-keyboard-properties}. ในสภาพแวดล้อม GNOME จะใช้ XKB ปรับแต่งแป้นพิมพ์ต่างหากแยกจากการปรับแต่งแป้นพิมพ์ด้วยไฟล์ \cmd{xorg.conf}. ถ้ามีการปรับแต่งแป้นพิมพ์ด้วย XKB จากไฟล์ \cmd{xorg.conf} และปรับแต่งแป้นพิมพ์อีกทีด้วย GNOME, ในระบบจะใช้การปรับแต่งแป้นพิมพ์จาก GNOME เป็นหลัก.

\begin{figure}[!htb]
\ifthenelse{\isodd{\pageref{fig:gnomekeyboard}}}%
{\parbox{\headwidth}{\center\scalebox{.45}{\includegraphics{gnome-keyboard-properties-1.eps}~~~~\includegraphics{gnome-keyboard-properties-2.eps}}\caption{โปรแกรม \cmd{gnome-keyboard-properties} สำหรับปรับแต่งแป้นพิมพ์.}\label{fig:gnomekeyboard}}}%
{\leftskip=\moveback\parbox{\headwidth}{\center\scalebox{.45}{\includegraphics{gnome-keyboard-properties-1.eps}~~~~\includegraphics{gnome-keyboard-properties-2.eps}}\caption{โปรแกรม \cmd{gnome-keyboard-properties} สำหรับปรับแต่งแป้นพิมพ์.}\label{fig:gnomekeyboard}}}
\end{figure}


\section{เทอร์มินอลเอมิวเลเตอร์}
เทอร์มินอลเอมิวเลเตอร์เป็นโปรแกรมที่จำลองเทอร์มินอลสำหรับสั่งคำสั่งด้วยเชลล์. ในระบบ X วินโดว์มีโปรแกรมเทอร์มินอลเอมิวเลเตอร์มาตรฐานได้แก่ \cmd{xterm}. โปรแกรม \cmd{xterm} เป็นโปรแกรมที่เรียบง่ายไม่มีเมนูบาร์เหมือนโปรแกรมสมัยใหม่ทั่วไป. ถ้าผู้ใช้กดคีย์ \cmd{Ctrl} ค้างไว้แล้วกดปุ่มซ้าย, กลาง, หรือขวาของเมาส์, ตัวโปรแกรมจะแสดงเมนูปรับแต่งค่าต่างๆที่แสดงในรูปที่ \ref{fig:xterm-menu}. ค่าที่ปรับแต่งจากเมนูบางตัวสามารถกำหนดจากตัวเลือกของโปรแกรมได้ด้วย.

\begin{figure}[!htb]
\plfigure{.55}{xterm-menu.eps}{เมนูของ \cmd{xterm} เมื่อกดคีย์ \cmd{Ctrl} และเมาส์ปุ่มต่างๆ.}{xterm-menu}
\end{figure}

สิ่งที่ผู้ใช้ควรรู้เกี่ยวกับการใช้เทอร์มินอลได้แก่การเลื่อนดูหน้าจอที่แสดงผ่านไปแล้ว. ผู้ใช้สามารถใช้เมาส์เลื่อนเนื้อหาขึ้นลงได้, หรือถ้าสะดวกใช้แป้นพิมพ์สามารถใช้คีย์ \cmd{Shift+PgUp} เพื่อเลื่อนหน้าจอขึ้น, ใช้คีย์ \cmd{Shift+PgDn} เลื่อนหน้าจอลงแทนการใช้เมาส์ได้. การเลื่อนหน้าจอด้วยแป้นพิมพ์นี้สามารถใช้ได้กับเทอร์มินอลอื่นๆที่ไม่ใช่ \cmd{xterm} ได้ด้วย.

เมื่อเปรียบเทียบ \cmd{xterm} กับเทอร์มินอลสมัยใหม่อื่นๆเช่น \cmd{gnome-terminal}, \cmd{konsole} ฯลฯ ในแง่ของการใช้งานบรรทัดคำสั่งไม่มีความแตกต่าง. ในแง่ของความใช้ง่ายและการตกแต่ง, เทอร์มินอลสมัยอำนวยความสะดวกเกี่ยวกับการปรับแต่งตัวเทอร์มินอลเช่น ฟอนต์, ฉากหลัง ฯลฯ ปรับแต่งง่ายกว่า \cmd{xterm}. ข้อแตกต่างอีกประการคือเทอร์มินอลสมัยใหม่สามารถแสดงหน้าจอเชลล์ได้หลายตัวภายในหน้าต่างเดียวโดยใช้แท็บ (tab)\gindex{แท็บ}\gindex{tab} ไม่ต้องเปิดเทอร์มินอลหลายบาน. ตัวอย่างเช่นใน \cmd{gnome-terminal} สามารถสร้างแท็บใหม่ด้วยการกด \cmd{Ctrl+Shift+t} หรือเลือกสร้างแท็บจากเมนู. ผู้ใช้สร้างมารถเลือกแท็บที่ต้องการโดยใช้เมาส์คลิ้กหรือกดคีย์ \cmd{Ctrl} กับคีย์ \cmd{PnUp}, \cmd{PnDn} เปลี่ยนหน้าจอแท็บไปมาได้.

\begin{figure}[!htb]
\plfigure{.4}{terminal-tab.eps}{แท็บในเทอร์มิวนอลเอมิวเลเตอร์สมัยใหม่.}{terminal-tab}
\end{figure}


\subsection{บันทึกหน้าจอเทอร์มินอล}
เทอร์มินอลเป็นอินเทอร์เฟสพื้นฐานที่ใช้อักขระโต้ตอบกับผู้ใช้, ดังนั้นการถ่ายทอดสิ่งที่ทำในบรรทัดคำสั่งจึงง่ายกว่าโปรแกรมระบบ GUI คือผู้ใช้สามารถก็อปปี้สิ่งที่แสดงทางหน้าจอลงในไฟล์แล้วส่งต่อให้ผู้อื่นรู้ได้.

การบันทึกสิ่งที่พิมพ์และสิ่งที่แสดงผลทางเทอร์มินอลแบบพื้นฐานสามารถทำได้โดยใช้เมาส์ก็อปปี้ส่วนแสดงผลที่ต้องการแล้วแปะบันทึกลงไฟล์. วิธีนี้เหมาะกับการบันทึกสิ่งที่กระทำในเทอร์มินอลช่วงเวลาสั้นๆ. ถ้าต้องการบันทึกการทำงานทั้งหมดในเทอร์มินอลเป็นระยะเวลานาน, ให้ใช้คำสั่ง \cmd{script}. คำสั่ง \cmd{script}\refcmd{script}\cindex{script} จะเริ่มเชลล์ตัวใหม่และเก็บบันทึกที่แสดงในเทอร์มินอลทั้งหมดลงในไฟล์ที่กำหนด. วิธีนี้เหมาะสำหรับเก็บบันทึกการกระทำทุกอย่างในเทอร์มินอลแล้วเปิดดูภายหลัง.
\begin{MyExample}[บันทึกหน้าจอเทอร์มินอลด้วยคำสั่ง \cmd{script}.]
\begin{MyEx}
$ \cin{script typescript.txt} \mycomment{บันทึกสิ่งที่แสดงบนเทอร์มินอลในไฟล์ \cmd{typescript.txt}}
Script started, file is typescript.txt
$ \cin{fortune}
"In matters of principle, stand like a rock; in matters of taste, swim with
the current."
-- Thomas Jefferson
$ \cin{exit} \mycomment{จบการบันทึก}
Script done, file is typescript.txt
$ \cin{cat typescript.txt} \mycomment{แสดงสิ่งที่บันทึก}
Script started on Thu Mar 24 01:03:10 2005
$ fortune
"In matters of principle, stand like a rock; in matters of taste, swim with
the current."
-- Thomas Jefferson
$ exit

Script done on Thu Mar 24 01:03:39 2005
\end{MyEx}
\end{MyExample}

%\section{แอพพลิเคชันมาตรฐานของ X วินโดว์}

\section{สภาพแวดล้อมเดสก์ท็อป GNOME}
\emph{GNOME (GNU Network Object Model Environment)} เป็นสภาพแวดล้อมเดสก์ท็อปหนึ่งที่นิยมใช้ในระบบปฏิบัติการลินุกซ์มีจุดมุ่งหมายหลักได้แก่การเสนอสภาพแวดล้อมเดสก์ท็อปที่ง่ายต่อการใช้งานสำหรับผู้ใช้ทั่วไป, และเสนอแพลตฟอร์มการพัฒนาแอพพลิเคชันให้สามารถเข้ากันได้ในเดสก์ท็อป. ก่อนหน้าที่มีแนวคิดเรื่องสภาพแวดล้อมเดสก์ท็อป, โปรแกรม GUI ต่างๆที่มีใช้ไม่มีรูปแบบที่แน่นอนเช่นบางโปรแกรมมีเมนูบาร์, บางโปรแกรมไม่มี. บางโปรแกรมทีหน้าต่างเอกสารวิธีใช้งาน, บางโปรแกรมไม่มี. สภาพแวดล้อมเดสก์ท็อปเป็นเหมือนมาตรฐานให้โปรแกรมแบบ GUI ต่างๆที่ใช้งานบนเดสก์ท็อปมีความเข้ากันได้, มีรูปแบบที่เหมือนกัน. โปรแกรมแต่ละตัวจะดูคล้ายเหมือนกันเพราะสร้างด้วยไลบรารีร่วมที่เหมือนกันและยึดรูปแบบเดียวกัน. แอพพลิเคชันหรือโปรแกรมทุกตัวที่ถือว่าเป็นส่วนหนึ่งในสภาพแวดล้อมเดสก์ท็อป GNOME จะใช้ไลบรารี Gtk+ เหมือนกัน, มีเมนูมาตรฐานได้แก่เมนู File, Edit, Help ฯลฯ, มีตัวเลือกของบรรทัดคล้ายเหมือนกัน เป็นต้น. ในที่นี้จะแนะสภาพแวดล้อมเดสก์ท็อปโดยอ้างอิงจาก GNOME รุ่น 2.6 หรือ 2.8.

สภาพแวดล้อมเดสก์ท็อป GNOME เป็นโครงการที่เริ่มสร้างในราวเดือนสิงหาคมปีค.ศ. 1997 โดยมี Miguel de Icaza\gindex{miguel deIcaza@Miguel de Icaza} และ Federico Mena\gindex{federico mena@Federico Mena} ชาวเมกซิกันขณะที่ยังเป็นนักศึกษา. ในช่วงเวลานั้นมีโครงการเด่นๆได้แก่ KDE ซึ่งเป็นสภาพแวดล้อมเดสก์ท็อปใหม่อีกโครงการเช่นกันแต่มีปัญหาเกี่ยวกับสิทธิ์อนุญาตการใช้. KDE ใช้ไลบรารี Qt ซึ่งในตอนนั้นยังมีสิทธิ์อนุญาตการใช้งานที่ไม่ใช่ GPL ทำให้มีปัญหาว่าจะขัดกับการแก้ไขรหัสต้นฉบับของ KDE หรือไม่. ต่อมาไม่นาน Miguel และ Federoco ก็ได้เริ่มโครงการ GNOME อย่างจริงจังโดยใช้ไลบรารี Gtk+ ที่พัฒนาสำหรับใช้กับโปรแกรม \cmd{gimp} เป็นไลบรารีหลักในการสร้างสภาพแวดล้อมเดสก์ท็อป GNOME และได้รับความนิยมในเวลาต่อมาจนถึงปัจจุบัน.


ในสภาพแวดล้อมเดสก์ท็อปจะประกอบด้วยแอพพลิเคชันหรือโปรแกรมต่างๆเข้าด้วยกันเป็นระบบ. ส่วนประกอบที่สำคัญๆของสภาพแวดล้อมได้แก่


\subsection{พาเนล (penel)}
พาเนล\gindex{พาเนล}\gindex{panel} (โปรแกรม \cmd{gnome-panel})\cindex{gnome-panel} คือแถบที่อยู่บริเวณขอบหน้าจอเป็นพื้นที่สำหรับใส่วัตถุต่างๆเช่นเมนูในสภาพแวดล้อมเดสก์ท็อป. พาเนลสามารถอยู่บริเวณขอบหน้าจอด้านไหนก็ไหนและมีจำนวนได้มากกว่าหนึ่งตัว. ผู้ใช้สามารถลากไปไว้บริเวณขอบที่ต้องการ. การปรับแต่งพาเนลทำได้โดยคลิ้กเมาส์ปุ่มขวาแล้วเลือกเพิ่มแอพเพล็ต, เพิ่มเมนูจากเมนูที่เตรียมไว้ให้.
\subsection{เมนู (menu)}\gindex{menu}\gindex{เมนู}
เมนูเป็นปุ่มแสดงรายการแอพพลิเคชัน (applications menu) หรือการกระทำต่างๆ (actions menu) ในพาเนลให้ผู้ใช้เลือกใช้.

\begin{figure}[!htb]
\plfigure{.38}{gnome-panel.eps}{พาเนลในสภาพแวลล้อมเดสก์ท็อป GNOME.}{gnome-panel}
\end{figure}

\subsection{หน้าต่าง (window)}
หน้าต่างของแอพพลิเคชันหรือโปรแกรมต่างจะควบคุมโดยวินโดว์แมนเนเจอร์เช่นการย่อขยายหน้าต่าง, การเลื่อนหน้าต่าง ฯลฯ. ผู้ใช้สามารถใช้วินโดว์แมนเนเจอร์อะไรก็ได้ที่มีคุณสมบัติของวินโดว์แมนเนเจอร์พื้นฐานและเข้ากันได้กับ GNOME เช่น \cmd{metacity}\cindex{metacity}\mymemo{ปัจจุบันวินโดว์แมนเนเจอร์ปริยายของ GNOME คือ \cmd{metacity}.}, \cmd{sawfish}\cindex{sawfish} ฯลฯ. เวลา GNOME เรียกใช้วินโดว์แมนเนเจอร์จะใช้โปรแกรม \cmd{gnome-wm}\cindex{gnome-wm} เป็นตัวกลางโดยไม่เรียกใช้โปรแกรมวินโดว์แมนเนเจอร์โดยตรง.
\subsection{พื้นที่ทำงาน (workspace)}\gindex{พื้นที่ทำงาน}\gindex{workspace}
ในสภาพแวดล้อม GNOME สามารถมีพื้นที่ทำงานเป็นหน้าจอได้หลายบาน. โดยส่วนใหญ่ระบบจะตั้งจำนวนพื้นที่ทำงานไว้ให้โดยปริยาย 4 หน้าจอ. ผู้ใช้สามารถสลับเปลี่ยนพื้นที่ทำงานจากหน้าจอหนึ่งไปอีกหน้าจอหนึ่งด้วยการคลิ้กตัวสลับพื้นที่ทำงานหรือใช้แป้นพิมพ์ลัด (shortcut) กด \cmd{Ctrl+Alt} พร้อมกับคีย์ลูกศรซ้าย, ขวา, บน, หรือล่าง.
\subsection{โปรแกรมจัดการแฟ้มข้อมูล (file manager)}\gindex{file manager}
โปรแกรม \cmd{nautilus}\cindex{nautilus} เป็นโปรแกรมจัดการไฟล์ต่างๆในสภาพแวดล้อมเดสก์ท็อป GNOME, มีหน้าที่แสดงและจัดการไฟล์หรือไดเรกทอรีต่างๆด้วย GUI. นอกจากนี้ยังทำหน้าที่เป็นพื้นเดสก์ท็อปที่เห็นบนหน้าจอ, และเป็นโปรแกรมศูนย์กลางสำหรับใช้เดสก์ท็อปโดยรวม.

\medskip
การใช้งาน \cmd{nautilus} อาจแบ่งออกได้เป็น 3 ประเภทได้แก่

\subsubsection{ไฟล์เบราเซอร์ (file browser)}
การใช้ \cmd{nautilus} แบบไฟล์เบราเซอร์ให้เรียกใช้โปรแกรมจากเมนู Applications \arrowright{} Browse Filesystem หรือสั่งคำสั่ง ``\cmd{nautilus --browser}'' จากบรรทัดคำสั่ง. หน้าต่าง \cmd{nautilus} แบบนี้ทางเทคนิคเรียกว่า \emph{Navigation Metaphor}\gindex{navigation metaphor} คือการมองไฟล์เบราเซอร์เป็นโปรแกรม, เมื่อเปิดไดเรกทอรีไม่มีการเปิดหน้าจอใหม่. คล้ายกับการใช้งานจากเชลล์ที่ผู้ใช้ต้องรู้ว่าขณะนี้กำลังอยู่ในไดเรกทอรีอะไร. การใช้งานแบบนี้เหมาะสำหรับผู้ที่คุ้นเคยกับการใช้ระบบปฏิบัติการวินโดวส์มาก่อน.

\begin{figure}[!htb]
\plfigure{.4}{nautilus-browser.eps}{ใช้ \cmd{nautilus} เป็นไฟล์เบราเซอร์.}{nautilus-browser}
\end{figure}

ในหน้าต่างของ \cmd{nautilus} แบบเบราเซอร์จะมีพื้นที่กรอกชื่อสถานที่ ``Location:'' ซึ่งผู้ใช้สามารถใส่ชื่อไดเรกทอรีที่ต้องการจัดการไฟล์หรือที่อยู่พิเศษในตารางที่ \ref{tab:nautilus}.

\begin{table}[!htb]
\caption{ชื่อสถานที่พิเศษสำหรับ \cmd{nautilus}.}\label{tab:nautilus}
\medskip
\begin{tabular}{lp{.55\textwidth}l}
\toprule
\multicolumn{1}{c}{สถานที่} & \multicolumn{1}{c}{คำอธิบาย}\\
\midrule
\cmd{applications:///} & แสดงรายการแอพพลิเคชันในเมนู Applications.\\
\cmd{burn:///} & แสดงสถานที่เตรียมไฟล์และไดเรกทอรีสำหรับเขียนแผ่นซีดี.\\
\cmd{fonts:///} & แสดงฟอนต์ที่มีอยู่ในระบบ. ผู้ใช้สามารถติดตั้งฟอนต์ได้โดยการลากฟอนต์เข้าไปในหน้าต่างนี้.\\
\cmd{network:///} & แสดงเน็ตเวิร์กเช่นไซต์สำหรับ ftp ที่ติดตั้งไว้.\\
\cmd{preferences:///} & แสดงแอพพลิเคชันสำหรับช่วยปรับแต่งสภาพแวดล้อมเดสก์ท็อปต่างๆ. ผู้ใช้สามารถใช้โปรแกรมช่วยปรับแต่งสภาพแวดล้อมเดสก์ท็อปเหล่านี้ได้จากเมนูเช่นกัน.\\
\cmd{server-settings:///} & แสดงแอพพลิเคชันสำหรับปรับแต่งเซิร์ฟเวอร์.\\
\cmd{start-here:///} & อำนวยความสะดวกเป็นจุดเริ่มต้นสำหรับการกระทำต่างๆ. ในหน้าต่างจะแสดงสถานที่ของแอพพลิเคชัน, ที่ปรับแต่งระบบ ฯลฯ.\\
\cmd{system-settings:///} & แสดงแอพพลิเคชันาำหรับปรับแต่งระบบ.\\
\cmd{themes:///} & แสดงธีม (theme)\gindex{ธีม}\gindex{theme} ของ GNOME และเป็นที่ผู้ใช้สามารถติดตั้งธีมใหม่ได้ด้วย.\\
\bottomrule
\end{tabular}
\end{table}


\subsubsection{ไฟล์เบราเซอร์เชิงวัตถุ (object)}
บนพื้นหน้าจอเดสก์ท็อปจะมีไอคอน (icon) อำนวยความสะดวกเช่น ``Computer'', ``Home'', ``Start Here'' และ ``Trash''. ถ้าดับเบิ้ลคลิ้กไอคอนเหล่านี้จะเป็นการเรียกใช้ \cmd{nautilus} เป็นไฟล์เบราเซอร์เชิงวัตถุ.

\begin{figure}[!htb]
\plfigure{.4}{nautilus-object.eps}{ใช้ \cmd{nautilus} เป็นไฟล์เบราเซอร์เชิงวัตถุและพื้นเดสก์ท็อป.}{nautilus-object}
\end{figure}

เวลาดับเบิ้ลคลิ้กไดเรกทอรีที่แสดงในหน้าต่างจะเปิดหน้าต่างใหม่ทุกครั้ง. การเปิดหน้าต่างใหม่ทุกครั้งหลังจากที่ดับเบิ้ลคลิ้กตัววัตถุนี้เริ่มใช้ใน GNOME 2.6 เรียกว่า \emph{spatial view}\gindex{spatial view} หรือในทางเทคนิคเรียกว่า \emph{Object Oriented Metaphor}\gindex{object oriented metaphor}. หน้าต่างของ \cmd{nautilus} จะไม่แสดงไอออนบาร์ (icons bar) หรือ Location โดยจะถือว่าไดเรกทอรีที่ดับเบิ้ลคลิ้กนั้นเป็นวัตถุ, เป็นแฟ้มที่ใส่ไฟล์อื่นๆ. ถ้าดับเบิ้ลคลิ้กไฟล์, \cmd{nautilus} จะดูว่าไฟล์นั้นเป็นไฟล์อะไรแล้วเรียกโปรแกรมที่เหมาะสมเปิดไฟล์นั้น. ในทำนองเดียวกันถ้าสิ่งที่ดับเบิ้ลคลิ้กคือไดเรกทอรี, ก็จะเปิดหน้าต่างแอพพลิเคชันที่ใช้ดูไฟล์ที่อยู่ข้างในเสมอเหมือนกับการเปิดไฟล์.

การกระทำของ \cmd{nautilus} แบบนี้ดูเหมือนกับย้อนยุคและไม่สะดวกสำหรับผู้ที่ใช้คอมพิวเตอร์คล่องแล้ว. แต่ในมุมมองของผู้ที่ไม่เคยใช้คอมพิวเตอร์มาก่อนจะเข้าใจกับการทำงานในลักษณะนี้ได้ง่ายกว่าการทำงานแบบไฟล์เบราเซอร์. หลังจากที่เบิ้ลคลิ้กแล้ว, หน้าต่างเดิมจะไม่มีการเปลี่ยนแปลง, ไม่สูญหาย, ทำให้ผู้ที่ไม่เคยใช้คอมพิวเตอร์มาก่อนไม่หลงว่าอะไรอยู่ที่ไหน.  ถ้าไม่ต้องการเปิดหน้าต่างใหม่ทุกครั้ง, ผู้ใช้สามารถดับเบิ้ลคลิ้กด้วยปุ่มกลางแทนปุ่มซ้ายของเมาส์. หรือดับเบิ้ลคลิ้กตามปรกติขณะที่กดคีย์ \cmd{Shift} ค้างไว้. ถ้าต้องการเปลี่ยนเป็นแบบไฟล์เบราเซอร์ก็สามารถคลิ้กปุ่มเมาส์ขวาแล้วเลือก Browse Folder.


\subsubsection{เดสก์ท็อป}
พื้นหลังเดสก์ท็อปของ GNOME จริงๆแล้วเป็นหน้าต่างหนึ่งของ \cmd{nautilus} ซึ่งรันโดยอัตโนมัติหลังจากที่ผู้ใช้เข้าสู่เซสชันของ GNOME.



\subsection{เซสชัน}
เวลาผู้ใช้ล็อกอินผ่านทางดิสเพลยแมนเนเจอร์เข้าสู่ระบบ X วินโดว์จนจบการทำงานจะเรียกช่วงสภาพแวดล้อมนั้นว่า\emph{เซสชัน (session)}.\gindex{session}\gindex{เซสชัน}\mymemo{คำแปลภาษาไทยของ session คือวาระแต่ในที่นี้จะใช้คำว่าเซสชันเพื่อความสะดวก.}  การจัดการเซสชันเป็นการเปิดโอกาสให้ผู้ใช้สามารถเก็บบันทึกการทำงานในเดสก์ท็อปเพื่อใช้ในคราวหน้าตอนล็อกอินได้และเป็นวิธีที่ผู้ใช้เรียกใช้โปรแกรมต่างๆโดยอัตโนมัติหลังจากที่ล็อกอิน.

โปรแกรมที่เป็นตัวเริ่มต้นเซสชันในสภาพแวดล้อมเดสก์ท็อป GNOME ได้แก่ \cmd{gnome-session}\cindex{gnome-session} ซึ่งปรกติจะถูกกระทำการโดยดิสเพลยแมนเนเจอร์เช่น \cmd{gdm} หรือหลังจากสั่งคำสั่ง \cmd{startx}. \cmd{gnome-session} จะเริ่มทำงานโดยสร้างโปรเซสที่สำคัญๆสำหรับสภาพแวดล้อมเดสก์ท็อปเช่น \cmd{gnome-wm}, \cmd{gnome-panel}, \cmd{nautilus} ฯลฯ. เวลาเริ่มเซสชันจะมีไฟล์ \cmd{/usr/share/gnome/default.session}\findex{default.session} เป็นไฟล์ตั้งค่าเริ่มต้นของเซสชันปริยาย. ในไฟล์นี้จะระบุโปรแกรมต่างๆที่จำเป็นสำหรับสภาพแวดล้อมเดสก์ท็อป.

\begin{shaded}
\begin{MyExample}[ไฟล์ \cmd{/usr/share/gnome/default.session}.]
\begin{MyEx}
# This is the default session that is launched if the user doesn't
# already have a session.
# The RestartCommand specifies the command to run from the $PATH.
# The Priority determines the order in which the commands are started
# (with Priority = 0 first) and defaults to 50.
# The id provides a name that is unique within this file and passed to the
# app as the client id which it must use to register with gnome-session.
# The clients must be numbered from 0 to the value of num_clients - 1.

[Default] \mycomment{ชื่อเซสชัน}
num_clients=8 \mycomment{จำนวนไคลเอ็นต์ในเซสชัน}
0,id=default0 \mycomment{id ของไคลเอ็นต์}
0,Priority=0 \mycomment{ค่าลำดับความสำคัญ}
0,RestartCommand=gnome-smproxy --sm-client-id default0 \mycomment{โปรแกรมที่ต้องการรัน}
1,id=default1
1,Priority=10
1,RestartCommand=gnome-wm --sm-client-id default1
2,id=default2
2,Priority=40
2,RestartCommand=gnome-panel --sm-client-id default2
3,id=default3
3,Priority=40
3,RestartCommand=nautilus --no-default-window --sm-client-id default3
4,id=default4
4,Priority=60
4,RestartCommand=gnome-cups-icon --sm-client-id default4
5,id=default5
5,Priority=40
5,RestartCommand=gnome-volume-manager --sm-client-id default5
6,id=default6
6,Priority=40
6,RestartCommand=magicdev --sm-client-id default6
7,id=default7
7,Priority=50
7,RestartCommand=vino-session --sm-client-id default7
\end{MyEx}
\end{MyExample}
\end{shaded}%$

จากตัวอย่างเป็นไฟล์ตั้งค่าเริ่มต้นเซสชันปริยายของ GNOME 2.8. ชื่อที่อยู่ในวงเล็บเหลี่ยมคือชื่อเซสชันซึ่งในที่นี้คือ Default. โปรแกรมที่ทำงานในเซสชันจะมีชื่อ id และลำดับความสำคัญ. โปรแกรมต่างๆที่ระบุในไฟล์จะถูกกระทำตามลำดับความสำคัญที่ระบุไว้. โปรแกรมที่มีค่า priority น้อยกว่าจะทำงานก่อนตามลำดับ. RestartCommand เป็นการระบุให้เริ่มทำงานใหม่ถ้าตายไป. สมมติว่าเราสั่งคำสั่ง ``\cmd{killall nautilus}'' เพื่อฆ่าโปรเซสของ \cmd{nautilus} ทุกตัว, ตัวจัดการเซสชันจะรันโปรแกรม \cmd{nautilus} ใหม่แทนตัวที่ตายไปโดยอัตโนมัติ.

ไฟล์ \cmd{default.session} เป็นไฟล์ที่ระบบเตรียมไว้ให้อยู่แล้ว, ผู้ใช้ไม่ต้องสร้างเอง. และผู้ใช้สามารถปรับแต่ง, ควบคุมโปรแกรมในเซสชันเฉพาะของตัวเองด้วยโปรแกรม \cmd{gnome-session-properties}\cindex{gnome-session-properties}. โปรแกรมนี้สามารถเลือกจากเมนู Applications \arrowright{} Desktop Preferences \arrowright{} Advanced \arrowright{} Sessions.

\begin{figure}[!htb]
\plfiguretwo{.4}{gnome-session-properties.eps}{gnome-session-properties-2.eps}{โปรแกรม \cmd{gnome-session-properties} สำหรับปรับแต่งเซสชัน.}{gnome-session-properties}
\end{figure}

ผู้ใช้เอาโปรเซสที่กำหนดในเซสชันปริยายเช่น \cmd{nautilus} ออกได้ถ้าไม่ต้องการโดยใช้แท็บ Current Session ในรูปที่ \ref{fig:gnome-session-properties}. ตอนล็อกเอาท์ออกจากระบบจะมีคำถามถามว่าต้องการบันทึกเซสชันไว้ใช้คราวหน้าหรือไม่ให้ตอบว่าใช่. หรือถ้าต้องการบันทึกเซสชันในขณะใดขณะหนึ่งก็สามารถสั่งคำสั่ง \cmd{gnome-session-save}\cindex{gnome-session-save} ได้ทันที. เซสชันที่บันทึกจะเป็นข้อมูลที่เก็บไว้ในไฟล์ \cmd{\~{}/.gnome2/session}\findex{session} ซึ่งมีเนื้อหาคล้ายกับไฟล์ \cmd{default.session}. ถ้าผู้ใช้มีไฟล์ \cmd{\~{}/.gnome2/session} อยู่, เวลาล็อกอินเข้าสู่สภาพแวดล้อมเดสก์ท็อป GNOME จะใช้ไฟล์นี้เริ่มเซสชันแทนไฟล์ \cmd{defatul.session}.

นอกจากการปรับแต่งเซสชันแล้ว, ผู้ใช้สามารถกำหนดโปรแกรมที่ต้องการรันหลังจากเข้าเซสชัน GNOME ทางแท็บ Startup Program ของ \cmd{gnome-session-properties} ด้วย.

\subsection{การปรับแต่งสภาพแวดล้อมเดสก์ท็อป GNOME}
การปรับแต่งสภาพแวดล้อมเดสก์ท็อป GNOME โดยทั่วไปจะทำโดยการเลือกโปรแกรมปรับแต่งจากเมนู Applications \arrowright{} Desktop Preferences. สิ่งที่ผู้ใช้สามารถปรับแต่งได้เช่น ฟอนต์ที่ใช้ในเดสก์ท็อป, เซสชัน, เมาส์ ฯลฯ. โปรแกรมช่วยปรับแต่งเหล่านี้มักมีชื่อเริ่มต้นด้วย \cmd{gnome-} และลงท้ายด้วย \cmd{-properties} เช่นโปรแกรมสำหรับปรับแต่งความละเอียดหน้าจอสามารถเรียกใช้จากบรรทัดคำสั่งด้วยชื่อ \cmd{gnome-display-properties}\cindex{gnome-display-properties} เป็นต้น.

โปรแกรมช่วยปรับแต่งเดสก์ท็อปเหล่านี้จริงๆแล้วเป็นอินเทอร์เฟสระหว่างผู้ใช้กับเดมอน \cmd{gconfd-2}\cindex{gconfd-2}\mymemo{ไฟล์โปรแกรม \cmd{gconfd-2} จะอยู่ในไดเรกทอรี \cmd{/usr/lib/gconf2}.} ซึ่งทำหน้าที่จัดการปรับแต่งระบบ, บันทึกการปรับแต่งต่างๆเก็บลงไฟล์ในฟอร์แมต \mbox{XML}. ไฟล์ที่เก็บค่าการปรับแต่งเหล่านี้จะอยู่ในไดเรกทอรี \cmd{\~{}/.gconf}\dindex{.gconf} ซึ่งในไดเรกทอรีนี้จะมีไดเรกทอรีแยกย่อยต่อออกไปสำหรับเก็บค่าปรับแต่งเฉพาะบุคคลของเดสก์ท็อปและแอพพลิเคชันต่างๆ. วิธีการปรับแต่งเดสก์ท็อปและแอพพลิเคชันในสภาพแวดล้อมเดสก์ท็อป GNOME มีชื่อเรียกว่า \emph{GConf}\gindex{gconf@GConf}.

โดยปรกติผู้ใช้สามารถปรับแต่งเดสก์ท็อปจากเมนู Desktop Preferences ด้วยโปรแกรมช่วยปรับแต่งเดสก์ท็อป. ถ้าเป็นการปรับแต่งแอพพลิเคชัน, ผู้ใช้สามารถปรับแต่งแอพพลิเคชันได้จากเมนูในหน้าต่างของแอพพลิเคชันนั้นๆ. ในกรณีที่สิ่งที่ต้องการปรับแต่งไม่สามารถทำได้จากโปรแกรมช่วยปรับแต่งหรือจากเมนูที่เตรียมไว้, ผู้ใช้สามารถใช้โปรแกรม \cmd{gconf-editor}\cindex{gconf-editor} (จากเมนูเลือก System Tools \arrowright{} Configuration Editor) ใช้ปรับแต่งค่าคุณสมบัติต่างได้โดยตรงโดยที่ไม่ต้องแก้ไขไฟล์ที่อยู่ใต้ไดเรกทอรี \cmd{.gconf} ด้วยตัวเอง.

\begin{figure}[!htb]
\plfigure{.45}{gconf-editor.eps}{โปรแกรม \cmd{gconf-editor} ปรับแต่งเดสก์ท็อปและแอพพลิเคชัน.}{gconf-editor}
\end{figure}

การปรับแต่งเดสก์ท็อปและแอพพลิเคชันด้วย GConf จะเก็บค่าคุณสมบัติต่างๆไว้ในฐานข้อมูลเป็นไฟล์ XML. ในเชิงตรรกะจะแจกแจงเก็บค่าคุณสมบัติที่ต้องการปรับแต่งเป็นโค้งสร้างคล้ายเหมือนกับไดเรกทอรีและไฟล์ที่ใช้ในระบบไฟล์ทั่วไป. ค่าที่เก็บในฐานข้อมูลจะมีชื่อที่เรียกว่าคีย์ (key) และค่า (value) ของคุณสมบัติที่ต้องการปรับแต่งควบคู่กันไป. ตัวอย่างเช่น \cmd{/apps/\wbr{}gnome-terminal/\wbr{}profiles/\wbr{}Default/\wbr{}font} เป็นชื่อคีย์สำหรับปรับแต่งฟอนต์ที่ใช้แสดงผลของโปรแกรม \cmd{gnome-terminal}. เวลาอ้างอิงชื่อคีย์จะระบุเป็นชื่อเต็มๆรวมถึงไดเรกทอรีตำแหน่งที่เก็บคีย์ซึ่งได้แก่ \cmd{/apps/\wbr{}gnome-terminal/\wbr{}profiles/\wbr{}Default} ด้วย. ในไดเรกทอรีหนึ่งสามารถเก็บคีย์ได้หลายตัวเช่นในไดเรอทอรี \cmd{/apps/\wbr{}gnome-terminal/\wbr{}profiles/\wbr{}Default} ยังมีคีย์อื่นๆอีกเช่น \cmd{use\_theme\_colors}, \cmd{palette}, \cmd{exit\_action} ฯลฯ. เราสามารถสำรวจโครงสร้างของไดเรกทอรีและคีย์ต่างๆหรือตั้งค่าได้จากโปรแกรม \cmd{gconf-editor}. ตัวโปรแกรมยังช่วยแสดงคำอธิบายคีย์ต่างๆและบางครั้งจะแสดงค่าต่างที่สามารถกำหนดให้ด้วย.
%, \cmd{/desktop/\wbr{}gnome/\wbr{}font\_rendering/\wbr{}antialiasing} เป็นชื่อคีย์สำหรับกำหนดวิธีการเรนเดอร์ฟอนต์ในเดสก์ท็อป เป็นต้น. จะเห็นได้ว่าชื่อคีย์จะมีรูปแบบคล้ายกับระบบไฟล์. จากโปรแกรม \cmd{gconf-editor} จะแสดงคำอธิบายคีย์ต่างๆและบางครั้งจะแสดงค่าต่างที่สามารถกำหนดให้ด้วย.
ใน GNOME รุ่น 2.8, ผู้ดูแลระบบสามารถใช้ \cmd{gconf-editor} กำหนดค่าปริยาย (default) หรือค่าบังคับ (mandatory) ที่จะใช้ในสภาพแวดล้อมเดสก์ท็อปสำหรับผู้ใช้ทั่วไปได้ด้วย.

วิธีปรับแต่งเดสก์ท็อปอีกวิธีหนึ่งคือใช้โปรแกรมบรรทัดคำสั่ง \cmd{gconftool-2}\cindex{gconftool-2}. เมื่อเทียบกับโปรแกรม \cmd{gconf-editor} แล้วจะใช้ยากกว่าและเหมาะสำหรับใช้ในเชลล์สคริปต์. เช่นจากตัวอย่างที่ \ref{ex:gconftool}, ผู้ใช้สามารถสร้างเชลล์สคริปต์สำหรับเปลี่ยนรูปพื้นเดสก์ท็อปทุก 5 นาทีจากอัลบันรูปที่มีอยู่ได้ด้วยคำสั่ง \cmd{gconftool-2}.

\begin{MyExample}[การใช้ \cmd{gconftool-2}]\label{ex:gconftool}
\begin{MyEx}
$ \cin{gconftool-2 --list-dirs /} \mycomment{สำรวจไดเรกทอรีในฐานข้อมูล GConf}
 /desktop
 /apps
 /system
 /schemas
$ \cin{gconftool-2 --list-entries /desktop/gnome/background} \mycomment{สำรวจคีย์และค่า}
 color_shading_type = vertical-gradient
 secondary_color = #7F7F7F
 primary_color = #7F7F7F
 picture_filename = /usr/share/pixmaps/backgrounds/gnome/branded/GNOME-Aqua.jpg
 picture_options = stretched
 picture_opacity = 100
 draw_background = true
$ \cin{gconftool-2 --type string -s /desktop/gnome/background/picture_filename \bs }
> \cin{/home/poonlap/wallpaper.jpg} \mycomment{เปลี่ยนรูปของพื้นเดสก์ท็อป}
$ \cin{gconftool-2  -g /desktop/gnome/background/picture_filename} \mycomment{ดูค่าของคีย์}
/home/poonlap/wallpaper.jpg
\end{MyEx}
\end{MyExample}


\medskip
เป็นที่ยอมรัมกันว่าสภาพแวดล้อมเดสก์ท็อป GNOME ใช้ง่ายกว่าเชลล์. ผู้ใช้ที่ไม่คุ้นเคยกับอินเทอร์เฟสแบบบรรทัดคำสั่งสามารถใช้คอมพิวเตอร์ได้ง่ายขึ้นเพียงแต่มีทักษะเบื้องต้นในการใช้เมาส์และแป้นพิมพ์เท่านั้น. สำหรับผู้ที่ต้องเรียนรู้เกี่ยวกับสภาพแวดล้อมเดสก์ท็อป GNOME เพิ่มเติมสามารถอ่านเอกสารที่มาพร้อมกับ GNOME ได้จากโปรแกรม \cmd{yelp} (จากเมนู Applications \arrowright{} Help). สำหรับสภาพแวดล้อมเดสก์ท็อปอื่นๆเช่น KDE ที่ไม่ได้แนะนำให้หนังสือเล่มนี้ผู้ใช้สามารถอ่านการใช้เบื้องต้นจากโปรแกรม \cmd{khelpcenter} และสิ่งที่สำคัญที่สุดคือการลองใช้ด้วยตนเอง.



%\section{KDE}

%\section{แนะนำโปรแกรม}
\section{สรุปท้ายบท}
\begin{itemize}
\item ระบบ X วินโดว์เป็นระบบแบบไคลเอ็นต์เซิร์ฟเวอร์. เซิร์ฟเวอร์เป็นโปรแกรมแยกจากระบบปฏิบัติการมีหน้าที่แสดงผลกราฟิกทางหน้าจอเมื่อได้รับการร้องของจากไคลเอ็นต์.
\item โปรแกรม X เซิร์ฟเวอร์สามารถทำงานได้หลายตัวพร้อมกันโดยระบุใช้หน้าจอคนละตัว. และประเภทของเซิร์ฟเวอร์มีหลายชนิดเช่น \cmd{Xnest}, \cmd{Xvfb}, \cmd{Xvnc} เป็นต้น.
\item X เซิร์ฟเวอร์เปิดโอกาสให้ไคลเอ็นต์ติดต่อกับเซิฟร์เวอร์โดยการใช้ไลบรารี Xlib ซึ่งเป็น API สำหรับแสดงผลกราฟิกขั้นพื้นฐาน. ในความเป็นจริงไคลเอ็นต์จะใช้ไลบรารีอื่นๆที่ใช้ไลบรารี Xlib อีกทีในการสร้างโปรแกรมเช่น GTK+, Qt เป็นต้น.
\item การจัดการหน้าต่างของโปรแกรมเช่นการย่อขยาย, ย้ายตำแหน่งหน้าต่างเป็นหน้าที่ของโปรแกรมที่เรียกว่าวินโดว์แมนเนเจอร์.
\item ระบบการจัดการฟอนต์แบ่งเป็น 2 ประเภทใหญ่ๆคือระบบจัดการฟอนต์แบบดั้งเดิมที่เรียกว่า X core font และ fontconfig. เวลาติดตั้งฟอนต์ใหม่ในระบบควรคำนึงถึงปัจจัยต่างๆได้แก่ ระบบการจัดการฟอนต์ที่ใช้, ต้องการติดตั้งฟอนต์ในระบบโดยรวมหรือเฉพาะบุคคล เป็นต้น.
\item การปรับแต่งแป้นพิมพ์แบ่งเป็น 2 ประเภทใหญ่ๆคือใช้โปรแกรม \cmd{xmodmap} และ XKB. XKB เหมาะสำหรับการปรับแต่งแป้นพิมพ์ภาษาไทยและในสภาพแวดล้อมเดสก์ท็อปเช่น GNOME สามารถปรับแต่งแป้นพิมพ์เฉพาะบุคคลได้.
\item สภาพแวดล้อมเดสก์ท็อปช่วยอำนวยความสะดวกให้ผู้ที่เริ่มใช้คอมพิวเตอร์ใช้คอมพิวเตอร์ได้ง่ายขึ้น. โปรแกรมต่างๆที่เป็นส่วนหนึ่งในสภาพแวดล้อมเดสก์ท็อปจะมีรูปร่างหน้าตา, วิธีการใช้งานคล้ายเหมือนกัน, มีเอกสารช่วยเหลือผู้ใช้, ใช้เมาส์ควบคุมการทำงานเป็นหลัก เป็นต้น.

\end{itemize}

